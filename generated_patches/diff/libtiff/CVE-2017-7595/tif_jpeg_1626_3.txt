@@ -1571,6 +1571,7 @@
 	return (1);
 }
 
+
 static int
 JPEGSetupEncode(TIFF* tif)
 {
@@ -1590,11 +1591,6 @@
 
 	sp->photometric = td->td_photometric;
 
-	/*
-	 * Initialize all JPEG parameters to default values.
-	 * Note that jpeg_set_defaults needs legal values for
-	 * in_color_space and input_components.
-	 */
 	if (td->td_planarconfig == PLANARCONFIG_CONTIG) {
 		sp->cinfo.c.input_components = td->td_samplesperpixel;
 		if (sp->photometric == PHOTOMETRIC_YCBCR) {
@@ -1619,16 +1615,15 @@
 	}
 	if (!TIFFjpeg_set_defaults(sp))
 		return (0);
-	/* Set per-file parameters */
+
 	switch (sp->photometric) {
 	case PHOTOMETRIC_YCBCR:
 		sp->h_sampling = td->td_ycbcrsubsampling[0];
+                if (td->td_ycbcrsubsampling[1] <= 0) { // Check for invalid vertical sampling
+                    TIFFErrorExt(tif->tif_clientdata, module, "Invalid vertical sampling value.");
+                    return (0);
+                }
 		sp->v_sampling = td->td_ycbcrsubsampling[1];
-		/*
-		 * A ReferenceBlackWhite field *must* be present since the
-		 * default value is inappropriate for YCbCr.  Fill in the
-		 * proper value if application didn't set it.
-		 */
 		{
 			float *ref;
 			if (!TIFFGetField(tif, TIFFTAG_REFERENCEBLACKWHITE,
@@ -1646,28 +1641,19 @@
 			}
 		}
 		break;
-	case PHOTOMETRIC_PALETTE:		/* disallowed by Tech Note */
+	case PHOTOMETRIC_PALETTE:
 	case PHOTOMETRIC_MASK:
 		TIFFErrorExt(tif->tif_clientdata, module,
 			  "PhotometricInterpretation %d not allowed for JPEG",
 			  (int) sp->photometric);
 		return (0);
 	default:
-		/* TIFF 6.0 forbids subsampling of all other color spaces */
 		sp->h_sampling = 1;
 		sp->v_sampling = 1;
 		break;
 	}
 
-	/* Verify miscellaneous parameters */
-
-	/*
-	 * This would need work if libtiff ever supports different
-	 * depths for different components, or if libjpeg ever supports
-	 * run-time selection of depth.  Neither is imminent.
-	 */
 #ifdef JPEG_LIB_MK1
-        /* BITS_IN_JSAMPLE now permits 8 and 12 --- dgilbert */
 	if (td->td_bitspersample != 8 && td->td_bitspersample != 12) 
 #else
 	if (td->td_bitspersample != BITS_IN_JSAMPLE )
@@ -1679,7 +1665,7 @@
 	}
 	sp->cinfo.c.data_precision = td->td_bitspersample;
 #ifdef JPEG_LIB_MK1
-        sp->cinfo.c.bits_in_jsample = td->td_bitspersample;
+	sp->cinfo.c.bits_in_jsample = td->td_bitspersample;
 #endif
 	if ((((tif)->tif_flags & 0x00400U) != 0)) {
 		if ((td->td_tilelength % (sp->v_sampling * DCTSIZE)) != 0) {
@@ -1704,30 +1690,25 @@
 		}
 	}
 
-	/* Create a JPEGTables field if appropriate */
 	if (sp->jpegtablesmode & (JPEGTABLESMODE_QUANT|JPEGTABLESMODE_HUFF)) {
                 if( sp->jpegtables == NULL
                     || memcmp(sp->jpegtables,"\0\0\0\0\0\0\0\0\0",8) == 0 )
                 {
                         if (!prepare_JPEGTables(tif))
                                 return (0);
-                        /* Mark the field present */
-                        /* Can't use TIFFSetField since BEENWRITING is already set! */
                         tif->tif_flags |= TIFF_DIRTYDIRECT;
                         TIFFSetFieldBit(tif, FIELD_JPEGTABLES);
                 }
 	} else {
-		/* We do not support application-supplied JPEGTables, */
-		/* so mark the field not present */
 		TIFFClrFieldBit(tif, FIELD_JPEGTABLES);
 	}
 
-	/* Direct libjpeg output to libtiff's output buffer */
 	TIFFjpeg_data_dest(sp, tif);
 
 	return (1);
 }
 
+
 /*
  * Set encoding state at the start of a strip or tile.
  */
