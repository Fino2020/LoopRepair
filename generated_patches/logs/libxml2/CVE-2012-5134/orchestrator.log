2025-02-02 13:31:50.319 | INFO     | scenario:build:265 - loaded bug scenario: Scenario(subject='libxml2', name='CVE-2012-5134', directory='/data/vulnloc/libxml2/CVE-2012-5134', build_directory='/data/vulnloc/libxml2/CVE-2012-5134/src', source_directory='/data/vulnloc/libxml2/CVE-2012-5134/src', tag_id='libxml2_CVE-2012-5134', binary_path='/data//vulnloc/libxml2/CVE-2012-5134/src/xmllint', clean_command='make clean', prebuild_command='exit 0', build_command='make CFLAGS="${INJECT_CFLAGS}" CXXFLAGS="${INJECT_CXXFLAGS}" LDFLAGS="${INJECT_LDFLAGS}" xmllint', crashing_command='$POC', crashing_input='/CrashRepair/experiments/vulnloc/libxml2/CVE-2012-5134/tests/1.xml', shell=Shell(cwd='/data/vulnloc/libxml2/CVE-2012-5134'), crash_test=Test(name='crash', command='/data//vulnloc/libxml2/CVE-2012-5134/src/xmllint /CrashRepair/experiments/vulnloc/libxml2/CVE-2012-5134/tests/1.xml', expected_exit_code=0, expected_stdout=None, bad_output='SUMMARY: AddressSanitizer:', asan_options=None, ubsan_options=None), sanitizer_flags='-fsanitize=address', additional_klee_flags='', expected_exit_code_for_crashing_input=0, should_terminate_early=True, fuzzer_tests=[], fuzzer=None, time_limit_minutes_validation=None, time_limit_seconds_single_test=30, time_limit_minutes_analysis=3600, halt_on_error=True, rebuild_for_validation=False, asan_options=None, ubsan_options=None, use_ghost_functions=True, acceptable_patch_limit=None)
2025-02-02 13:31:50.319 | INFO     | scenario:fuzz:426 - skipping fuzzing: fuzzer disabled
2025-02-02 13:31:50.320 | INFO     | analyzer:run:114 - running analysis with timeout: 60 minutes
2025-02-02 13:31:50.320 | DEBUG    | analyzer:write_config_to_file:88 - generated analyzer config:

dir_exp:/data/vulnloc/libxml2/CVE-2012-5134
tag_id:libxml2_CVE-2012-5134
src_directory:/data/vulnloc/libxml2/CVE-2012-5134/src
binary_path:/data//vulnloc/libxml2/CVE-2012-5134/src/xmllint
config_command:exit 0
build_command:make CFLAGS="${INJECT_CFLAGS}" CXXFLAGS="${INJECT_CXXFLAGS}" LDFLAGS="${INJECT_LDFLAGS}" xmllint
test_input_list:$POC
poc_list:/CrashRepair/experiments/vulnloc/libxml2/CVE-2012-5134/tests/1.xml
klee_flags:--link-llvm-lib=/CrashRepair/lib/libcrepair_proxy.bca 

2025-02-02 13:31:50.320 | DEBUG    | analyzer:run:124 - wrote analyzer config file to: /tmp/tmp04dzgqen
2025-02-02 13:31:50.320 | DEBUG    | shell:__call__:41 - executing: crepair --conf=/tmp/tmp04dzgqen
[K[1;36m
====================================================================================================

	Starting CRepair (C Crash Repair) 
====================================================================================================
[0m
[K[1;36m
	Loading Configurations
	__________________________________________________________________________________________
[0m
[K	[1;34mreading configuration values from arguments[0m
[K	[1;34mreading configuration values form configuration file[0m
[K	[1;37m	[file] /tmp/tmp04dzgqen[0m
[K	[1;34mupdating configuration values[0m
[K	[1;34mreading test configuration[0m
[K	[1;34mreading seed information[0m
[K	[1;37m	[config] stack size: 15000[0m
[K	[1;37m	[config] collecting stats: False[0m
[K	[1;37m	[config] number of tests: 1[0m
[K	[1;37m	[config] number of cores: 8[0m
[K	[1;37m	[config] klee concrete execution timeout: 600[0m
[K	[1;37m	[config] klee concolic execution timeout: 1200[0m
[K	[1;37m	[config] synthesize subset expressions: True[0m
[K	[1;37m	[config] window size for taint locations: 500[0m
[K	[1;37m	[config] window size for taint values: 500000[0m
[K[1;36m

	Analyzing Program
====================================================================================================
[0m
[K[1;36m
	Test Case #1
	__________________________________________________________________________________________
[0m
[K[1;36m
		Running Concrete Execution
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37mUsing Arguments: ['$POC'][0m
[K	[1;37m	[0m[K     [1;37mUsing Input File: /CrashRepair/experiments/vulnloc/libxml2/CVE-2012-5134/tests/1.xml[0m
[K	[1;34m	building program[0m
[K	[1;34m		setting environment variables[0m
[K	[1;34m		cleaning files[0m
[K	[1;34m		configuring program[0m
[K	[1;34m		compiling program[0m
[K	[1;37m	[0m[K     [1;37mUsing Binary: /data//vulnloc/libxml2/CVE-2012-5134/src/xmllint[0m
[K	[1;34m	extracting bytecode[0m
[K	[1;34m	executing klee in concrete mode[0m
[K	[1;34m	extracting instruction trace[0m
[K	[1;37m		[note] program crashed[0m
[K	[1;34m	collecting tainted expressions[0m
[K	[1;34m	collecting tainted concrete values[0m
[K	[1;34m	collecting memory allocations/de-allocations[0m
[K	[1;34m	collecting pointer mapping[0m
[K	[1;34m	extracting crash information[0m
[K	[1;37m		[0m[K     [1;37m[info] crash type: memory read overflow[0m
[K	[1;37m		[0m[K     [1;37m[info] crash location: /data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4079:16[0m
[K	[1;37m		[0m[K     [1;37m[info] crash function: xmlParseAttValueComplex[0m
[K	[1;37m		[0m[K     [1;37m[info] crash address: 141152[0m
[K	[1;37m		[0m[K     [1;37m[info] crash free constraint: ((@var(integer, len) - 1) < (size  @var(pointer,
                             buf)))[0m
[K	[1;37m		[0m[K     [1;37m[info] crash inducing variables: (base  @var(pointer, buf)), (size  @var(pointer, buf)),
                             buf, len[0m
[K	[1;37m			[info] identified crash type: memory read overflow[0m
[K[1;36m
		Running Concolic Execution
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37mUsing Arguments: ['$POC'][0m
[K	[1;37m	[0m[K     [1;37mUsing Input File: /CrashRepair/experiments/vulnloc/libxml2/CVE-2012-5134/tests/1.xml[0m
[K	[1;34m	building program[0m
[K	[1;34m		setting environment variables[0m
[K	[1;34m		cleaning files[0m
[K	[1;34m		configuring program[0m
[K	[1;34m		compiling program[0m
[K	[1;34m	extracting bytecode[0m
[K	[1;34m	generating ktest file[0m
[K	[1;34m	executing klee in concolic mode[0m
[K	[1;34m	extracting largest symbolic path[0m
[K	[1;34m	extracting instruction trace[0m
[K	[1;37m		[note] program crashed[0m
[K	[1;34m	collecting tainted expressions[0m
[K	[1;34m	collecting memory allocations/de-allocations[0m
[K	[1;34m	collecting pointer mapping[0m
[K	[1;37m		[0m[K     [1;37m[info] Symbolic Mapping: buf -> [bv514854623][0m
[K	[1;37m		[0m[K     [1;37m[info] Symbolic Mapping: (size  @var(pointer, buf)) -> [][0m
[K	[1;37m		[0m[K     [1;37m[info] Symbolic Mapping: (base  @var(pointer, buf)) -> [bv514854623][0m
[K	[1;37m		[0m[K     [1;37m[info] Symbolic Mapping: len -> [][0m
[K[1;36m

	Fix Localization
====================================================================================================
[0m
[K[1;36m
	Generating Fix Locations
	__________________________________________________________________________________________
[0m
[K	[1;34m	generating taint map[0m
[K	[1;37m		[0m[K     [1;37m[info] found 11777 tainted locations[0m
[K	[1;34m		starting parallel computing[0m
[K	[1;34m		waiting for thread completion[0m
[K	[1;37m		[0m[K     [1;37m[info] found 2 source files[0m
[K	[1;37m		[0m[K     [1;37m[info] found 5 executed functions[0m
[K	[1;34m	generating possible fix locations[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] xmlParseAttValueComplex,
                             /data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4079:41[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] xmlParseAttValueComplex,
                             /data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4079:29[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] xmlParseAttValueComplex,
                             /data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4079:16[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] xmlParseAttValueComplex,
                             /data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4079:24[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] xmlParseAttValueComplex,
                             /data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4079:20[0m
[K[1;36m
	Localizing Constraints
	__________________________________________________________________________________________
[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3920:5
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] ((@var(integer, in_space) - 1) < @var(integer, buf_size))[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3921:23
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] ((@var(integer, in_space) - 1) < @var(integer, buf_size))[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3922:5
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] ((@var(integer, in_space) - 1) < @var(integer, buf_size))[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3935:9
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] ((@var(integer, len) - 1) < @var(integer, buf_size))[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3943:6
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] ((@var(integer, in_space) - 1) < @var(integer, buf_size))[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3968:7
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] ((@var(integer, len) - 1) < @var(integer, buf_size))[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3971:7
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] ((@var(integer, len) - 1) < @var(integer, buf_size))[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3971:14
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] ((@var(integer, len) - 1) < @var(integer, buf_size))[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4055:7
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] ((@var(integer, in_space) - 1) < @var(integer, buf_size))[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4056:4
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] ((@var(integer, in_space) - 1) < @var(integer, buf_size))[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4057:4
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] ((@var(integer, in_space) - 1) < @var(integer, buf_size))[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4072:2
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] ((@var(integer, ctxt->progressive) - 1) < @var(integer, buf_size))[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4079:9
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] ((@var(integer, len) - 1) < @var(integer, buf_size))[0m
[K[1;32m
	localization information saved at /CrashRepair/output/libxml2_CVE-2012-5134/localization.json[0m
[K[1;32m
	state values saved at /CrashRepair/output/libxml2_CVE-2012-5134/values/[0m
[K	[1;37m
Run time statistics:
-----------------------
[0m
[K	[1;37mStartup: 0.000 minutes[0m
[K	[1;37mBuild: 0 minutes[0m
[K	[1;37mConcrete Analysis: 0.812 minutes[0m
[K	[1;37mConcolic Analysis: 0.563 minutes[0m
[K	[1;37mTotal Analysis: 1.408 minutes[0m
[K	[1;37mLocalization: 0.905 minutes[0m
[K[1;32m
CRepair finished successfully after 2.321 minutes 
[0m
2025-02-02 13:34:10.272 | WARNING  | analyzer:run:143 - analysis output directory does not exist [/data/vulnloc/libxml2/CVE-2012-5134/analysis]: creating...
2025-02-02 13:34:10.380 | INFO     | scenario:generate:454 - generating candidate repairs in implicated files: {'/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c'}
total_candidates:[{'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,22 +3903,24 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n     /*\n      * allocate a translation buffer.\n      */\n-    buf_size = XML_PARSER_BUFFER_SIZE;\n+    buf_size = XML_PARSER_BUFFER_SIZE; // Original vulnerability line\n+    if (buf_size > XML_MAX_BUFFER_SIZE)   // Added buffer size check\n+        buf_size = XML_MAX_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n     if (buf == NULL) goto mem_error;\n \n@@ -3938,139 +3941,139 @@\n                            "AttValue lenght too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        /*\n+                         * The reparsing will be done in xmlStringGetNodeList()\n+                         * called by the attribute() function in SAX.c\n+                         */\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    /*\n+                     * This may look absurd but is needed to detect\n+                     * entities problems\n+                     */\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    /*\n+                     * Just output the reference\n+                     */\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,17 +4083,17 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+    NEXT;\n \n     /*\n      * There we potentially risk an overflow, don\'t allow attribute value of\n@@ -4115,6 +4118,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 0, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3920:5'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,20 +3903,20 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n     /*\n-     * allocate a translation buffer.\n+     * allocate a translation buffer with a dynamic size.\n      */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n@@ -3935,142 +3936,147 @@\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            buf_size += 10; // dynamic resizing here\n+                            buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            buf_size += 10; // dynamic resizing here\n+                            buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        buf_size += 10; // dynamic resizing here\n+                        buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        buf_size += 10; // dynamic resizing here\n+                        buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    buf_size += 10; // dynamic resizing here\n+                                    buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            buf_size += 10; // dynamic resizing here\n+                            buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    /*\n+                     * This may look absurd but is needed to detect\n+                     * entities problems\n+                     */\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    /*\n+                     * Just output the reference\n+                     */\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        buf_size += i + 10; // dynamic resizing here\n+                        buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                    }\n+                    for (; i > 0; i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l, buf, len, 0x20);\n+                        while (len + 10 > buf_size) {\n+                            buf_size += 10; // dynamic resizing here\n+                            buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l, buf, len, c);\n+                if (len + 10 > buf_size) {\n+                    buf_size += 10; // dynamic resizing here\n+                    buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4086,25 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n     /*\n      * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n+     * length more than INT_MAX it is a very reasonable assumption!\n      */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4121,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 1, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3920:5'}, {'diff': '@@ -3890,34 +3890,34 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n     xmlChar *buf = NULL;\n     xmlChar *rep = NULL;\n     size_t len = 0;\n-    size_t buf_size = 0;\n+    size_t buf_size = XML_PARSER_BUFFER_SIZE; // Initialize buf_size here\n     int c, l, in_space = 0;\n     xmlChar *current = NULL;\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n     /*\n      * allocate a translation buffer.\n      */\n-    buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n     if (buf == NULL) goto mem_error;\n \n@@ -3935,142 +3935,142 @@\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n"); // Fix typo: "lenght" to "length"\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        /*\n+                         * The reparsing will be done in xmlStringGetNodeList()\n+                         * called by the attribute() function in SAX.c\n+                         */\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    /*\n+                     * This may look absurd but is needed to detect\n+                     * entities problems\n+                     */\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    /*\n+                     * Just output the reference\n+                     */\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (; i > 0; i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l, buf, len, 0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l, buf, len, c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4080,25 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n     /*\n      * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n+     * length more than INT_MAX it is a very reasonable assumption !\n      */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n"); // Fix typo: "lenght" to "length"\n         goto mem_error;\n     }\n \n@@ -4115,6 +4115,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 2, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3920:5'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,16 +3903,16 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n     /*\n@@ -3935,142 +3936,131 @@\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4070,21 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n-    /*\n-     * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n-     */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4101,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 3, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3920:5'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,22 +3903,22 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n     /*\n      * allocate a translation buffer.\n      */\n-    buf_size = XML_PARSER_BUFFER_SIZE;\n+    buf_size = XML_PARSER_BUFFER_SIZE; // Ensure this is a reasonable size.\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n     if (buf == NULL) goto mem_error;\n \n@@ -3935,142 +3936,138 @@\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    /*\n+                     * This may look absurd but is needed to detect\n+                     * entities problems\n+                     */\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    /*\n+                     * Just output the reference\n+                     */\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4077,25 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n     /*\n      * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n+     * length more than INT_MAX it is a very reasonable assumption !\n      */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4112,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 4, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3920:5'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3935,7 +3936,7 @@\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n \tif (c == 0) break;\n@@ -4094,11 +4095,11 @@\n \n     /*\n      * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n+     * length more than INT_MAX it is a very reasonable assumption !\n      */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4116,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 5, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3921:23'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,22 +3903,26 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n     /*\n      * allocate a translation buffer.\n      */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n+    if (buf_size > INT_MAX) { // Prevent overflow by ensuring buffer size is reasonable.\n+        xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED, "AttValue length too long\\n");\n+        goto mem_error;\n+    }\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n     if (buf == NULL) goto mem_error;\n \n@@ -3935,142 +3940,142 @@\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        /*\n+                         * The reparsing will be done in xmlStringGetNodeList()\n+                         * called by the attribute() function in SAX.c\n+                         */\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    /*\n+                     * This may look absurd but is needed to detect\n+                     * entities problems\n+                     */\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    /*\n+                     * Just output the reference\n+                     */\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4085,25 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n     /*\n      * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n+     * length more than INT_MAX it is a very reasonable assumption !\n      */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4120,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 6, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3921:23'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,22 +3903,26 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n     /*\n      * allocate a translation buffer.\n      */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n+    if (buf_size > INT_MAX) {\n+        xmlFatalErr(ctxt, XML_ERR_MEMORY_ALLOCATION, "Buffer size exceeds limit\\n");\n+        return NULL;\n+    }\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n     if (buf == NULL) goto mem_error;\n \n@@ -3935,142 +3940,142 @@\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        /*\n+                         * The reparsing will be done in xmlStringGetNodeList()\n+                         * called by the attribute() function in SAX.c\n+                         */\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    /*\n+                     * This may look absurd but is needed to detect\n+                     * entities problems\n+                     */\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    /*\n+                     * Just output the reference\n+                     */\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4085,25 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n     /*\n      * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n+     * length more than INT_MAX it is a very reasonable assumption !\n      */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4120,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 7, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3921:23'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,24 +3903,30 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n     /*\n      * allocate a translation buffer.\n      */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n+    if (buf_size > INT_MAX) {\n+        xmlFatalErr(ctxt, XML_ERR_MEMORY_ALLOCATION, "Buffer size exceeds limit\\n");\n+        goto mem_error;\n+    }\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n-    if (buf == NULL) goto mem_error;\n+    if (buf == NULL) {\n+        goto mem_error;\n+    }\n \n     /*\n      * OK loop until we reach one of the ending char or a size limit.\n@@ -3935,142 +3942,142 @@\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        /*\n+                         * The reparsing will be done in xmlStringGetNodeList()\n+                         * called by the attribute() function in SAX.c\n+                         */\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    /*\n+                     * This may look absurd but is needed to detect\n+                     * entities problems\n+                     */\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    /*\n+                     * Just output the reference\n+                     */\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4087,26 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n-    } else\n-\tNEXT;\n+    } else {\n+        NEXT;\n+    }\n \n     /*\n      * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n+     * length more than INT_MAX it is a very reasonable assumption !\n      */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4123,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 8, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3921:23'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,22 +3903,27 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n     /*\n      * allocate a translation buffer.\n      */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n+    if (buf_size > XML_MAX_ATTRIBUTE_LENGTH) {\n+        xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                       "Attribute length exceeds maximum allowed length\\n");\n+        return NULL;\n+    }\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n     if (buf == NULL) goto mem_error;\n \n@@ -3935,142 +3941,142 @@\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        /*\n+                         * The reparsing will be done in xmlStringGetNodeList()\n+                         * called by the attribute() function in SAX.c\n+                         */\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    /*\n+                     * This may look absurd but is needed to detect\n+                     * entities problems\n+                     */\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    /*\n+                     * Just output the reference\n+                     */\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4086,25 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n     /*\n      * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n+     * length more than INT_MAX it is a very reasonable assumption !\n      */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4121,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 9, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3921:23'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,16 +3903,16 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n     /*\n@@ -3919,7 +3920,10 @@\n      */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n-    if (buf == NULL) goto mem_error;\n+    if (buf == NULL) {\n+        xmlErrMemory(ctxt, NULL);\n+        return NULL;   // Changed handling of memory error\n+    }\n \n     /*\n      * OK loop until we reach one of the ending char or a size limit.\n@@ -3935,142 +3939,142 @@\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        /*\n+                         * The reparsing will be done in xmlStringGetNodeList()\n+                         * called by the attribute() function in SAX.c\n+                         */\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    /*\n+                     * This may look absurd but is needed to detect\n+                     * entities problems\n+                     */\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    /*\n+                     * Just output the reference\n+                     */\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4084,25 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n     /*\n      * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n+     * length more than INT_MAX it is a very reasonable assumption !\n      */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4119,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 10, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3922:5'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,16 +3903,16 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n     /*\n@@ -3919,7 +3920,10 @@\n      */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n-    if (buf == NULL) goto mem_error;\n+    if (buf == NULL) {\n+        xmlErrMemory(ctxt, NULL); // Modify to handle memory allocation error\n+        return NULL; // Add return statement to prevent further processing\n+    }\n \n     /*\n      * OK loop until we reach one of the ending char or a size limit.\n@@ -3935,142 +3939,142 @@\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        /*\n+                         * The reparsing will be done in xmlStringGetNodeList()\n+                         * called by the attribute() function in SAX.c\n+                         */\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    /*\n+                     * This may look absurd but is needed to detect\n+                     * entities problems\n+                     */\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    /*\n+                     * Just output the reference\n+                     */\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4084,25 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n     /*\n      * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n+     * length more than INT_MAX it is a very reasonable assumption !\n      */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4119,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 11, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3922:5'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,16 +3903,16 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n     /*\n@@ -3919,7 +3920,10 @@\n      */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n-    if (buf == NULL) goto mem_error;\n+    if (buf == NULL) {\n+        xmlErrMemory(ctxt, NULL);  // Added error handling for memory allocation failure\n+        return(NULL);  // Ensure to return NULL if memory allocation fails\n+    }\n \n     /*\n      * OK loop until we reach one of the ending char or a size limit.\n@@ -3938,139 +3942,139 @@\n                            "AttValue lenght too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        /*\n+                         * The reparsing will be done in xmlStringGetNodeList()\n+                         * called by the attribute() function in SAX.c\n+                         */\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    /*\n+                     * This may look absurd but is needed to detect\n+                     * entities problems\n+                     */\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    /*\n+                     * Just output the reference\n+                     */\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (; i > 0; i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l, buf, len, 0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l, buf, len, c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,21 +4084,21 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n     /*\n      * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n+     * length more than INT_MAX it is a very reasonable assumption !\n      */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n@@ -4115,6 +4119,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 12, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3922:5'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,16 +3903,16 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n     /*\n@@ -3919,7 +3920,11 @@\n      */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n-    if (buf == NULL) goto mem_error;\n+    \n+    if (buf == NULL) {\n+        xmlErrMemory(ctxt, NULL);\n+        return NULL; // Added to handle memory error more gracefully\n+    }\n \n     /*\n      * OK loop until we reach one of the ending char or a size limit.\n@@ -3935,142 +3940,142 @@\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        /*\n+                         * The reparsing will be done in xmlStringGetNodeList()\n+                         * called by the attribute() function in SAX.c\n+                         */\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[length++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    /*\n+                     * This may look absurd but is needed to detect\n+                     * entities problems\n+                     */\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    /*\n+                     * Just output the reference\n+                     */\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (; i > 0; i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l, buf, len, 0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l, buf, len, c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4085,25 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n     /*\n      * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n+     * length more than INT_MAX it is a very reasonable assumption !\n      */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4120,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 13, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3922:5'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3919,7 +3920,10 @@\n      */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n-    if (buf == NULL) goto mem_error;\n+    if (buf == NULL) {\n+\txmlErrMemory(ctxt, NULL);\n+\treturn NULL; // Modified line\n+    }\n \n     /*\n      * OK loop until we reach one of the ending char or a size limit.\n@@ -4115,6 +4119,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 14, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3922:5'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,16 +3903,16 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n     /*\n@@ -3932,145 +3933,145 @@\n          * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE\n          * special option is given\n          */\n-        if ((len > XML_MAX_TEXT_LENGTH) &&\n+        if ((len >= XML_MAX_TEXT_LENGTH) &&  // Changed from len > XML_MAX_TEXT_LENGTH to len >= XML_MAX_TEXT_LENGTH\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        /*\n+                         * The reparsing will be done in xmlStringGetNodeList()\n+                         * called by the attribute() function in SAX.c\n+                         */\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    /*\n+                     * This may look absurd but is needed to detect\n+                     * entities problems\n+                     */\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    /*\n+                     * Just output the reference\n+                     */\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (; i > 0; i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4081,25 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n     /*\n      * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n+     * length more than INT_MAX it is a very reasonable assumption !\n      */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4116,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 15, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3935:9'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,16 +3903,16 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n     /*\n@@ -3932,145 +3933,145 @@\n          * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE\n          * special option is given\n          */\n-        if ((len > XML_MAX_TEXT_LENGTH) &&\n+        if ((len >= XML_MAX_TEXT_LENGTH) && \n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        /*\n+                         * The reparsing will be done in xmlStringGetNodeList()\n+                         * called by the attribute() function in SAX.c\n+                         */\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    /*\n+                     * This may look absurd but is needed to detect\n+                     * entities problems\n+                     */\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    /*\n+                     * Just output the reference\n+                     */\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4081,25 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n     /*\n      * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n+     * length more than INT_MAX it is a very reasonable assumption !\n      */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4116,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 16, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3935:9'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,175 +3903,155 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n-    /*\n-     * allocate a translation buffer.\n-     */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n     if (buf == NULL) goto mem_error;\n \n-    /*\n-     * OK loop until we reach one of the ending char or a size limit.\n-     */\n     c = CUR_CHAR(l);\n     while (((ctxt->input->cur[0] != limit) && /* checked */\n             (IS_CHAR(c)) && (c != \'<\')) &&\n             (ctxt->instate != XML_PARSER_EOF)) {\n-        /*\n-         * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE\n-         * special option is given\n-         */\n-        if ((len > XML_MAX_TEXT_LENGTH) &&\n-            ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n+        \n+        if (len >= XML_MAX_TEXT_LENGTH && (ctxt->options & XML_PARSE_HUGE) == 0) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                    (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) {\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (; i > 0; i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l, buf, len, 0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l, buf, len, c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4061,21 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n-    /*\n-     * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n-     */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4092,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 17, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3935:9'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,16 +3903,16 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n     /*\n@@ -3929,148 +3930,148 @@\n             (IS_CHAR(c)) && (c != \'<\')) &&\n             (ctxt->instate != XML_PARSER_EOF)) {\n         /*\n-         * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE\n-         * special option is given\n+         * Impose a reasonable limit on attribute size and ensure it\'s\n+         * well-formed, unless XML_PARSE_HUGE special option is given\n          */\n-        if ((len > XML_MAX_TEXT_LENGTH) &&\n+        if ((len >= XML_MAX_TEXT_LENGTH) && \n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        /*\n+                         * The reparsing will be done in xmlStringGetNodeList()\n+                         * called by the attribute() function in SAX.c\n+                         */\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    /*\n+                     * This may look absurd but is needed to detect\n+                     * entities problems\n+                     */\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    /*\n+                     * Just output the reference\n+                     */\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4081,25 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n     /*\n      * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n+     * length more than INT_MAX it is a very reasonable assumption !\n      */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4116,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 18, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3935:9'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,175 +3903,156 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n-    /*\n-     * allocate a translation buffer.\n-     */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n     if (buf == NULL) goto mem_error;\n \n-    /*\n-     * OK loop until we reach one of the ending char or a size limit.\n-     */\n     c = CUR_CHAR(l);\n     while (((ctxt->input->cur[0] != limit) && /* checked */\n             (IS_CHAR(c)) && (c != \'<\')) &&\n             (ctxt->instate != XML_PARSER_EOF)) {\n-        /*\n-         * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE\n-         * special option is given\n-         */\n-        if ((len > XML_MAX_TEXT_LENGTH) &&\n+        \n+        if ((len >= XML_MAX_TEXT_LENGTH) && // Changed condition for attribute size check\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) {\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (; i > 0; i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l, buf, len, 0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l, buf, len, c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4062,21 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n-    /*\n-     * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n-     */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4093,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 19, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3935:9'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,175 +3903,152 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n-    /*\n-     * allocate a translation buffer.\n-     */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n     if (buf == NULL) goto mem_error;\n \n-    /*\n-     * OK loop until we reach one of the ending char or a size limit.\n-     */\n     c = CUR_CHAR(l);\n-    while (((ctxt->input->cur[0] != limit) && /* checked */\n+    while (((ctxt->input->cur[0] != limit) && \n             (IS_CHAR(c)) && (c != \'<\')) &&\n             (ctxt->instate != XML_PARSER_EOF)) {\n-        /*\n-         * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE\n-         * special option is given\n-         */\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n                            "AttValue lenght too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) {\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l, buf, len, 0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l, buf, len, c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,22 +4058,18 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n-    /*\n-     * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n-     */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n                        "AttValue lenght too long\\n");\n@@ -4115,6 +4089,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 20, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3943:6'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,175 +3903,160 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n-    /*\n-     * allocate a translation buffer.\n-     */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n     if (buf == NULL) goto mem_error;\n \n-    /*\n-     * OK loop until we reach one of the ending char or a size limit.\n-     */\n     c = CUR_CHAR(l);\n     while (((ctxt->input->cur[0] != limit) && /* checked */\n             (IS_CHAR(c)) && (c != \'<\')) &&\n             (ctxt->instate != XML_PARSER_EOF)) {\n-        /*\n-         * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE\n-         * special option is given\n-         */\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n                            "AttValue lenght too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            // Modify to handle excessive consecutive spaces\n+            if (in_space && normalize) {\n+                NEXTL(l);\n+                c = CUR_CHAR(l);\n+                continue;\n+            }\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) {\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,22 +4066,18 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n-    /*\n-     * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n-     */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n                        "AttValue lenght too long\\n");\n@@ -4115,6 +4097,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 21, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3943:6'}, {'diff': "@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3940,7 +3941,7 @@\n         }\n \tif (c == 0) break;\n \tif (c == '&') {\n-\t    in_space = 0;\n+\t    in_space = 0; // Vulnerable line\n \t    if (ctxt->input->cur[1] == '#') {\n \t\tint val = xmlParseCharRef(ctxt);\n \n@@ -4115,6 +4116,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n", 'id': 22, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3943:6'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,175 +3903,157 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n-    /*\n-     * allocate a translation buffer.\n-     */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n     if (buf == NULL) goto mem_error;\n \n-    /*\n-     * OK loop until we reach one of the ending char or a size limit.\n-     */\n     c = CUR_CHAR(l);\n     while (((ctxt->input->cur[0] != limit) && /* checked */\n             (IS_CHAR(c)) && (c != \'<\')) &&\n             (ctxt->instate != XML_PARSER_EOF)) {\n-        /*\n-         * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE\n-         * special option is given\n-         */\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n                            "AttValue lenght too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) {\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n+                                    if (len + 10 > buf_size) {\n+                                        growBuffer(buf, 10);\n+                                    }\n                                     buf[len++] = 0x20;\n                                     current++;\n-                                } else\n+                                } else {\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                    if (len + 10 > buf_size) {\n+                                        growBuffer(buf, 10);\n+                                    }\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,22 +4063,18 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n-    /*\n-     * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n-     */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n                        "AttValue lenght too long\\n");\n@@ -4115,6 +4094,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 23, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3943:6'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,175 +3903,149 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n-    /*\n-     * allocate a translation buffer.\n-     */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n     if (buf == NULL) goto mem_error;\n \n-    /*\n-     * OK loop until we reach one of the ending char or a size limit.\n-     */\n     c = CUR_CHAR(l);\n-    while (((ctxt->input->cur[0] != limit) && /* checked */\n-            (IS_CHAR(c)) && (c != \'<\')) &&\n-            (ctxt->instate != XML_PARSER_EOF)) {\n-        /*\n-         * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE\n-         * special option is given\n-         */\n+    while (((ctxt->input->cur[0] != limit) && (IS_CHAR(c)) && (c != \'<\')) &&\n+           (ctxt->instate != XML_PARSER_EOF)) {\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n                            "AttValue lenght too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n-                                if ((*current == 0xD) || (*current == 0xA) ||\n-                                    (*current == 0x9)) {\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) && (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) && (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) && (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { \n+                                if ((*current == 0xD) || (*current == 0xA) || (*current == 0x9)) {\n+                                    if (len + 10 > buf_size) {\n+                                        growBuffer(buf, 10);\n+                                    }\n                                     buf[len++] = 0x20;\n                                     current++;\n-                                } else\n+                                } else {\n+                                    if (len + 10 > buf_size) {\n+                                        growBuffer(buf, 10);\n+                                    }\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) && (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (; i > 0; i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        COPY_BUF(l, buf, len, 0x20);\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+                COPY_BUF(l, buf, len, c);\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,22 +4055,18 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n-    /*\n-     * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n-     */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n                        "AttValue lenght too long\\n");\n@@ -4115,6 +4086,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 24, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3943:6'}, {'diff': '@@ -3890,34 +3890,34 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n     xmlChar *buf = NULL;\n     xmlChar *rep = NULL;\n     size_t len = 0;\n-    size_t buf_size = 0;\n+    size_t buf_size = XML_PARSER_BUFFER_SIZE; // Initialized to a safe size\n     int c, l, in_space = 0;\n     xmlChar *current = NULL;\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n     /*\n      * allocate a translation buffer.\n      */\n-    buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n     if (buf == NULL) goto mem_error;\n \n@@ -3935,142 +3935,160 @@\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            buf_size += 10; // Increase buffer size to prevent overflow\n+                            buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                            if (buf == NULL) goto mem_error; // Check if realloc succeeded\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        /*\n+                         * The reparsing will be done in xmlStringGetNodeList()\n+                         * called by the attribute() function in SAX.c\n+                         */\n+                        if (len + 10 > buf_size) {\n+                            buf_size += 10; // Increase buffer size to prevent overflow\n+                            buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                            if (buf == NULL) goto mem_error; // Check if realloc succeeded\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        buf_size += 10; // Increase buffer size to prevent overflow\n+                        buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                        if (buf == NULL) goto mem_error; // Check if realloc succeeded\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        buf_size += 10; // Increase buffer size to prevent overflow\n+                        buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                        if (buf == NULL) goto mem_error; // Check if realloc succeeded\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    buf_size += 10; // Increase buffer size to prevent overflow\n+                                    buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                                    if (buf == NULL) goto mem_error; // Check if realloc succeeded\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            buf_size += 10; // Increase buffer size to prevent overflow\n+                            buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                            if (buf == NULL) goto mem_error; // Check if realloc succeeded\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    /*\n+                     * This may look absurd but is needed to detect\n+                     * entities problems\n+                     */\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    /*\n+                     * Just output the reference\n+                     */\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        buf_size += i + 10; // Increase buffer size to prevent overflow\n+                        buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                        if (buf == NULL) goto mem_error; // Check if realloc succeeded\n+                    }\n+                    for (; i > 0; i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l, buf, len, 0x20);\n+                        while (len + 10 > buf_size) {\n+                            buf_size += 10; // Increase buffer size to prevent overflow\n+                            buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                            if (buf == NULL) goto mem_error; // Check if realloc succeeded\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l, buf, len, c);\n+                if (len + 10 > buf_size) {\n+                    buf_size += 10; // Increase buffer size to prevent overflow\n+                    buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                    if (buf == NULL) goto mem_error; // Check if realloc succeeded\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,30 +4098,30 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n     /*\n      * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n+     * length more than INT_MAX it is a very reasonable assumption !\n      */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n     if (attlen != NULL) *attlen = (int) len;\n-    return(buf);\n+    return (buf);\n \n mem_error:\n     xmlErrMemory(ctxt, NULL);\n@@ -4112,9 +4130,10 @@\n         xmlFree(buf);\n     if (rep != NULL)\n         xmlFree(rep);\n-    return(NULL);\n+    return (NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 25, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3968:7'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,16 +3903,16 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n     /*\n@@ -3935,142 +3936,202 @@\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            size_t new_size = buf_size + 10;\n+                            xmlChar *new_buf = (xmlChar *) xmlRealloc(buf, new_size);\n+                            if (new_buf == NULL) {\n+                                xmlFree(buf);\n+                                goto mem_error;\n+                            }\n+                            buf = new_buf;\n+                            buf_size = new_size;\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            size_t new_size = buf_size + 10;\n+                            xmlChar *new_buf = (xmlChar *) xmlRealloc(buf, new_size);\n+                            if (new_buf == NULL) {\n+                                xmlFree(buf);\n+                                goto mem_error;\n+                            }\n+                            buf = new_buf;\n+                            buf_size = new_size;\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        size_t new_size = buf_size + 10;\n+                        xmlChar *new_buf = (xmlChar *) xmlRealloc(buf, new_size);\n+                        if (new_buf == NULL) {\n+                            xmlFree(buf);\n+                            goto mem_error;\n+                        }\n+                        buf = new_buf;\n+                        buf_size = new_size;\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        size_t new_size = buf_size + 10;\n+                        xmlChar *new_buf = (xmlChar *) xmlRealloc(buf, new_size);\n+                        if (new_buf == NULL) {\n+                            xmlFree(buf);\n+                            goto mem_error;\n+                        }\n+                        buf = new_buf;\n+                        buf_size = new_size;\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    size_t new_size = buf_size + 10;\n+                                    xmlChar *new_buf = (xmlChar *) xmlRealloc(buf, new_size);\n+                                    if (new_buf == NULL) {\n+                                        xmlFree(buf);\n+                                        xmlFree(rep);\n+                                        goto mem_error;\n+                                    }\n+                                    buf = new_buf;\n+                                    buf_size = new_size;\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            size_t new_size = buf_size + 10;\n+                            xmlChar *new_buf = (xmlChar *) xmlRealloc(buf, new_size);\n+                            if (new_buf == NULL) {\n+                                xmlFree(buf);\n+                                goto mem_error;\n+                            }\n+                            buf = new_buf;\n+                            buf_size = new_size;\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    /*\n+                     * This may look absurd but is needed to detect\n+                     * entities problems\n+                     */\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    /*\n+                     * Just output the reference\n+                     */\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        size_t new_size = buf_size + i + 10;\n+                        xmlChar *new_buf = (xmlChar *) xmlRealloc(buf, new_size);\n+                        if (new_buf == NULL) {\n+                            xmlFree(buf);\n+                            goto mem_error;\n+                        }\n+                        buf = new_buf;\n+                        buf_size = new_size;\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 > buf_size) {\n+                            size_t new_size = buf_size + 10;\n+                            xmlChar *new_buf = (xmlChar *) xmlRealloc(buf, new_size);\n+                            if (new_buf == NULL) {\n+                                xmlFree(buf);\n+                                goto mem_error;\n+                            }\n+                            buf = new_buf;\n+                            buf_size = new_size;\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    size_t new_size = buf_size + 10;\n+                    xmlChar *new_buf = (xmlChar *) xmlRealloc(buf, new_size);\n+                    if (new_buf == NULL) {\n+                        xmlFree(buf);\n+                        goto mem_error;\n+                    }\n+                    buf = new_buf;\n+                    buf_size = new_size;\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4141,25 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+    NEXT;\n \n     /*\n      * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n+     * length more than INT_MAX it is a very reasonable assumption !\n      */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4176,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 26, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3968:7'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,175 +3903,172 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n-    /*\n-     * allocate a translation buffer.\n-     */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n     if (buf == NULL) goto mem_error;\n \n-    /*\n-     * OK loop until we reach one of the ending char or a size limit.\n-     */\n     c = CUR_CHAR(l);\n     while (((ctxt->input->cur[0] != limit) && /* checked */\n             (IS_CHAR(c)) && (c != \'<\')) &&\n             (ctxt->instate != XML_PARSER_EOF)) {\n-        /*\n-         * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE\n-         * special option is given\n-         */\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            buf_size += 10; // Increase buffer size appropriately\n+                            buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                            if (buf == NULL) goto mem_error;\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            buf_size += 10; // Increase buffer size appropriately\n+                            buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                            if (buf == NULL) goto mem_error;\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        buf_size += 10; // Increase buffer size appropriately\n+                        buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                        if (buf == NULL) goto mem_error;\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        buf_size += 10; // Increase buffer size appropriately\n+                        buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                        if (buf == NULL) goto mem_error;\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) {\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    buf_size += 10; // Increase buffer size appropriately\n+                                    buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                                    if (buf == NULL) goto mem_error;\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            buf_size += 10; // Increase buffer size appropriately\n+                            buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                            if (buf == NULL) goto mem_error;\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        buf_size += i + 10; // Increase buffer size appropriately\n+                        buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                        if (buf == NULL) goto mem_error;\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 > buf_size) {\n+                            buf_size += 10; // Increase buffer size appropriately\n+                            buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                            if (buf == NULL) goto mem_error;\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    buf_size += 10; // Increase buffer size appropriately\n+                    buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                    if (buf == NULL) goto mem_error;\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4078,21 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n-    /*\n-     * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n-     */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4109,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 27, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3968:7'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,16 +3903,16 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n     /*\n@@ -3935,142 +3936,142 @@\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 >= buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        /*\n+                         * The reparsing will be done in xmlStringGetNodeList()\n+                         * called by the attribute() function in SAX.c\n+                         */\n+                        if (len + 10 >= buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 >= buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 >= buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 >= buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 >= buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    /*\n+                     * This may look absurd but is needed to detect\n+                     * entities problems\n+                     */\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    /*\n+                     * Just output the reference\n+                     */\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 >= buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (; i > 0; i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l, buf, len, 0x20);\n+                        while (len + 10 >= buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l, buf, len, c);\n+                if (len + 10 >= buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4081,25 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n     /*\n      * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n+     * length more than INT_MAX it is a very reasonable assumption !\n      */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4116,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 28, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3968:7'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,16 +3903,16 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n     /*\n@@ -3932,145 +3933,145 @@\n          * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE\n          * special option is given\n          */\n-        if ((len > XML_MAX_TEXT_LENGTH) &&\n+        if ((len >= XML_MAX_TEXT_LENGTH) &&  // Changed from len > to len >=\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, len + 10); // Modified to grow based on current length\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        /*\n+                         * The reparsing will be done in xmlStringGetNodeList()\n+                         * called by the attribute() function in SAX.c\n+                         */\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, len + 10); // Modified to grow based on current length\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, len + 10); // Modified to grow based on current length\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, len + 10); // Modified to grow based on current length\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, len + 10); // Modified to grow based on current length\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, len + 10); // Modified to grow based on current length\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    /*\n+                     * This may look absurd but is needed to detect\n+                     * entities problems\n+                     */\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    /*\n+                     * Just output the reference\n+                     */\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, len + 10); // Modified to grow based on current length\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l, buf, len, c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, len + 10); // Modified to grow based on current length\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4081,25 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n     /*\n      * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n+     * length more than INT_MAX it is a very reasonable assumption !\n      */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4116,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 29, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3968:7'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,175 +3903,156 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n-    /*\n-     * allocate a translation buffer.\n-     */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n     if (buf == NULL) goto mem_error;\n \n-    /*\n-     * OK loop until we reach one of the ending char or a size limit.\n-     */\n     c = CUR_CHAR(l);\n-    while (((ctxt->input->cur[0] != limit) && /* checked */\n+    while (((ctxt->input->cur[0] != limit) && \n             (IS_CHAR(c)) && (c != \'<\')) &&\n             (ctxt->instate != XML_PARSER_EOF)) {\n-        /*\n-         * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE\n-         * special option is given\n-         */\n-        if ((len > XML_MAX_TEXT_LENGTH) &&\n+        if ((len > XML_MAX_TEXT_LENGTH) && \n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+                \n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if (len + 1 < buf_size) {\n+                        len += xmlCopyChar(0, &buf[len], val); // Safe length check\n+                    }\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) {\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4062,21 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n-    /*\n-     * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n-     */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4093,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 30, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3971:7'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,16 +3903,16 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n     /*\n@@ -3935,142 +3936,153 @@\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        /*\n+                         * The reparsing will be done in xmlStringGetNodeList()\n+                         * called by the attribute() function in SAX.c\n+                         */\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if (len + 10 <= buf_size) {  // Fix for potential overflow\n+                        len += xmlCopyChar(0, &buf[len], val);\n+                    }\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n-                                } else\n-                                    buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                } else {\n+                                    if (len + 10 <= buf_size) {  // Fix for potential overflow\n+                                        buf[len++] = *current++;\n+                                    }\n+                                }\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    /*\n+                     * This may look absurd but is needed to detect\n+                     * entities problems\n+                     */\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    /*\n+                     * Just output the reference\n+                     */\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (;i > 0;i--)\n+                        if (len + 10 <= buf_size) {  // Fix for potential overflow\n+                            buf[len++] = *cur++;\n+                        }\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        if (len + 10 <= buf_size) {  // Fix for potential overflow\n+                            COPY_BUF(l,buf,len,0x20);\n+                        }\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                if (len + 10 <= buf_size) {  // Fix for potential overflow\n+                    COPY_BUF(l,buf,len,c);\n+                }\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4092,25 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n     /*\n      * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n+     * length more than INT_MAX it is a very reasonable assumption !\n      */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4127,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 31, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3971:7'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,175 +3903,159 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n-    /*\n-     * allocate a translation buffer.\n-     */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n     if (buf == NULL) goto mem_error;\n \n-    /*\n-     * OK loop until we reach one of the ending char or a size limit.\n-     */\n     c = CUR_CHAR(l);\n-    while (((ctxt->input->cur[0] != limit) && /* checked */\n-            (IS_CHAR(c)) && (c != \'<\')) &&\n+    while (((ctxt->input->cur[0] != limit) && \n+            (IS_CHAR(c)) && (c != \'<\')) && \n             (ctxt->instate != XML_PARSER_EOF)) {\n-        /*\n-         * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE\n-         * special option is given\n-         */\n-        if ((len > XML_MAX_TEXT_LENGTH) &&\n+        if ((len > XML_MAX_TEXT_LENGTH) && \n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    // Modified the way we copy value to consider buffer overflow\n+                    if ((len + xmlCharLength(val)) < buf_size) {\n+                        len += xmlCopyChar(0, &buf[len], val);\n+                    } else {\n+                        xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                                       "Buffer overflow in attribute parsing\\n");\n+                        goto mem_error;\n+                    }\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) {\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4065,21 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n-    /*\n-     * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n-     */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4096,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 32, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3971:7'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,175 +3903,144 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n-    /*\n-     * allocate a translation buffer.\n-     */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n     if (buf == NULL) goto mem_error;\n \n-    /*\n-     * OK loop until we reach one of the ending char or a size limit.\n-     */\n     c = CUR_CHAR(l);\n-    while (((ctxt->input->cur[0] != limit) && /* checked */\n-            (IS_CHAR(c)) && (c != \'<\')) &&\n-            (ctxt->instate != XML_PARSER_EOF)) {\n-        /*\n-         * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE\n-         * special option is given\n-         */\n-        if ((len > XML_MAX_TEXT_LENGTH) &&\n-            ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n-            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+    while (((ctxt->input->cur[0] != limit) && (IS_CHAR(c)) && (c != \'<\')) &&\n+           (ctxt->instate != XML_PARSER_EOF)) {\n+        if ((len > XML_MAX_TEXT_LENGTH) && ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED, "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n-                                if ((*current == 0xD) || (*current == 0xA) ||\n-                                    (*current == 0x9)) {\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) && (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) && (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) && (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content, XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) {\n+                                if ((*current == 0xD) || (*current == 0xA) || (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n-                                } else\n+                                } else {\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                }\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) && (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content, XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (; i > 0; i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l, buf, len, 0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l, buf, len, c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4050,18 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR, "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED, "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n-    /*\n-     * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n-     */\n     if (len >= INT_MAX) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+        xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED, "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4078,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 33, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3971:7'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,16 +3903,16 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n     /*\n@@ -3935,142 +3936,145 @@\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        /*\n+                         * The reparsing will be done in xmlStringGetNodeList()\n+                         * called by the attribute() function in SAX.c\n+                         */\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if (len + xmlStrlen(val) > buf_size) {\n+                        growBuffer(buf, xmlStrlen(val));\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    /*\n+                     * This may look absurd but is needed to detect\n+                     * entities problems\n+                     */\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    /*\n+                     * Just output the reference\n+                     */\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (; i > 0; i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l, buf, len, 0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l, buf, len, c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4084,25 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n     /*\n      * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n+     * length more than INT_MAX it is a very reasonable assumption !\n      */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4119,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 34, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3971:7'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,16 +3903,16 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n     /*\n@@ -3938,139 +3939,139 @@\n                            "AttValue lenght too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        /*\n+                         * The reparsing will be done in xmlStringGetNodeList()\n+                         * called by the attribute() function in SAX.c\n+                         */\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    /*\n+                     * This may look absurd but is needed to detect\n+                     * entities problems\n+                     */\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    /*\n+                     * Just output the reference\n+                     */\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,17 +4081,17 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n     /*\n      * There we potentially risk an overflow, don\'t allow attribute value of\n@@ -4115,6 +4116,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 35, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3971:14'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,175 +3903,155 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n-    /*\n-     * allocate a translation buffer.\n-     */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n     if (buf == NULL) goto mem_error;\n \n-    /*\n-     * OK loop until we reach one of the ending char or a size limit.\n-     */\n     c = CUR_CHAR(l);\n     while (((ctxt->input->cur[0] != limit) && /* checked */\n             (IS_CHAR(c)) && (c != \'<\')) &&\n             (ctxt->instate != XML_PARSER_EOF)) {\n-        /*\n-         * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE\n-         * special option is given\n-         */\n+\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) {\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4061,21 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n-    /*\n-     * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n-     */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4092,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 36, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3971:14'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,175 +3903,157 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n-    /*\n-     * allocate a translation buffer.\n-     */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n     if (buf == NULL) goto mem_error;\n \n-    /*\n-     * OK loop until we reach one of the ending char or a size limit.\n-     */\n     c = CUR_CHAR(l);\n-    while (((ctxt->input->cur[0] != limit) && /* checked */\n-            (IS_CHAR(c)) && (c != \'<\')) &&\n+    while (((ctxt->input->cur[0] != limit) && \n+            (IS_CHAR(c)) && (c != \'<\')) && \n             (ctxt->instate != XML_PARSER_EOF)) {\n-        /*\n-         * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE\n-         * special option is given\n-         */\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+                \n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    // Patch starts here\n+                    if (len + xmlBytesConsumed(val) > buf_size) {\n+                        growBuffer(buf, xmlBytesConsumed(val));\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                    // Patch ends here\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+\n+                if ((ent != NULL) && (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) && (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) && (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) {\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (; i > 0; i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l, buf, len, 0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l, buf, len, c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4063,21 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n-    /*\n-     * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n-     */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4094,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 37, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3971:14'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,175 +3903,124 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n-    /*\n-     * allocate a translation buffer.\n-     */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n     if (buf == NULL) goto mem_error;\n \n-    /*\n-     * OK loop until we reach one of the ending char or a size limit.\n-     */\n     c = CUR_CHAR(l);\n-    while (((ctxt->input->cur[0] != limit) && /* checked */\n-            (IS_CHAR(c)) && (c != \'<\')) &&\n-            (ctxt->instate != XML_PARSER_EOF)) {\n-        /*\n-         * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE\n-         * special option is given\n-         */\n-        if ((len > XML_MAX_TEXT_LENGTH) &&\n-            ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n+    while (((ctxt->input->cur[0] != limit) && (IS_CHAR(c)) && (c != \'<\')) &&\n+           (ctxt->instate != XML_PARSER_EOF)) {\n+        if ((len > XML_MAX_TEXT_LENGTH) && ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n-                                if ((*current == 0xD) || (*current == 0xA) ||\n-                                    (*current == 0x9)) {\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+                if (val != 0 && len < buf_size - 1) {\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) && (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if ((ctxt->replaceEntities == 0) && (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) && (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) {\n+                                if ((*current == 0xD) || (*current == 0xA) || (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n-                                } else\n+                                } else if (len < buf_size - 1) {\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                }\n+                                if (len + 10 >= buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 >= buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (; i > 0; i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l, buf, len, 0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l, buf, len, c);\n+                if (len + 10 >= buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4030,21 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n-    /*\n-     * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n-     */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4061,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 38, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3971:14'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,16 +3903,16 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n     /*\n@@ -3935,142 +3936,145 @@\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        /*\n+                         * The reparsing will be done in xmlStringGetNodeList()\n+                         * called by the attribute() function in SAX.c\n+                         */\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if (len + XML_MAX_CHAR_SIZE > buf_size) {\n+                        growBuffer(buf, XML_MAX_CHAR_SIZE);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    /*\n+                     * This may look absurd but is needed to detect\n+                     * entities problems\n+                     */\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    /*\n+                     * Just output the reference\n+                     */\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (; i > 0; i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l, buf, len, 0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l, buf, len, c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4084,25 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n     /*\n      * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n+     * length more than INT_MAX it is a very reasonable assumption !\n      */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4119,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 39, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:3971:14'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,175 +3903,154 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n-    /*\n-     * allocate a translation buffer.\n-     */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n     if (buf == NULL) goto mem_error;\n \n-    /*\n-     * OK loop until we reach one of the ending char or a size limit.\n-     */\n     c = CUR_CHAR(l);\n     while (((ctxt->input->cur[0] != limit) && /* checked */\n             (IS_CHAR(c)) && (c != \'<\')) &&\n             (ctxt->instate != XML_PARSER_EOF)) {\n-        /*\n-         * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE\n-         * special option is given\n-         */\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) {\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (; i > 0; i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4060,21 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n-    /*\n-     * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n-     */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4091,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 40, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4055:7'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,203 +3903,157 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n-    /*\n-     * allocate a translation buffer.\n-     */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n     if (buf == NULL) goto mem_error;\n \n-    /*\n-     * OK loop until we reach one of the ending char or a size limit.\n-     */\n     c = CUR_CHAR(l);\n-    while (((ctxt->input->cur[0] != limit) && /* checked */\n-            (IS_CHAR(c)) && (c != \'<\')) &&\n-            (ctxt->instate != XML_PARSER_EOF)) {\n-        /*\n-         * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE\n-         * special option is given\n-         */\n-        if ((len > XML_MAX_TEXT_LENGTH) &&\n-            ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n-            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+    while (((ctxt->input->cur[0] != limit) && (IS_CHAR(c)) && (c != \'<\')) && (ctxt->instate != XML_PARSER_EOF)) {\n+        if ((len > XML_MAX_TEXT_LENGTH) && ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED, "AttValue lenght too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n-                                if ((*current == 0xD) || (*current == 0xA) ||\n-                                    (*current == 0x9)) {\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) && (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) && (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) && (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content, XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) {\n+                                if ((*current == 0xD) || (*current == 0xA) || (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) && (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content, XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (; i > 0; i--) \n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n \n     if ((in_space) && (normalize)) {\n-        while (buf[len - 1] == 0x20) len--;\n+        while (len > 0 && buf[len - 1] == 0x20) len--;\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR, "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED, "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n-    /*\n-     * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n-     */\n     if (len >= INT_MAX) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+        xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED, "AttValue lenght too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4070,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 41, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4055:7'}, {'diff': "@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -4054,7 +4055,7 @@\n \t        if ((len != 0) || (!normalize)) {\n \t\t    if ((!normalize) || (!in_space)) {\n \t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n+\t\t\tif (len + 10 > buf_size) {\n \t\t\t    growBuffer(buf, 10);\n \t\t\t}\n \t\t    }\n@@ -4094,7 +4095,7 @@\n \n     /*\n      * There we potentially risk an overflow, don't allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n+     * lenght more than INT_MAX it is a very reasonble assumption !\n      */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n@@ -4115,6 +4116,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n", 'id': 42, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4055:7'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,175 +3903,77 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n-    /*\n-     * allocate a translation buffer.\n-     */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n     if (buf == NULL) goto mem_error;\n \n-    /*\n-     * OK loop until we reach one of the ending char or a size limit.\n-     */\n     c = CUR_CHAR(l);\n-    while (((ctxt->input->cur[0] != limit) && /* checked */\n+    while (((ctxt->input->cur[0] != limit) &&\n             (IS_CHAR(c)) && (c != \'<\')) &&\n             (ctxt->instate != XML_PARSER_EOF)) {\n-        /*\n-         * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE\n-         * special option is given\n-         */\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n-                                if ((*current == 0xD) || (*current == 0xA) ||\n-                                    (*current == 0x9)) {\n-                                    buf[len++] = 0x20;\n-                                    current++;\n-                                } else\n-                                    buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+                if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    buf[len++] = ent->content[0];\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l, buf, len, 0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l, buf, len, c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +3983,21 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n-    /*\n-     * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n-     */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4014,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 43, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4055:7'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,175 +3903,139 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n-    /*\n-     * allocate a translation buffer.\n-     */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n     if (buf == NULL) goto mem_error;\n \n-    /*\n-     * OK loop until we reach one of the ending char or a size limit.\n-     */\n     c = CUR_CHAR(l);\n-    while (((ctxt->input->cur[0] != limit) && /* checked */\n-            (IS_CHAR(c)) && (c != \'<\')) &&\n-            (ctxt->instate != XML_PARSER_EOF)) {\n-        /*\n-         * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE\n-         * special option is given\n-         */\n-        if ((len > XML_MAX_TEXT_LENGTH) &&\n-            ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n-            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+    while (((ctxt->input->cur[0] != limit) && (IS_CHAR(c)) && (c != \'<\')) &&\n+           (ctxt->instate != XML_PARSER_EOF)) {\n+        if ((len > XML_MAX_TEXT_LENGTH) && ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED, "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n-                                if ((*current == 0xD) || (*current == 0xA) ||\n-                                    (*current == 0x9)) {\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL) ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) && (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) && (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) && (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content, XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) {\n+                                if ((*current == 0xD) || (*current == 0xA) || (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n-                                } else\n+                                } else \n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) && (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content, XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (; i > 0; i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = 0x20; // Modified line for buffer overrun prevention\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+                buf[len++] = c; // Modified line for buffer overrun prevention\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4045,18 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR, "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED, "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n-    /*\n-     * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n-     */\n     if (len >= INT_MAX) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+        xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED, "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4073,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 44, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4055:7'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,175 +3903,154 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n-    /*\n-     * allocate a translation buffer.\n-     */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n     if (buf == NULL) goto mem_error;\n \n-    /*\n-     * OK loop until we reach one of the ending char or a size limit.\n-     */\n     c = CUR_CHAR(l);\n     while (((ctxt->input->cur[0] != limit) && /* checked */\n             (IS_CHAR(c)) && (c != \'<\')) &&\n             (ctxt->instate != XML_PARSER_EOF)) {\n-        /*\n-         * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE\n-         * special option is given\n-         */\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n                            "AttValue lenght too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) {\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = 0x20;\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,22 +4060,18 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n-    /*\n-     * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n-     */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n                        "AttValue lenght too long\\n");\n@@ -4115,6 +4091,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 45, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4056:4'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,175 +3903,158 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n-    /*\n-     * allocate a translation buffer.\n-     */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n     if (buf == NULL) goto mem_error;\n \n-    /*\n-     * OK loop until we reach one of the ending char or a size limit.\n-     */\n     c = CUR_CHAR(l);\n-    while (((ctxt->input->cur[0] != limit) && /* checked */\n+    while (((ctxt->input->cur[0] != limit) && \n             (IS_CHAR(c)) && (c != \'<\')) &&\n             (ctxt->instate != XML_PARSER_EOF)) {\n-        /*\n-         * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE\n-         * special option is given\n-         */\n+        \n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) {\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n+                                    if (len + 10 > buf_size) {\n+                                        growBuffer(buf, 10);\n+                                    }\n                                     buf[len++] = 0x20;\n                                     current++;\n-                                } else\n+                                } else {\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                }\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = 0x20; // Modified to handle buffer size \n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+                buf[len++] = c; // Modified to handle buffer size\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4064,21 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n-    /*\n-     * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n-     */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4095,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 46, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4056:4'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,175 +3903,158 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n-    /*\n-     * allocate a translation buffer.\n-     */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n     if (buf == NULL) goto mem_error;\n \n-    /*\n-     * OK loop until we reach one of the ending char or a size limit.\n-     */\n     c = CUR_CHAR(l);\n-    while (((ctxt->input->cur[0] != limit) && /* checked */\n+    while (((ctxt->input->cur[0] != limit) && \n             (IS_CHAR(c)) && (c != \'<\')) &&\n             (ctxt->instate != XML_PARSER_EOF)) {\n-        /*\n-         * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE\n-         * special option is given\n-         */\n-        if ((len > XML_MAX_TEXT_LENGTH) &&\n+        if ((len > XML_MAX_TEXT_LENGTH) && \n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) {\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n+                                    if (len + 10 > buf_size) {\n+                                        growBuffer(buf, 10);\n+                                    }\n                                     buf[len++] = 0x20;\n                                     current++;\n-                                } else\n+                                } else {\n+                                    if (len + 10 > buf_size) {\n+                                        growBuffer(buf, 10);\n+                                    }\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (; i > 0; i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = 0x20;\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+                buf[len++] = c;\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4064,21 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n-    /*\n-     * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n-     */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4095,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 47, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4056:4'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,16 +3903,16 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n     /*\n@@ -3935,142 +3936,146 @@\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        /*\n+                         * The reparsing will be done in xmlStringGetNodeList()\n+                         * called by the attribute() function in SAX.c\n+                         */\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n+                                    if (len + 10 > buf_size) {\n+                                        growBuffer(buf, 10);\n+                                    }\n                                     buf[len++] = 0x20;\n                                     current++;\n-                                } else\n+                                } else {\n+                                    if (len + 10 > buf_size) {\n+                                        growBuffer(buf, 10);\n+                                    }\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    /*\n+                     * This may look absurd but is needed to detect\n+                     * entities problems\n+                     */\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    /*\n+                     * Just output the reference\n+                     */\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        COPY_BUF(l, buf, len, 0x20);\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+                COPY_BUF(l, buf, len, c);\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4085,25 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n     /*\n      * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n+     * length more than INT_MAX it is a very reasonable assumption !\n      */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4120,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 48, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4056:4'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,175 +3903,158 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n-    /*\n-     * allocate a translation buffer.\n-     */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n     if (buf == NULL) goto mem_error;\n \n-    /*\n-     * OK loop until we reach one of the ending char or a size limit.\n-     */\n     c = CUR_CHAR(l);\n     while (((ctxt->input->cur[0] != limit) && /* checked */\n             (IS_CHAR(c)) && (c != \'<\')) &&\n             (ctxt->instate != XML_PARSER_EOF)) {\n-        /*\n-         * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE\n-         * special option is given\n-         */\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) {\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n+                                    if (len >= buf_size) {\n+                                        growBuffer(buf, 10);\n+                                    }\n                                     buf[len++] = 0x20;\n                                     current++;\n-                                } else\n+                                } else {\n+                                    if (len >= buf_size) {\n+                                        growBuffer(buf, 10);\n+                                    }\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (; i > 0; i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        if (len >= buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = 0x20;\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                if (len >= buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+                buf[len++] = c;\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4064,21 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n-    /*\n-     * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n-     */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4095,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 49, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4056:4'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,175 +3903,163 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n-    /*\n-     * allocate a translation buffer.\n-     */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n     if (buf == NULL) goto mem_error;\n \n-    /*\n-     * OK loop until we reach one of the ending char or a size limit.\n-     */\n     c = CUR_CHAR(l);\n     while (((ctxt->input->cur[0] != limit) && /* checked */\n             (IS_CHAR(c)) && (c != \'<\')) &&\n             (ctxt->instate != XML_PARSER_EOF)) {\n-        /*\n-         * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE\n-         * special option is given\n-         */\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            buf_size += 10; // Update buffer size safely\n+                            buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            buf_size += 10; // Update buffer size safely\n+                            buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        buf_size += 10; // Update buffer size safely\n+                        buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        buf_size += 10; // Update buffer size safely\n+                        buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) {\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    buf_size += 10; // Update buffer size safely\n+                                    buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            buf_size += 10; // Update buffer size safely\n+                            buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        buf_size += i + 10; // Update buffer size safely\n+                        buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 > buf_size) {\n+                            buf_size += 10; // Update buffer size safely\n+                            buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    buf_size += 10; // Update buffer size safely\n+                    buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4069,21 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n-    /*\n-     * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n-     */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4100,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 50, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4057:4'}, {'diff': '@@ -3890,187 +3890,193 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n     xmlChar *buf = NULL;\n     xmlChar *rep = NULL;\n     size_t len = 0;\n-    size_t buf_size = 0;\n+    size_t buf_size = XML_PARSER_BUFFER_SIZE; // Initialize to a reasonable size\n     int c, l, in_space = 0;\n     xmlChar *current = NULL;\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n-    /*\n-     * allocate a translation buffer.\n-     */\n-    buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n     if (buf == NULL) goto mem_error;\n \n-    /*\n-     * OK loop until we reach one of the ending char or a size limit.\n-     */\n     c = CUR_CHAR(l);\n     while (((ctxt->input->cur[0] != limit) && /* checked */\n             (IS_CHAR(c)) && (c != \'<\')) &&\n             (ctxt->instate != XML_PARSER_EOF)) {\n-        /*\n-         * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE\n-         * special option is given\n-         */\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 >= buf_size) {\n+                            // Prevent overflow\n+                            buf_size = len + 10 + 1;\n+                            buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                            if (buf == NULL) goto mem_error;\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        if (len + 10 >= buf_size) {\n+                            // Prevent overflow\n+                            buf_size = len + 10 + 1;\n+                            buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                            if (buf == NULL) goto mem_error;\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 >= buf_size) {\n+                        // Prevent overflow\n+                        buf_size = len + 10 + 1;\n+                        buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                        if (buf == NULL) goto mem_error;\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 >= buf_size) {\n+                        // Prevent overflow\n+                        buf_size = len + 10 + 1;\n+                        buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                        if (buf == NULL) goto mem_error;\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                        (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 >= buf_size) {\n+                                    // Prevent overflow\n+                                    buf_size = len + 10 + 1;\n+                                    buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                                    if (buf == NULL) goto mem_error;\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 >= buf_size) {\n+                            // Prevent overflow\n+                            buf_size = len + 10 + 1;\n+                            buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                            if (buf == NULL) goto mem_error;\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 >= buf_size) {\n+                        // Prevent overflow\n+                        buf_size = len + i + 10 + 1;\n+                        buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                        if (buf == NULL) goto mem_error;\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 >= buf_size) {\n+                            // Prevent overflow\n+                            buf_size = len + 10 + 1;\n+                            buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                            if (buf == NULL) goto mem_error;\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 >= buf_size) {\n+                    // Prevent overflow\n+                    buf_size = len + 10 + 1;\n+                    buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                    if (buf == NULL) goto mem_error;\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4086,21 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n-    /*\n-     * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n-     */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4117,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 51, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4057:4'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,16 +3903,16 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n     /*\n@@ -3938,139 +3939,157 @@\n                            "AttValue lenght too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            buf_size += 10; // update buffer size\n+                            buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                            if (buf == NULL) goto mem_error;\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        /*\n+                         * The reparsing will be done in xmlStringGetNodeList()\n+                         * called by the attribute() function in SAX.c\n+                         */\n+                        if (len + 10 > buf_size) {\n+                            buf_size += 10; // update buffer size\n+                            buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                            if (buf == NULL) goto mem_error;\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        buf_size += 10; // update buffer size\n+                        buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                        if (buf == NULL) goto mem_error;\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        buf_size += 10; // update buffer size\n+                        buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                        if (buf == NULL) goto mem_error;\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    buf_size += 10; // update buffer size\n+                                    buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                                    if (buf == NULL) goto mem_error;\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            buf_size += 10; // update buffer size\n+                            buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                            if (buf == NULL) goto mem_error;\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    /*\n+                     * This may look absurd but is needed to detect\n+                     * entities problems\n+                     */\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    /*\n+                     * Just output the reference\n+                     */\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        buf_size += i + 10; // update buffer size\n+                        buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                        if (buf == NULL) goto mem_error;\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 > buf_size) {\n+                            buf_size += 10; // update buffer size\n+                            buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                            if (buf == NULL) goto mem_error;\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    buf_size += 10; // update buffer size\n+                    buf = (xmlChar *) xmlRealloc(buf, buf_size);\n+                    if (buf == NULL) goto mem_error;\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4099,25 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n     /*\n      * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n+     * length more than INT_MAX it is a very reasonable assumption !\n      */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4134,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 52, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4057:4'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,16 +3903,16 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n     /*\n@@ -3935,142 +3936,141 @@\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 >= buf_size) {\n+                            growBuffer(buf, len + 10); // Change necessary to prevent overflow\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        /*\n+                         * The reparsing will be done in xmlStringGetNodeList()\n+                         * called by the attribute() function in SAX.c\n+                         */\n+                        if (len + 10 >= buf_size) {\n+                            growBuffer(buf, len + 10); // Change necessary to prevent overflow\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 >= buf_size) {\n+                        growBuffer(buf, len + 10); // Change necessary to prevent overflow\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 >= buf_size) {\n+                        growBuffer(buf, len + 10); // Change necessary to prevent overflow\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 >= buf_size) {\n+                                    growBuffer(buf, len + 10); // Change necessary to prevent overflow\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 >= buf_size) {\n+                            growBuffer(buf, len + 10); // Change necessary to prevent overflow\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    /*\n+                     * This may look absurd but is needed to detect\n+                     * entities problems\n+                     */\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    /*\n+                     * Just output the reference\n+                     */\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 >= buf_size) {\n+                        growBuffer(buf, len + i + 10); // Change necessary to prevent overflow\n+                    }\n+                    for (; i > 0; i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l, buf, len, 0x20);\n+                        while (len + 10 >= buf_size) {\n+                            growBuffer(buf, len + 10); // Change necessary to prevent overflow\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l, buf, len, c);\n+                if (len + 10 >= buf_size) {\n+                    growBuffer(buf, len + 10); // Change necessary to prevent overflow\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4080,25 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n     /*\n      * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n+     * length more than INT_MAX; it is a very reasonable assumption!\n      */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4115,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 53, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4057:4'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,16 +3903,16 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n     /*\n@@ -3935,142 +3936,142 @@\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, len + 10); // Modified\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        /*\n+                         * The reparsing will be done in xmlStringGetNodeList()\n+                         * called by the attribute() function in SAX.c\n+                         */\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, len + 10); // Modified\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, len + 10); // Modified\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, len + 10); // Modified\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, len + 10); // Modified\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, len + 10); // Modified\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    /*\n+                     * This may look absurd but is needed to detect\n+                     * entities problems\n+                     */\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    /*\n+                     * Just output the reference\n+                     */\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, len + i + 10); // Modified\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, len + 10); // Modified\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, len + 10); // Modified\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4081,25 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n     /*\n      * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n+     * length more than INT_MAX it is a very reasonable assumption !\n      */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4116,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 54, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4057:4'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,16 +3903,16 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n     /*\n@@ -3938,139 +3939,142 @@\n                            "AttValue lenght too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        /*\n+                         * The reparsing will be done in xmlStringGetNodeList()\n+                         * called by the attribute() function in SAX.c\n+                         */\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    /*\n+                     * This may look absurd but is needed to detect\n+                     * entities problems\n+                     */\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    /*\n+                     * Just output the reference\n+                     */\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        // GROW; // Commenting out the original vulnerable line\n+        if (len + 10 > buf_size) { // Add size check before growing the buffer\n+            growBuffer(buf, 10);\n+        }\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,17 +4084,17 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n     /*\n      * There we potentially risk an overflow, don\'t allow attribute value of\n@@ -4115,6 +4119,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 55, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4072:2'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,16 +3903,16 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n     /*\n@@ -3938,139 +3939,143 @@\n                            "AttValue lenght too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        /*\n+                         * The reparsing will be done in xmlStringGetNodeList()\n+                         * called by the attribute() function in SAX.c\n+                         */\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    /*\n+                     * This may look absurd but is needed to detect\n+                     * entities problems\n+                     */\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    /*\n+                     * Just output the reference\n+                     */\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        if (len >= INT_MAX) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                            "AttValue lenght too long\\n");\n+            goto mem_error;\n+        }\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,17 +4085,17 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n     /*\n      * There we potentially risk an overflow, don\'t allow attribute value of\n@@ -4115,6 +4120,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 56, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4072:2'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,175 +3903,155 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n-    /*\n-     * allocate a translation buffer.\n-     */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n     if (buf == NULL) goto mem_error;\n \n-    /*\n-     * OK loop until we reach one of the ending char or a size limit.\n-     */\n     c = CUR_CHAR(l);\n     while (((ctxt->input->cur[0] != limit) && /* checked */\n             (IS_CHAR(c)) && (c != \'<\')) &&\n             (ctxt->instate != XML_PARSER_EOF)) {\n-        /*\n-         * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE\n-         * special option is given\n-         */\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+                    \n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        if (len + 10 > buf_size) {\n+            growBuffer(buf, 10);\n+        }\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4061,21 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n-    /*\n-     * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n-     */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4092,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 57, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4072:2'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,16 +3903,16 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n     /*\n@@ -3938,139 +3939,142 @@\n                            "AttValue lenght too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        /*\n+                         * The reparsing will be done in xmlStringGetNodeList()\n+                         * called by the attribute() function in SAX.c\n+                         */\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    /*\n+                     * This may look absurd but is needed to detect\n+                     * entities problems\n+                     */\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    /*\n+                     * Just output the reference\n+                     */\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        if (len + 10 > buf_size) {\n+            growBuffer(buf, 10);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,17 +4084,17 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n     /*\n      * There we potentially risk an overflow, don\'t allow attribute value of\n@@ -4115,6 +4119,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 58, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4072:2'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,175 +3903,156 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n-    /*\n-     * allocate a translation buffer.\n-     */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n     if (buf == NULL) goto mem_error;\n \n-    /*\n-     * OK loop until we reach one of the ending char or a size limit.\n-     */\n     c = CUR_CHAR(l);\n     while (((ctxt->input->cur[0] != limit) && /* checked */\n             (IS_CHAR(c)) && (c != \'<\')) &&\n             (ctxt->instate != XML_PARSER_EOF)) {\n-        /*\n-         * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE\n-         * special option is given\n-         */\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) {\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        if (len + 10 > buf_size) {\n+            growBuffer(buf, 10);\n+        }\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n@@ -4080,25 +4062,21 @@\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n-    /*\n-     * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n-     */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4093,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 59, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4072:2'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,16 +3903,16 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n     /*\n@@ -3935,170 +3936,170 @@\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        /*\n+                         * The reparsing will be done in xmlStringGetNodeList()\n+                         * called by the attribute() function in SAX.c\n+                         */\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non-input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    /*\n+                     * This may look absurd but is needed to detect\n+                     * entities problems\n+                     */\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    /*\n+                     * Just output the reference\n+                     */\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (; i > 0; i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l, buf, len, 0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l, buf, len, c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n \n     if ((in_space) && (normalize)) {\n-        while (buf[len - 1] == 0x20) len--;\n+        while (len > 0 && buf[len - 1] == 0x20) len--; // Modified\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n     /*\n      * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n+     * length more than INT_MAX it is a very reasonable assumption !\n      */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4116,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 60, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4079:9'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,16 +3903,16 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n     /*\n@@ -3938,159 +3939,159 @@\n                            "AttValue lenght too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        /*\n+                         * The reparsing will be done in xmlStringGetNodeList()\n+                         * called by the attribute() function in SAX.c\n+                         */\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    /*\n+                     * This may look absurd but is needed to detect\n+                     * entities problems\n+                     */\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    /*\n+                     * Just output the reference\n+                     */\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n \n     if ((in_space) && (normalize)) {\n-        while (buf[len - 1] == 0x20) len--;\n+        while (len > 0 && buf[len - 1] == 0x20) len--;\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n     /*\n      * There we potentially risk an overflow, don\'t allow attribute value of\n@@ -4115,6 +4116,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 61, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4079:9'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,203 +3903,177 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n-    /*\n-     * allocate a translation buffer.\n-     */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n     if (buf == NULL) goto mem_error;\n \n-    /*\n-     * OK loop until we reach one of the ending char or a size limit.\n-     */\n     c = CUR_CHAR(l);\n-    while (((ctxt->input->cur[0] != limit) && /* checked */\n+    while (((ctxt->input->cur[0] != limit) && \n             (IS_CHAR(c)) && (c != \'<\')) &&\n             (ctxt->instate != XML_PARSER_EOF)) {\n-        /*\n-         * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE\n-         * special option is given\n-         */\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) {\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n-                                } else\n+                                } else {\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                }\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n \n     if ((in_space) && (normalize)) {\n-        while (buf[len - 1] == 0x20) len--;\n+        while (len > 0 && buf[len - 1] == 0x20) len--;\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n-    /*\n-     * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n-     */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4090,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 62, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4079:9'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,200 +3903,174 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n-    /*\n-     * allocate a translation buffer.\n-     */\n     buf_size = XML_PARSER_BUFFER_SIZE;\n     buf = (xmlChar *) xmlMallocAtomic(buf_size);\n     if (buf == NULL) goto mem_error;\n \n-    /*\n-     * OK loop until we reach one of the ending char or a size limit.\n-     */\n     c = CUR_CHAR(l);\n     while (((ctxt->input->cur[0] != limit) && /* checked */\n             (IS_CHAR(c)) && (c != \'<\')) &&\n             (ctxt->instate != XML_PARSER_EOF)) {\n-        /*\n-         * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE\n-         * special option is given\n-         */\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n                            "AttValue lenght too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n \n     if ((in_space) && (normalize)) {\n-        while (buf[len - 1] == 0x20) len--;\n+        while (len > 0 && buf[len - 1] == 0x20) len--; // Modified to check len > 0\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n-    /*\n-     * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n-     */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n                        "AttValue lenght too long\\n");\n@@ -4115,6 +4090,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 63, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4079:9'}, {'diff': '@@ -3890,6 +3890,7 @@\n  *\n  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.\n  */\n+\n static xmlChar *\n xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n     xmlChar limit = 0;\n@@ -3902,16 +3903,16 @@\n     xmlEntityPtr ent;\n \n     if (ctxt->input->cur[0] == \'"\') {\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-\tlimit = \'"\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'"\';\n         NEXT;\n     } else if (ctxt->input->cur[0] == \'\\\'\') {\n-\tlimit = \'\\\'\';\n-\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = \'\\\'\';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n         NEXT;\n     } else {\n-\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-\treturn(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n     }\n \n     /*\n@@ -3935,170 +3936,170 @@\n         if ((len > XML_MAX_TEXT_LENGTH) &&\n             ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                           "AttValue lenght too long\\n");\n+                           "AttValue length too long\\n");\n             goto mem_error;\n         }\n-\tif (c == 0) break;\n-\tif (c == \'&\') {\n-\t    in_space = 0;\n-\t    if (ctxt->input->cur[1] == \'#\') {\n-\t\tint val = xmlParseCharRef(ctxt);\n-\n-\t\tif (val == \'&\') {\n-\t\t    if (ctxt->replaceEntities) {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t    } else {\n-\t\t\t/*\n-\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n-\t\t\t * called by the attribute() function in SAX.c\n-\t\t\t */\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    }\n-\t\t} else if (val != 0) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    len += xmlCopyChar(0, &buf[len], val);\n-\t\t}\n-\t    } else {\n-\t\tent = xmlParseEntityRef(ctxt);\n-\t\tctxt->nbentities++;\n-\t\tif (ent != NULL)\n-\t\t    ctxt->nbentities += ent->owner;\n-\t\tif ((ent != NULL) &&\n-\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\t\t    if (len + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, 10);\n-\t\t    }\n-\t\t    if ((ctxt->replaceEntities == 0) &&\n-\t\t        (ent->content[0] == \'&\')) {\n-\t\t\tbuf[len++] = \'&\';\n-\t\t\tbuf[len++] = \'#\';\n-\t\t\tbuf[len++] = \'3\';\n-\t\t\tbuf[len++] = \'8\';\n-\t\t\tbuf[len++] = \';\';\n-\t\t    } else {\n-\t\t\tbuf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if ((ent != NULL) &&\n-\t\t           (ctxt->replaceEntities != 0)) {\n-\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n-\t\t\t\t\t\t      0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    current = rep;\n-\t\t\t    while (*current != 0) { /* non input consuming */\n+        if (c == 0) break;\n+        if (c == \'&\') {\n+            in_space = 0;\n+            if (ctxt->input->cur[1] == \'#\') {\n+                int val = xmlParseCharRef(ctxt);\n+\n+                if (val == \'&\') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                    } else {\n+                        /*\n+                         * The reparsing will be done in xmlStringGetNodeList()\n+                         * called by the attribute() function in SAX.c\n+                         */\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n+            } else {\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == \'&\')) {\n+                        buf[len++] = \'&\';\n+                        buf[len++] = \'#\';\n+                        buf[len++] = \'3\';\n+                        buf[len++] = \'8\';\n+                        buf[len++] = \';\';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { /* non input consuming */\n                                 if ((*current == 0xD) || (*current == 0xA) ||\n                                     (*current == 0x9)) {\n                                     buf[len++] = 0x20;\n                                     current++;\n                                 } else\n                                     buf[len++] = *current++;\n-\t\t\t\tif (len + 10 > buf_size) {\n-\t\t\t\t    growBuffer(buf, 10);\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tif (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t\tif (ent->content != NULL)\n-\t\t\t    buf[len++] = ent->content[0];\n-\t\t    }\n-\t\t} else if (ent != NULL) {\n-\t\t    int i = xmlStrlen(ent->name);\n-\t\t    const xmlChar *cur = ent->name;\n-\n-\t\t    /*\n-\t\t     * This may look absurd but is needed to detect\n-\t\t     * entities problems\n-\t\t     */\n-\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-\t\t\t(ent->content != NULL)) {\n-\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n-\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n-\t\t\tif (rep != NULL) {\n-\t\t\t    xmlFree(rep);\n-\t\t\t    rep = NULL;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t    /*\n-\t\t     * Just output the reference\n-\t\t     */\n-\t\t    buf[len++] = \'&\';\n-\t\t    while (len + i + 10 > buf_size) {\n-\t\t\tgrowBuffer(buf, i + 10);\n-\t\t    }\n-\t\t    for (;i > 0;i--)\n-\t\t\tbuf[len++] = *cur++;\n-\t\t    buf[len++] = \';\';\n-\t\t}\n-\t    }\n-\t} else {\n-\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-\t        if ((len != 0) || (!normalize)) {\n-\t\t    if ((!normalize) || (!in_space)) {\n-\t\t\tCOPY_BUF(l,buf,len,0x20);\n-\t\t\twhile (len + 10 > buf_size) {\n-\t\t\t    growBuffer(buf, 10);\n-\t\t\t}\n-\t\t    }\n-\t\t    in_space = 1;\n-\t\t}\n-\t    } else {\n-\t        in_space = 0;\n-\t\tCOPY_BUF(l,buf,len,c);\n-\t\tif (len + 10 > buf_size) {\n-\t\t    growBuffer(buf, 10);\n-\t\t}\n-\t    }\n-\t    NEXTL(l);\n-\t}\n-\tGROW;\n-\tc = CUR_CHAR(l);\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    /*\n+                     * This may look absurd but is needed to detect\n+                     * entities problems\n+                     */\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL)) {\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        if (rep != NULL) {\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    }\n+\n+                    /*\n+                     * Just output the reference\n+                     */\n+                    buf[len++] = \'&\';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (; i > 0; i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = \';\';\n+                }\n+            }\n+        } else {\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l, buf, len, 0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l, buf, len, c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n+        }\n+        GROW;\n+        c = CUR_CHAR(l);\n     }\n     if (ctxt->instate == XML_PARSER_EOF)\n         goto error;\n \n     if ((in_space) && (normalize)) {\n-        while (buf[len - 1] == 0x20) len--;\n+        while (len > 0 && buf[len - 1] == 0x20) len--;\n     }\n     buf[len] = 0;\n     if (RAW == \'<\') {\n-\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n     } else if (RAW != limit) {\n-\tif ((c != 0) && (!IS_CHAR(c))) {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t   "invalid character in attribute value\\n");\n-\t} else {\n-\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-\t\t\t   "AttValue: \' expected\\n");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           "invalid character in attribute value\\n");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           "AttValue: \' expected\\n");\n         }\n     } else\n-\tNEXT;\n+        NEXT;\n \n     /*\n      * There we potentially risk an overflow, don\'t allow attribute value of\n-     * lenght more than INT_MAX it is a very reasonnable assumption !\n+     * length more than INT_MAX it is a very reasonable assumption !\n      */\n     if (len >= INT_MAX) {\n         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                       "AttValue lenght too long\\n");\n+                       "AttValue length too long\\n");\n         goto mem_error;\n     }\n \n@@ -4115,6 +4116,7 @@\n     return(NULL);\n }\n \n+\n /**\n  * xmlParseAttValue:\n  * @ctxt:  an XML parser context\n', 'id': 64, 'location': '/data/vulnloc/libxml2/CVE-2012-5134/src/parser.c:4079:9'}]2025-02-02 13:47:53.848 | INFO     | scenario:validate:475 - beginning candidate patch evaluation with time limit: 45 minutes
2025-02-02 13:47:53.850 | DEBUG    | scenario:rebuild:369 - original environment: environ({'CONDA_SHLVL': '2', 'LC_ALL': 'C.UTF-8', 'LS_COLORS': 'rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:', 'LD_LIBRARY_PATH': '/opt/crashrepair/lib:/CrashRepair/lib:/klee/build/lib:', 'CONDA_EXE': '/root/anaconda3/bin/conda', 'LANG': 'C.UTF-8', 'TZ': 'Asia/Shanghai', 'HOSTNAME': 'fea22102047d', 'OLDPWD': '/orchestrator', 'CONDA_PREFIX': '/root/anaconda3/envs/CrashRepair', '_CE_M': '', 'CC': 'crepair-cc', 'LLVM_COMPILER': 'clang', 'CONDA_PREFIX_1': '/root/anaconda3', 'PWD': '/orchestrator/crashrepair', 'HOME': '/root', 'CONDA_PYTHON_EXE': '/root/anaconda3/bin/python', '_CE_CONDA': '', 'CONDA_PROMPT_MODIFIER': '(CrashRepair) ', 'CXX': 'crepair-cxx', 'TERM': 'xterm', 'SHLVL': '2', 'PYTHONPATH': '/usr/lib/python3.8/site-packages:', 'PATH': '/root/anaconda3/envs/CrashRepair/bin:/root/anaconda3/condabin:~/anaconda3/bin:/opt/crashrepair/bin:/CrashRepair/compiler:/klee/build/bin:/opt/llvm-6/bin:/klee/build/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin', 'CONDA_DEFAULT_ENV': 'CrashRepair', '_': '/root/anaconda3/envs/CrashRepair/bin/python'})
2025-02-02 13:47:53.850 | DEBUG    | scenario:rebuild:382 - injecting ghost function into CFLAGS during build: -lcrepair_ghost
2025-02-02 13:47:53.850 | DEBUG    | scenario:rebuild:398 - using environment: {'INJECT_CFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address', 'INJECT_CXXFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address', 'INJECT_LDFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address'}
2025-02-02 13:47:53.850 | DEBUG    | shell:__call__:41 - executing: make clean
Making clean in include
make[1]: Entering directory '/data/vulnloc/libxml2/CVE-2012-5134/src/include'
Making clean in libxml
make[2]: Entering directory '/data/vulnloc/libxml2/CVE-2012-5134/src/include/libxml'
rm -rf .libs _libs
rm -f *.lo
make[2]: Leaving directory '/data/vulnloc/libxml2/CVE-2012-5134/src/include/libxml'
make[2]: Entering directory '/data/vulnloc/libxml2/CVE-2012-5134/src/include'
rm -rf .libs _libs
rm -f *.lo
make[2]: Leaving directory '/data/vulnloc/libxml2/CVE-2012-5134/src/include'
make[1]: Leaving directory '/data/vulnloc/libxml2/CVE-2012-5134/src/include'
Making clean in .
make[1]: Entering directory '/data/vulnloc/libxml2/CVE-2012-5134/src'
 rm -f xmllint xmlcatalog
test -z "runxmlconf.log test.out xml2Conf.sh *.gcda *.gcno *.res" || rm -f runxmlconf.log test.out xml2Conf.sh *.gcda *.gcno *.res
test -z "libxml2.la" || rm -f libxml2.la
rm -f ./so_locations
rm -rf .libs _libs
test -z "testdso.la" || rm -f testdso.la
rm -f ./so_locations
 rm -f testSchemas testRelax testSAX testHTML testXPath testURI testThreads testC14N testAutomata testRegexp testReader testapi testModule runtest runsuite testchar testdict runxmlconf testrecurse testlimits
rm -f *.o
rm -f *.lo
make[1]: Leaving directory '/data/vulnloc/libxml2/CVE-2012-5134/src'
Making clean in doc
make[1]: Entering directory '/data/vulnloc/libxml2/CVE-2012-5134/src/doc'
Making clean in .
make[2]: Entering directory '/data/vulnloc/libxml2/CVE-2012-5134/src/doc'
rm -rf .libs _libs
rm -f *~ *.bak *.hierarchy *.signals *-unused.txt
rm -f *.lo
make[2]: Leaving directory '/data/vulnloc/libxml2/CVE-2012-5134/src/doc'
Making clean in devhelp
make[2]: Entering directory '/data/vulnloc/libxml2/CVE-2012-5134/src/doc/devhelp'
rm -rf .libs _libs
rm -f *.lo
make[2]: Leaving directory '/data/vulnloc/libxml2/CVE-2012-5134/src/doc/devhelp'
Making clean in examples
make[2]: Entering directory '/data/vulnloc/libxml2/CVE-2012-5134/src/doc/examples'
test -z "*.tmp" || rm -f *.tmp
rm -rf .libs _libs
test -f Makefile.am || rm -f test?.xml
 rm -f io1 io2 parse1 parse2 parse3 parse4 reader1 reader2 reader3 reader4 testWriter tree1 tree2 xpath1 xpath2
rm -f *.o
rm -f *.lo
make[2]: Leaving directory '/data/vulnloc/libxml2/CVE-2012-5134/src/doc/examples'
make[1]: Leaving directory '/data/vulnloc/libxml2/CVE-2012-5134/src/doc'
Making clean in example
make[1]: Entering directory '/data/vulnloc/libxml2/CVE-2012-5134/src/example'
rm -rf .libs _libs
 rm -f gjobread
rm -f *.o
rm -f *.lo
make[1]: Leaving directory '/data/vulnloc/libxml2/CVE-2012-5134/src/example'
Making clean in xstc
make[1]: Entering directory '/data/vulnloc/libxml2/CVE-2012-5134/src/xstc'
test -z "nist-test.py ms-test.py sun-test.py test.log" || rm -f nist-test.py ms-test.py sun-test.py test.log
rm -rf .libs _libs
rm -f *.lo
make[1]: Leaving directory '/data/vulnloc/libxml2/CVE-2012-5134/src/xstc'
2025-02-02 13:47:53.940 | DEBUG    | shell:__call__:41 - executing: make CFLAGS="${INJECT_CFLAGS}" CXXFLAGS="${INJECT_CXXFLAGS}" LDFLAGS="${INJECT_LDFLAGS}" xmllint
  CC       xmllint.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       SAX.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       entities.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       encoding.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       error.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       parserInternals.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       parser.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
parser.c:2028:65: warning: comparison of distinct pointer types ('xmlInputReadCallback' (aka 'int (*)(void *, char *, int)') and 'int (*)(void)') [-Wcompare-distinct-pointer-types]
         ((ctxt->input->buf) && (ctxt->input->buf->readcallback != xmlNop)) &&
                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^  ~~~~~~
parser.c:13496:43: warning: passing 'const xmlChar *' (aka 'const unsigned char *') to parameter of type 'const char *' converts between pointers to integer types with different sign [-Wpointer-sign]
        hdlr = xmlFindCharEncodingHandler(doc->encoding);
                                          ^~~~~~~~~~~~~
./include/libxml/encoding.h:175:42: note: passing argument to parameter 'name' here
        xmlFindCharEncodingHandler      (const char *name);
                                                     ^
2 warnings generated.
parser.c:2028:65: warning: comparison of distinct pointer types ('xmlInputReadCallback' (aka 'int (*)(void *, char *, int)') and 'int (*)(void)') [-Wcompare-distinct-pointer-types]
         ((ctxt->input->buf) && (ctxt->input->buf->readcallback != xmlNop)) &&
                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^  ~~~~~~
parser.c:13496:43: warning: passing 'const xmlChar *' (aka 'const unsigned char *') to parameter of type 'const char *' converts between pointers to integer types with different sign [-Wpointer-sign]
        hdlr = xmlFindCharEncodingHandler(doc->encoding);
                                          ^~~~~~~~~~~~~
./include/libxml/encoding.h:175:42: note: passing argument to parameter 'name' here
        xmlFindCharEncodingHandler      (const char *name);
                                                     ^
2 warnings generated.
  CC       tree.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       hash.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       list.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       xmlIO.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       xmlmemory.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       uri.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       valid.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       xlink.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       HTMLparser.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       HTMLtree.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       debugXML.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
debugXML.c:2950:11: warning: comparison of array 'arg' equal to a null pointer is always false [-Wtautological-pointer-compare]
            if ((arg == NULL) || (arg[0] == 0))
                 ^~~    ~~~~
1 warning generated.
debugXML.c:2950:11: warning: comparison of array 'arg' equal to a null pointer is always false [-Wtautological-pointer-compare]
            if ((arg == NULL) || (arg[0] == 0))
                 ^~~    ~~~~
1 warning generated.
  CC       xpath.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
xpath.c:2855:23: warning: implicit declaration of function 'fabs_crepair' is invalid in C99 [-Wimplicit-function-declaration]
            absolute_value = fabs_crepair(number);
                             ^
xpath.c:12401:28: warning: comparison of two values with different enumeration types ('xmlElementType' and 'xmlXPathTypeVal') [-Wenum-compare]
                    } else if (cur->type == type) {
                               ~~~~~~~~~ ^  ~~~~
2 warnings generated.
xpath.c:2855:23: warning: implicit declaration of function 'fabs_crepair' is invalid in C99 [-Wimplicit-function-declaration]
            absolute_value = fabs_crepair(number);
                             ^
xpath.c:12401:28: warning: comparison of two values with different enumeration types ('xmlElementType' and 'xmlXPathTypeVal') [-Wenum-compare]
                    } else if (cur->type == type) {
                               ~~~~~~~~~ ^  ~~~~
2 warnings generated.
  CC       xpointer.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       xinclude.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       nanohttp.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
nanohttp.c:992:67: warning: passing 'int *' to parameter of type 'socklen_t *' (aka 'unsigned int *') converts between pointers to integer types with different sign [-Wpointer-sign]
        if (getsockopt(s, SOL_SOCKET, SO_ERROR, (char *) &status, &len) <
                                                                  ^~~~
/usr/include/x86_64-linux-gnu/sys/socket.h:210:32: note: passing argument to parameter '__optlen' here
                       socklen_t *__restrict __optlen) __THROW;
                                             ^
nanohttp.c:1526:38: warning: while loop has empty body [-Wempty-body]
        while ( xmlNanoHTTPRecv(ctxt) > 0 ) ;
                                            ^
nanohttp.c:1526:38: note: put the semicolon on a separate line to silence this warning
2 warnings generated.
nanohttp.c:992:67: warning: passing 'int *' to parameter of type 'socklen_t *' (aka 'unsigned int *') converts between pointers to integer types with different sign [-Wpointer-sign]
        if (getsockopt(s, SOL_SOCKET, SO_ERROR, (char *) &status, &len) <
                                                                  ^~~~
/usr/include/x86_64-linux-gnu/sys/socket.h:210:32: note: passing argument to parameter '__optlen' here
                       socklen_t *__restrict __optlen) __THROW;
                                             ^
nanohttp.c:1526:38: warning: while loop has empty body [-Wempty-body]
        while ( xmlNanoHTTPRecv(ctxt) > 0 ) ;
                                            ^
nanohttp.c:1526:38: note: put the semicolon on a separate line to silence this warning
2 warnings generated.
  CC       nanoftp.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
nanoftp.c:1471:66: warning: passing 'int *' to parameter of type 'socklen_t *' (aka 'unsigned int *') converts between pointers to integer types with different sign [-Wpointer-sign]
        getsockname(ctxt->dataFd, (struct sockaddr *) &dataAddr, &dataAddrLen);
                                                                 ^~~~~~~~~~~~
/usr/include/x86_64-linux-gnu/sys/socket.h:117:26: note: passing argument to parameter '__len' here
                        socklen_t *__restrict __len) __THROW;
                                              ^
nanoftp.c:1484:66: warning: passing 'int *' to parameter of type 'socklen_t *' (aka 'unsigned int *') converts between pointers to integer types with different sign [-Wpointer-sign]
        getsockname(ctxt->dataFd, (struct sockaddr *) &dataAddr, &dataAddrLen);
                                                                 ^~~~~~~~~~~~
/usr/include/x86_64-linux-gnu/sys/socket.h:117:26: note: passing argument to parameter '__len' here
                        socklen_t *__restrict __len) __THROW;
                                              ^
2 warnings generated.
nanoftp.c:1471:66: warning: passing 'int *' to parameter of type 'socklen_t *' (aka 'unsigned int *') converts between pointers to integer types with different sign [-Wpointer-sign]
        getsockname(ctxt->dataFd, (struct sockaddr *) &dataAddr, &dataAddrLen);
                                                                 ^~~~~~~~~~~~
/usr/include/x86_64-linux-gnu/sys/socket.h:117:26: note: passing argument to parameter '__len' here
                        socklen_t *__restrict __len) __THROW;
                                              ^
nanoftp.c:1484:66: warning: passing 'int *' to parameter of type 'socklen_t *' (aka 'unsigned int *') converts between pointers to integer types with different sign [-Wpointer-sign]
        getsockname(ctxt->dataFd, (struct sockaddr *) &dataAddr, &dataAddrLen);
                                                                 ^~~~~~~~~~~~
/usr/include/x86_64-linux-gnu/sys/socket.h:117:26: note: passing argument to parameter '__len' here
                        socklen_t *__restrict __len) __THROW;
                                              ^
2 warnings generated.
  CC       catalog.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       globals.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       threads.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       c14n.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       xmlstring.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       buf.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       xmlregexp.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       xmlschemas.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       xmlschemastypes.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
xmlschemastypes.c:5861:35: warning: implicit declaration of function 'fabs_crepair' is invalid in C99 [-Wimplicit-function-declaration]
                day = (unsigned long) FQUOTIENT(fabs_crepair(val->value.dur.sec), 86400);
                                                ^
1 warning generated.
xmlschemastypes.c:5861:35: warning: implicit declaration of function 'fabs_crepair' is invalid in C99 [-Wimplicit-function-declaration]
                day = (unsigned long) FQUOTIENT(fabs_crepair(val->value.dur.sec), 86400);
                                                ^
1 warning generated.
  CC       xmlunicode.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       xmlreader.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       relaxng.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       dict.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       SAX2.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       xmlwriter.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       legacy.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       chvalid.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       pattern.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       xmlsave.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       xmlmodule.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       schematron.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       xzlib.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CCLD     libxml2.la
ar: `u' modifier ignored since `D' is the default (see `U')
  CCLD     xmllint
2025-02-02 13:48:04.911 | INFO     | scenario:evaluate:635 - evaluating candidate patch #0:
@@ -3890,6 +3890,7 @@
  *
  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.
  */
+
 static xmlChar *
 xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {
     xmlChar limit = 0;
@@ -3902,22 +3903,24 @@
     xmlEntityPtr ent;
 
     if (ctxt->input->cur[0] == '"') {
-	ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;
-	limit = '"';
+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;
+        limit = '"';
         NEXT;
     } else if (ctxt->input->cur[0] == '\'') {
-	limit = '\'';
-	ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;
+        limit = '\'';
+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;
         NEXT;
     } else {
-	xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);
-	return(NULL);
+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);
+        return(NULL);
     }
 
     /*
      * allocate a translation buffer.
      */
-    buf_size = XML_PARSER_BUFFER_SIZE;
+    buf_size = XML_PARSER_BUFFER_SIZE; // Original vulnerability line
+    if (buf_size > XML_MAX_BUFFER_SIZE)   // Added buffer size check
+        buf_size = XML_MAX_BUFFER_SIZE;
     buf = (xmlChar *) xmlMallocAtomic(buf_size);
     if (buf == NULL) goto mem_error;
 
@@ -3938,139 +3941,139 @@
                            "AttValue lenght too long\n");
             goto mem_error;
         }
-	if (c == 0) break;
-	if (c == '&') {
-	    in_space = 0;
-	    if (ctxt->input->cur[1] == '#') {
-		int val = xmlParseCharRef(ctxt);
-
-		if (val == '&') {
-		    if (ctxt->replaceEntities) {
-			if (len + 10 > buf_size) {
-			    growBuffer(buf, 10);
-			}
-			buf[len++] = '&';
-		    } else {
-			/*
-			 * The reparsing will be done in xmlStringGetNodeList()
-			 * called by the attribute() function in SAX.c
-			 */
-			if (len + 10 > buf_size) {
-			    growBuffer(buf, 10);
-			}
-			buf[len++] = '&';
-			buf[len++] = '#';
-			buf[len++] = '3';
-			buf[len++] = '8';
-			buf[len++] = ';';
-		    }
-		} else if (val != 0) {
-		    if (len + 10 > buf_size) {
-			growBuffer(buf, 10);
-		    }
-		    len += xmlCopyChar(0, &buf[len], val);
-		}
-	    } else {
-		ent = xmlParseEntityRef(ctxt);
-		ctxt->nbentities++;
-		if (ent != NULL)
-		    ctxt->nbentities += ent->owner;
-		if ((ent != NULL) &&
-		    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
-		    if (len + 10 > buf_size) {
-			growBuffer(buf, 10);
-		    }
-		    if ((ctxt->replaceEntities == 0) &&
-		        (ent->content[0] == '&')) {
-			buf[len++] = '&';
-			buf[len++] = '#';
-			buf[len++] = '3';
-			buf[len++] = '8';
-			buf[len++] = ';';
-		    } else {
-			buf[len++] = ent->content[0];
-		    }
-		} else if ((ent != NULL) &&
-		           (ctxt->replaceEntities != 0)) {
-		    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {
-			rep = xmlStringDecodeEntities(ctxt, ent->content,
-						      XML_SUBSTITUTE_REF,
-						      0, 0, 0);
-			if (rep != NULL) {
-			    current = rep;
-			    while (*current != 0) { /* non input consuming */
+        if (c == 0) break;
+        if (c == '&') {
+            in_space = 0;
+            if (ctxt->input->cur[1] == '#') {
+                int val = xmlParseCharRef(ctxt);
+
+                if (val == '&') {
+                    if (ctxt->replaceEntities) {
+                        if (len + 10 > buf_size) {
+                            growBuffer(buf, 10);
+                        }
+                        buf[len++] = '&';
+                    } else {
+                        /*
+                         * The reparsing will be done in xmlStringGetNodeList()
+                         * called by the attribute() function in SAX.c
+                         */
+                        if (len + 10 > buf_size) {
+                            growBuffer(buf, 10);
+                        }
+                        buf[len++] = '&';
+                        buf[len++] = '#';
+                        buf[len++] = '3';
+                        buf[len++] = '8';
+                        buf[len++] = ';';
+                    }
+                } else if (val != 0) {
+                    if (len + 10 > buf_size) {
+                        growBuffer(buf, 10);
+                    }
+                    len += xmlCopyChar(0, &buf[len], val);
+                }
+            } else {
+                ent = xmlParseEntityRef(ctxt);
+                ctxt->nbentities++;
+                if (ent != NULL)
+                    ctxt->nbentities += ent->owner;
+                if ((ent != NULL) &&
+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
+                    if (len + 10 > buf_size) {
+                        growBuffer(buf, 10);
+                    }
+                    if ((ctxt->replaceEntities == 0) &&
+                        (ent->content[0] == '&')) {
+                        buf[len++] = '&';
+                        buf[len++] = '#';
+                        buf[len++] = '3';
+                        buf[len++] = '8';
+                        buf[len++] = ';';
+                    } else {
+                        buf[len++] = ent->content[0];
+                    }
+                } else if ((ent != NULL) &&
+                           (ctxt->replaceEntities != 0)) {
+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {
+                        rep = xmlStringDecodeEntities(ctxt, ent->content,
+                                                      XML_SUBSTITUTE_REF,
+                                                      0, 0, 0);
+                        if (rep != NULL) {
+                            current = rep;
+                            while (*current != 0) { /* non input consuming */
                                 if ((*current == 0xD) || (*current == 0xA) ||
                                     (*current == 0x9)) {
                                     buf[len++] = 0x20;
                                     current++;
                                 } else
                                     buf[len++] = *current++;
-				if (len + 10 > buf_size) {
-				    growBuffer(buf, 10);
-				}
-			    }
-			    xmlFree(rep);
-			    rep = NULL;
-			}
-		    } else {
-			if (len + 10 > buf_size) {
-			    growBuffer(buf, 10);
-			}
-			if (ent->content != NULL)
-			    buf[len++] = ent->content[0];
-		    }
-		} else if (ent != NULL) {
-		    int i = xmlStrlen(ent->name);
-		    const xmlChar *cur = ent->name;
-
-		    /*
-		     * This may look absurd but is needed to detect
-		     * entities problems
-		     */
-		    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&
-			(ent->content != NULL)) {
-			rep = xmlStringDecodeEntities(ctxt, ent->content,
-						  XML_SUBSTITUTE_REF, 0, 0, 0);
-			if (rep != NULL) {
-			    xmlFree(rep);
-			    rep = NULL;
-			}
-		    }
-
-		    /*
-		     * Just output the reference
-		     */
-		    buf[len++] = '&';
-		    while (len + i + 10 > buf_size) {
-			growBuffer(buf, i + 10);
-		    }
-		    for (;i > 0;i--)
-			buf[len++] = *cur++;
-		    buf[len++] = ';';
-		}
-	    }
-	} else {
-	    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {
-	        if ((len != 0) || (!normalize)) {
-		    if ((!normalize) || (!in_space)) {
-			COPY_BUF(l,buf,len,0x20);
-			while (len + 10 > buf_size) {
-			    growBuffer(buf, 10);
-			}
-		    }
-		    in_space = 1;
-		}
-	    } else {
-	        in_space = 0;
-		COPY_BUF(l,buf,len,c);
-		if (len + 10 > buf_size) {
-		    growBuffer(buf, 10);
-		}
-	    }
-	    NEXTL(l);
-	}
-	GROW;
-	c = CUR_CHAR(l);
+                                if (len + 10 > buf_size) {
+                                    growBuffer(buf, 10);
+                                }
+                            }
+                            xmlFree(rep);
+                            rep = NULL;
+                        }
+                    } else {
+                        if (len + 10 > buf_size) {
+                            growBuffer(buf, 10);
+                        }
+                        if (ent->content != NULL)
+                            buf[len++] = ent->content[0];
+                    }
+                } else if (ent != NULL) {
+                    int i = xmlStrlen(ent->name);
+                    const xmlChar *cur = ent->name;
+
+                    /*
+                     * This may look absurd but is needed to detect
+                     * entities problems
+                     */
+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&
+                        (ent->content != NULL)) {
+                        rep = xmlStringDecodeEntities(ctxt, ent->content,
+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);
+                        if (rep != NULL) {
+                            xmlFree(rep);
+                            rep = NULL;
+                        }
+                    }
+
+                    /*
+                     * Just output the reference
+                     */
+                    buf[len++] = '&';
+                    while (len + i + 10 > buf_size) {
+                        growBuffer(buf, i + 10);
+                    }
+                    for (;i > 0;i--)
+                        buf[len++] = *cur++;
+                    buf[len++] = ';';
+                }
+            }
+        } else {
+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {
+                if ((len != 0) || (!normalize)) {
+                    if ((!normalize) || (!in_space)) {
+                        COPY_BUF(l,buf,len,0x20);
+                        while (len + 10 > buf_size) {
+                            growBuffer(buf, 10);
+                        }
+                    }
+                    in_space = 1;
+                }
+            } else {
+                in_space = 0;
+                COPY_BUF(l,buf,len,c);
+                if (len + 10 > buf_size) {
+                    growBuffer(buf, 10);
+                }
+            }
+            NEXTL(l);
+        }
+        GROW;
+        c = CUR_CHAR(l);
     }
     if (ctxt->instate == XML_PARSER_EOF)
         goto error;
@@ -4080,17 +4083,17 @@
     }
     buf[len] = 0;
     if (RAW == '<') {
-	xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);
+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);
     } else if (RAW != limit) {
-	if ((c != 0) && (!IS_CHAR(c))) {
-	    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,
-			   "invalid character in attribute value\n");
-	} else {
-	    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
-			   "AttValue: ' expected\n");
+        if ((c != 0) && (!IS_CHAR(c))) {
+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,
+                           "invalid character in attribute value\n");
+        } else {
+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
+                           "AttValue: ' expected\n");
         }
     } else
-	NEXT;
+    NEXT;
 
     /*
      * There we potentially risk an overflow, don't allow attribute value of
@@ -4115,6 +4118,7 @@
     return(NULL);
 }
 
+
 /**
  * xmlParseAttValue:
  * @ctxt:  an XML parser context

2025-02-02 13:48:04.920 | DEBUG    | scenario:rebuild:369 - original environment: environ({'CONDA_SHLVL': '2', 'LC_ALL': 'C.UTF-8', 'LS_COLORS': 'rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:', 'LD_LIBRARY_PATH': '/opt/crashrepair/lib:/CrashRepair/lib:/klee/build/lib:', 'CONDA_EXE': '/root/anaconda3/bin/conda', 'LANG': 'C.UTF-8', 'TZ': 'Asia/Shanghai', 'HOSTNAME': 'fea22102047d', 'OLDPWD': '/orchestrator', 'CONDA_PREFIX': '/root/anaconda3/envs/CrashRepair', '_CE_M': '', 'CC': 'crepair-cc', 'LLVM_COMPILER': 'clang', 'CONDA_PREFIX_1': '/root/anaconda3', 'PWD': '/orchestrator/crashrepair', 'HOME': '/root', 'CONDA_PYTHON_EXE': '/root/anaconda3/bin/python', '_CE_CONDA': '', 'CONDA_PROMPT_MODIFIER': '(CrashRepair) ', 'CXX': 'crepair-cxx', 'TERM': 'xterm', 'SHLVL': '2', 'PYTHONPATH': '/usr/lib/python3.8/site-packages:', 'PATH': '/root/anaconda3/envs/CrashRepair/bin:/root/anaconda3/condabin:~/anaconda3/bin:/opt/crashrepair/bin:/CrashRepair/compiler:/klee/build/bin:/opt/llvm-6/bin:/klee/build/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin', 'CONDA_DEFAULT_ENV': 'CrashRepair', '_': '/root/anaconda3/envs/CrashRepair/bin/python'})
2025-02-02 13:48:04.920 | DEBUG    | scenario:rebuild:382 - injecting ghost function into CFLAGS during build: -lcrepair_ghost
2025-02-02 13:48:04.920 | DEBUG    | scenario:rebuild:398 - using environment: {'INJECT_CFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address', 'INJECT_CXXFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address', 'INJECT_LDFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address'}
2025-02-02 13:48:04.921 | DEBUG    | shell:__call__:41 - executing: make CFLAGS="${INJECT_CFLAGS}" CXXFLAGS="${INJECT_CXXFLAGS}" LDFLAGS="${INJECT_LDFLAGS}" xmllint
  CC       parser.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
parser.c:2028:65: warning: comparison of distinct pointer types ('xmlInputReadCallback' (aka 'int (*)(void *, char *, int)') and 'int (*)(void)') [-Wcompare-distinct-pointer-types]
         ((ctxt->input->buf) && (ctxt->input->buf->readcallback != xmlNop)) &&
                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^  ~~~~~~
parser.c:3922:20: error: use of undeclared identifier 'XML_MAX_BUFFER_SIZE'; did you mean 'XML_IO_BUFFER_FULL'?
    if (buf_size > XML_MAX_BUFFER_SIZE)   // Added buffer size check
                   ^~~~~~~~~~~~~~~~~~~
                   XML_IO_BUFFER_FULL
./include/libxml/xmlerror.h:463:5: note: 'XML_IO_BUFFER_FULL' declared here
    XML_IO_BUFFER_FULL, /* 1548 */
    ^
parser.c:3923:20: error: use of undeclared identifier 'XML_MAX_BUFFER_SIZE'; did you mean 'XML_IO_BUFFER_FULL'?
        buf_size = XML_MAX_BUFFER_SIZE;
                   ^~~~~~~~~~~~~~~~~~~
                   XML_IO_BUFFER_FULL
./include/libxml/xmlerror.h:463:5: note: 'XML_IO_BUFFER_FULL' declared here
    XML_IO_BUFFER_FULL, /* 1548 */
    ^
parser.c:13500:43: warning: passing 'const xmlChar *' (aka 'const unsigned char *') to parameter of type 'const char *' converts between pointers to integer types with different sign [-Wpointer-sign]
        hdlr = xmlFindCharEncodingHandler(doc->encoding);
                                          ^~~~~~~~~~~~~
./include/libxml/encoding.h:175:42: note: passing argument to parameter 'name' here
        xmlFindCharEncodingHandler      (const char *name);
                                                     ^
2 warnings and 2 errors generated.
ERROR:Failed to compile using given arguments: [-g -O0 -include /CrashRepair/compiler/../lib/crepair_runtime.h -DHAVE_CONFIG_H -I. -I./include -I./include -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT parser.lo -MD -MP -MF .deps/parser.Tpo -c parser.c -o parser.o -L/CrashRepair/compiler/../lib/ -L/klee/build/lib/ -lcrepair_runtime -lcrepair_proxy -lkleeRuntest -fno-sanitize=address]
Makefile:1238: recipe for target 'parser.lo' failed
make: *** [parser.lo] Error 1
2025-02-02 13:48:05.066 | INFO     | scenario:evaluate:643 - candidate patch #0 failed to compile
2025-02-02 13:48:05.072 | INFO     | scenario:evaluate:635 - evaluating candidate patch #1:
@@ -3890,6 +3890,7 @@
  *
  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.
  */
+
 static xmlChar *
 xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {
     xmlChar limit = 0;
@@ -3902,20 +3903,20 @@
     xmlEntityPtr ent;
 
     if (ctxt->input->cur[0] == '"') {
-	ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;
-	limit = '"';
+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;
+        limit = '"';
         NEXT;
     } else if (ctxt->input->cur[0] == '\'') {
-	limit = '\'';
-	ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;
+        limit = '\'';
+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;
         NEXT;
     } else {
-	xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);
-	return(NULL);
+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);
+        return(NULL);
     }
 
     /*
-     * allocate a translation buffer.
+     * allocate a translation buffer with a dynamic size.
      */
     buf_size = XML_PARSER_BUFFER_SIZE;
     buf = (xmlChar *) xmlMallocAtomic(buf_size);
@@ -3935,142 +3936,147 @@
         if ((len > XML_MAX_TEXT_LENGTH) &&
             ((ctxt->options & XML_PARSE_HUGE) == 0)) {
             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
-                           "AttValue lenght too long\n");
+                           "AttValue length too long\n");
             goto mem_error;
         }
-	if (c == 0) break;
-	if (c == '&') {
-	    in_space = 0;
-	    if (ctxt->input->cur[1] == '#') {
-		int val = xmlParseCharRef(ctxt);
-
-		if (val == '&') {
-		    if (ctxt->replaceEntities) {
-			if (len + 10 > buf_size) {
-			    growBuffer(buf, 10);
-			}
-			buf[len++] = '&';
-		    } else {
-			/*
-			 * The reparsing will be done in xmlStringGetNodeList()
-			 * called by the attribute() function in SAX.c
-			 */
-			if (len + 10 > buf_size) {
-			    growBuffer(buf, 10);
-			}
-			buf[len++] = '&';
-			buf[len++] = '#';
-			buf[len++] = '3';
-			buf[len++] = '8';
-			buf[len++] = ';';
-		    }
-		} else if (val != 0) {
-		    if (len + 10 > buf_size) {
-			growBuffer(buf, 10);
-		    }
-		    len += xmlCopyChar(0, &buf[len], val);
-		}
-	    } else {
-		ent = xmlParseEntityRef(ctxt);
-		ctxt->nbentities++;
-		if (ent != NULL)
-		    ctxt->nbentities += ent->owner;
-		if ((ent != NULL) &&
-		    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
-		    if (len + 10 > buf_size) {
-			growBuffer(buf, 10);
-		    }
-		    if ((ctxt->replaceEntities == 0) &&
-		        (ent->content[0] == '&')) {
-			buf[len++] = '&';
-			buf[len++] = '#';
-			buf[len++] = '3';
-			buf[len++] = '8';
-			buf[len++] = ';';
-		    } else {
-			buf[len++] = ent->content[0];
-		    }
-		} else if ((ent != NULL) &&
-		           (ctxt->replaceEntities != 0)) {
-		    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {
-			rep = xmlStringDecodeEntities(ctxt, ent->content,
-						      XML_SUBSTITUTE_REF,
-						      0, 0, 0);
-			if (rep != NULL) {
-			    current = rep;
-			    while (*current != 0) { /* non input consuming */
+        if (c == 0) break;
+        if (c == '&') {
+            in_space = 0;
+            if (ctxt->input->cur[1] == '#') {
+                int val = xmlParseCharRef(ctxt);
+
+                if (val == '&') {
+                    if (ctxt->replaceEntities) {
+                        if (len + 10 > buf_size) {
+                            buf_size += 10; // dynamic resizing here
+                            buf = (xmlChar *) xmlRealloc(buf, buf_size);
+                        }
+                        buf[len++] = '&';
+                    } else {
+                        if (len + 10 > buf_size) {
+                            buf_size += 10; // dynamic resizing here
+                            buf = (xmlChar *) xmlRealloc(buf, buf_size);
+                        }
+                        buf[len++] = '&';
+                        buf[len++] = '#';
+                        buf[len++] = '3';
+                        buf[len++] = '8';
+                        buf[len++] = ';';
+                    }
+                } else if (val != 0) {
+                    if (len + 10 > buf_size) {
+                        buf_size += 10; // dynamic resizing here
+                        buf = (xmlChar *) xmlRealloc(buf, buf_size);
+                    }
+                    len += xmlCopyChar(0, &buf[len], val);
+                }
+            } else {
+                ent = xmlParseEntityRef(ctxt);
+                ctxt->nbentities++;
+                if (ent != NULL)
+                    ctxt->nbentities += ent->owner;
+                if ((ent != NULL) &&
+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
+                    if (len + 10 > buf_size) {
+                        buf_size += 10; // dynamic resizing here
+                        buf = (xmlChar *) xmlRealloc(buf, buf_size);
+                    }
+                    if ((ctxt->replaceEntities == 0) &&
+                        (ent->content[0] == '&')) {
+                        buf[len++] = '&';
+                        buf[len++] = '#';
+                        buf[len++] = '3';
+                        buf[len++] = '8';
+                        buf[len++] = ';';
+                    } else {
+                        buf[len++] = ent->content[0];
+                    }
+                } else if ((ent != NULL) &&
+                           (ctxt->replaceEntities != 0)) {
+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {
+                        rep = xmlStringDecodeEntities(ctxt, ent->content,
+                                                      XML_SUBSTITUTE_REF,
+                                                      0, 0, 0);
+                        if (rep != NULL) {
+                            current = rep;
+                            while (*current != 0) { /* non input consuming */
                                 if ((*current == 0xD) || (*current == 0xA) ||
                                     (*current == 0x9)) {
                                     buf[len++] = 0x20;
                                     current++;
                                 } else
                                     buf[len++] = *current++;
-				if (len + 10 > buf_size) {
-				    growBuffer(buf, 10);
-				}
-			    }
-			    xmlFree(rep);
-			    rep = NULL;
-			}
-		    } else {
-			if (len + 10 > buf_size) {
-			    growBuffer(buf, 10);
-			}
-			if (ent->content != NULL)
-			    buf[len++] = ent->content[0];
-		    }
-		} else if (ent != NULL) {
-		    int i = xmlStrlen(ent->name);
-		    const xmlChar *cur = ent->name;
-
-		    /*
-		     * This may look absurd but is needed to detect
-		     * entities problems
-		     */
-		    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&
-			(ent->content != NULL)) {
-			rep = xmlStringDecodeEntities(ctxt, ent->content,
-						  XML_SUBSTITUTE_REF, 0, 0, 0);
-			if (rep != NULL) {
-			    xmlFree(rep);
-			    rep = NULL;
-			}
-		    }
-
-		    /*
-		     * Just output the reference
-		     */
-		    buf[len++] = '&';
-		    while (len + i + 10 > buf_size) {
-			growBuffer(buf, i + 10);
-		    }
-		    for (;i > 0;i--)
-			buf[len++] = *cur++;
-		    buf[len++] = ';';
-		}
-	    }
-	} else {
-	    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {
-	        if ((len != 0) || (!normalize)) {
-		    if ((!normalize) || (!in_space)) {
-			COPY_BUF(l,buf,len,0x20);
-			while (len + 10 > buf_size) {
-			    growBuffer(buf, 10);
-			}
-		    }
-		    in_space = 1;
-		}
-	    } else {
-	        in_space = 0;
-		COPY_BUF(l,buf,len,c);
-		if (len + 10 > buf_size) {
-		    growBuffer(buf, 10);
-		}
-	    }
-	    NEXTL(l);
-	}
-	GROW;
-	c = CUR_CHAR(l);
+                                if (len + 10 > buf_size) {
+                                    buf_size += 10; // dynamic resizing here
+                                    buf = (xmlChar *) xmlRealloc(buf, buf_size);
+                                }
+                            }
+                            xmlFree(rep);
+                            rep = NULL;
+                        }
+                    } else {
+                        if (len + 10 > buf_size) {
+                            buf_size += 10; // dynamic resizing here
+                            buf = (xmlChar *) xmlRealloc(buf, buf_size);
+                        }
+                        if (ent->content != NULL)
+                            buf[len++] = ent->content[0];
+                    }
+                } else if (ent != NULL) {
+                    int i = xmlStrlen(ent->name);
+                    const xmlChar *cur = ent->name;
+
+                    /*
+                     * This may look absurd but is needed to detect
+                     * entities problems
+                     */
+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&
+                        (ent->content != NULL)) {
+                        rep = xmlStringDecodeEntities(ctxt, ent->content,
+                                                      XML_SUBSTITUTE_REF, 0, 0, 0);
+                        if (rep != NULL) {
+                            xmlFree(rep);
+                            rep = NULL;
+                        }
+                    }
+
+                    /*
+                     * Just output the reference
+                     */
+                    buf[len++] = '&';
+                    while (len + i + 10 > buf_size) {
+                        buf_size += i + 10; // dynamic resizing here
+                        buf = (xmlChar *) xmlRealloc(buf, buf_size);
+                    }
+                    for (; i > 0; i--)
+                        buf[len++] = *cur++;
+                    buf[len++] = ';';
+                }
+            }
+        } else {
+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {
+                if ((len != 0) || (!normalize)) {
+                    if ((!normalize) || (!in_space)) {
+                        COPY_BUF(l, buf, len, 0x20);
+                        while (len + 10 > buf_size) {
+                            buf_size += 10; // dynamic resizing here
+                            buf = (xmlChar *) xmlRealloc(buf, buf_size);
+                        }
+                    }
+                    in_space = 1;
+                }
+            } else {
+                in_space = 0;
+                COPY_BUF(l, buf, len, c);
+                if (len + 10 > buf_size) {
+                    buf_size += 10; // dynamic resizing here
+                    buf = (xmlChar *) xmlRealloc(buf, buf_size);
+                }
+            }
+            NEXTL(l);
+        }
+        GROW;
+        c = CUR_CHAR(l);
     }
     if (ctxt->instate == XML_PARSER_EOF)
         goto error;
@@ -4080,25 +4086,25 @@
     }
     buf[len] = 0;
     if (RAW == '<') {
-	xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);
+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);
     } else if (RAW != limit) {
-	if ((c != 0) && (!IS_CHAR(c))) {
-	    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,
-			   "invalid character in attribute value\n");
-	} else {
-	    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
-			   "AttValue: ' expected\n");
+        if ((c != 0) && (!IS_CHAR(c))) {
+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,
+                           "invalid character in attribute value\n");
+        } else {
+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
+                           "AttValue: ' expected\n");
         }
     } else
-	NEXT;
+        NEXT;
 
     /*
      * There we potentially risk an overflow, don't allow attribute value of
-     * lenght more than INT_MAX it is a very reasonnable assumption !
+     * length more than INT_MAX it is a very reasonable assumption!
      */
     if (len >= INT_MAX) {
         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
-                       "AttValue lenght too long\n");
+                       "AttValue length too long\n");
         goto mem_error;
     }
 
@@ -4115,6 +4121,7 @@
     return(NULL);
 }
 
+
 /**
  * xmlParseAttValue:
  * @ctxt:  an XML parser context

2025-02-02 13:48:05.081 | DEBUG    | scenario:rebuild:369 - original environment: environ({'CONDA_SHLVL': '2', 'LC_ALL': 'C.UTF-8', 'LS_COLORS': 'rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:', 'LD_LIBRARY_PATH': '/opt/crashrepair/lib:/CrashRepair/lib:/klee/build/lib:', 'CONDA_EXE': '/root/anaconda3/bin/conda', 'LANG': 'C.UTF-8', 'TZ': 'Asia/Shanghai', 'HOSTNAME': 'fea22102047d', 'OLDPWD': '/orchestrator', 'CONDA_PREFIX': '/root/anaconda3/envs/CrashRepair', '_CE_M': '', 'CC': 'crepair-cc', 'LLVM_COMPILER': 'clang', 'CONDA_PREFIX_1': '/root/anaconda3', 'PWD': '/orchestrator/crashrepair', 'HOME': '/root', 'CONDA_PYTHON_EXE': '/root/anaconda3/bin/python', '_CE_CONDA': '', 'CONDA_PROMPT_MODIFIER': '(CrashRepair) ', 'CXX': 'crepair-cxx', 'TERM': 'xterm', 'SHLVL': '2', 'PYTHONPATH': '/usr/lib/python3.8/site-packages:', 'PATH': '/root/anaconda3/envs/CrashRepair/bin:/root/anaconda3/condabin:~/anaconda3/bin:/opt/crashrepair/bin:/CrashRepair/compiler:/klee/build/bin:/opt/llvm-6/bin:/klee/build/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin', 'CONDA_DEFAULT_ENV': 'CrashRepair', '_': '/root/anaconda3/envs/CrashRepair/bin/python'})
2025-02-02 13:48:05.081 | DEBUG    | scenario:rebuild:382 - injecting ghost function into CFLAGS during build: -lcrepair_ghost
2025-02-02 13:48:05.081 | DEBUG    | scenario:rebuild:398 - using environment: {'INJECT_CFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address', 'INJECT_CXXFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address', 'INJECT_LDFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address'}
2025-02-02 13:48:05.081 | DEBUG    | shell:__call__:41 - executing: make CFLAGS="${INJECT_CFLAGS}" CXXFLAGS="${INJECT_CXXFLAGS}" LDFLAGS="${INJECT_LDFLAGS}" xmllint
  CC       parser.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
parser.c:2028:65: warning: comparison of distinct pointer types ('xmlInputReadCallback' (aka 'int (*)(void *, char *, int)') and 'int (*)(void)') [-Wcompare-distinct-pointer-types]
         ((ctxt->input->buf) && (ctxt->input->buf->readcallback != xmlNop)) &&
                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^  ~~~~~~
parser.c:13503:43: warning: passing 'const xmlChar *' (aka 'const unsigned char *') to parameter of type 'const char *' converts between pointers to integer types with different sign [-Wpointer-sign]
        hdlr = xmlFindCharEncodingHandler(doc->encoding);
                                          ^~~~~~~~~~~~~
./include/libxml/encoding.h:175:42: note: passing argument to parameter 'name' here
        xmlFindCharEncodingHandler      (const char *name);
                                                     ^
2 warnings generated.
parser.c:2028:65: warning: comparison of distinct pointer types ('xmlInputReadCallback' (aka 'int (*)(void *, char *, int)') and 'int (*)(void)') [-Wcompare-distinct-pointer-types]
         ((ctxt->input->buf) && (ctxt->input->buf->readcallback != xmlNop)) &&
                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^  ~~~~~~
parser.c:13503:43: warning: passing 'const xmlChar *' (aka 'const unsigned char *') to parameter of type 'const char *' converts between pointers to integer types with different sign [-Wpointer-sign]
        hdlr = xmlFindCharEncodingHandler(doc->encoding);
                                          ^~~~~~~~~~~~~
./include/libxml/encoding.h:175:42: note: passing argument to parameter 'name' here
        xmlFindCharEncodingHandler      (const char *name);
                                                     ^
2 warnings generated.
  CCLD     libxml2.la
ar: `u' modifier ignored since `D' is the default (see `U')
  CCLD     xmllint
2025-02-02 13:48:05.834 | DEBUG    | scenario:evaluate:655 - testing candidate #1 against test #crash...
2025-02-02 13:48:05.835 | DEBUG    | shell:__call__:41 - executing: /data//vulnloc/libxml2/CVE-2012-5134/src/xmllint /CrashRepair/experiments/vulnloc/libxml2/CVE-2012-5134/tests/1.xml
2025-02-02 13:48:05.839 | INFO     | scenario:evaluate:659 - candidate #1 passes test #crash
2025-02-02 13:48:05.839 | INFO     | scenario:evaluate:674 - repair found! candidate #1 passes all tests
2025-02-02 13:48:05.847 | INFO     | scenario:validate:513 - saving successful patch #1...
2025-02-02 13:48:05.847 | INFO     | scenario:validate:520 - stopping search: patch was found

