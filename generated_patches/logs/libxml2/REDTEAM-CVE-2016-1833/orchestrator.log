2025-02-02 12:48:55.696 | INFO     | scenario:build:265 - loaded bug scenario: Scenario(subject='libxml2', name='REDTEAM-CVE-2016-1833', directory='/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833', build_directory='/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src', source_directory='/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src', tag_id='libxml2_REDTEAM-CVE-2016-1833', binary_path='/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/xmllint', clean_command='make clean', prebuild_command='exit 0', build_command='make CFLAGS="${INJECT_CFLAGS}" CXXFLAGS="${INJECT_CXXFLAGS}" LDFLAGS="${INJECT_LDFLAGS}" xmllint', crashing_command='--html $POC', crashing_input='/CrashRepair/experiments/vulnloc/libxml2/REDTEAM-CVE-2016-1833/exploit', shell=Shell(cwd='/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833'), crash_test=Test(name='crash', command='/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/xmllint --html /CrashRepair/experiments/vulnloc/libxml2/REDTEAM-CVE-2016-1833/exploit', expected_exit_code=0, expected_stdout=None, bad_output='SUMMARY: AddressSanitizer:', asan_options=None, ubsan_options=None), sanitizer_flags='-fsanitize=address', additional_klee_flags='', expected_exit_code_for_crashing_input=0, should_terminate_early=True, fuzzer_tests=[], fuzzer=None, time_limit_minutes_validation=None, time_limit_seconds_single_test=30, time_limit_minutes_analysis=3600, halt_on_error=True, rebuild_for_validation=False, asan_options=None, ubsan_options=None, use_ghost_functions=True, acceptable_patch_limit=None)
2025-02-02 12:48:55.696 | INFO     | scenario:fuzz:426 - skipping fuzzing: fuzzer disabled
2025-02-02 12:48:55.696 | INFO     | analyzer:run:114 - running analysis with timeout: 60 minutes
2025-02-02 12:48:55.696 | DEBUG    | analyzer:write_config_to_file:88 - generated analyzer config:

dir_exp:/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833
tag_id:libxml2_REDTEAM-CVE-2016-1833
src_directory:/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src
binary_path:/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/xmllint
config_command:exit 0
build_command:make CFLAGS="${INJECT_CFLAGS}" CXXFLAGS="${INJECT_CXXFLAGS}" LDFLAGS="${INJECT_LDFLAGS}" xmllint
test_input_list:--html $POC
poc_list:/CrashRepair/experiments/vulnloc/libxml2/REDTEAM-CVE-2016-1833/exploit
klee_flags:--link-llvm-lib=/CrashRepair/lib/libcrepair_proxy.bca 

2025-02-02 12:48:55.696 | DEBUG    | analyzer:run:124 - wrote analyzer config file to: /tmp/tmpcqm_vguu
2025-02-02 12:48:55.696 | DEBUG    | shell:__call__:41 - executing: crepair --conf=/tmp/tmpcqm_vguu
[K[1;36m
====================================================================================================

	Starting CRepair (C Crash Repair) 
====================================================================================================
[0m
[K[1;36m
	Loading Configurations
	__________________________________________________________________________________________
[0m
[K	[1;34mreading configuration values from arguments[0m
[K	[1;34mreading configuration values form configuration file[0m
[K	[1;37m	[file] /tmp/tmpcqm_vguu[0m
[K	[1;34mupdating configuration values[0m
[K	[1;34mreading test configuration[0m
[K	[1;34mreading seed information[0m
[K	[1;37m	[config] stack size: 15000[0m
[K	[1;37m	[config] collecting stats: False[0m
[K	[1;37m	[config] number of tests: 1[0m
[K	[1;37m	[config] number of cores: 8[0m
[K	[1;37m	[config] klee concrete execution timeout: 600[0m
[K	[1;37m	[config] klee concolic execution timeout: 1200[0m
[K	[1;37m	[config] synthesize subset expressions: True[0m
[K	[1;37m	[config] window size for taint locations: 500[0m
[K	[1;37m	[config] window size for taint values: 500000[0m
[K[1;36m

	Analyzing Program
====================================================================================================
[0m
[K[1;36m
	Test Case #1
	__________________________________________________________________________________________
[0m
[K[1;36m
		Running Concrete Execution
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37mUsing Arguments: ['--html', '$POC'][0m
[K	[1;37m	[0m[K     [1;37mUsing Input File: /CrashRepair/experiments/vulnloc/libxml2/REDTEAM-
                        CVE-2016-1833/exploit[0m
[K	[1;34m	building program[0m
[K	[1;34m		setting environment variables[0m
[K	[1;34m		cleaning files[0m
[K	[1;34m		configuring program[0m
[K	[1;34m		compiling program[0m
[K	[1;37m	[0m[K     [1;37mUsing Binary: /data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/xmllint[0m
[K	[1;34m	extracting bytecode[0m
[K	[1;34m	executing klee in concrete mode[0m
[K	[1;34m	extracting instruction trace[0m
[K	[1;37m		[note] program crashed[0m
[K	[1;34m	collecting tainted expressions[0m
[K	[1;34m	collecting tainted concrete values[0m
[K	[1;34m	collecting memory allocations/de-allocations[0m
[K	[1;34m	collecting pointer mapping[0m
[K	[1;34m	extracting crash information[0m
[K	[1;37m		[0m[K     [1;37m[info] crash type: memory read overflow[0m
[K	[1;37m		[0m[K     [1;37m[info] crash location: /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:439:6[0m
[K	[1;37m		[0m[K     [1;37m[info] crash function: htmlCurrentChar[0m
[K	[1;37m		[0m[K     [1;37m[info] crash address: 435620[0m
[K	[1;37m		[0m[K     [1;37m[info] crash free constraint: (@var(pointer, cur) < ((base  @var(pointer, cur)) + (size
                             @var(pointer, cur))))[0m
[K	[1;37m		[0m[K     [1;37m[info] crash inducing variables: (base  @var(pointer, cur)), (size  @var(pointer, cur)),
                             cur[0m
[K	[1;37m			[info] identified crash type: memory read overflow[0m
[K[1;36m
		Running Concolic Execution
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37mUsing Arguments: ['--html', '$POC'][0m
[K	[1;37m	[0m[K     [1;37mUsing Input File: /CrashRepair/experiments/vulnloc/libxml2/REDTEAM-
                        CVE-2016-1833/exploit[0m
[K	[1;34m	building program[0m
[K	[1;34m		setting environment variables[0m
[K	[1;34m		cleaning files[0m
[K	[1;34m		configuring program[0m
[K	[1;34m		compiling program[0m
[K	[1;34m	extracting bytecode[0m
[K	[1;34m	generating ktest file[0m
[K	[1;34m	executing klee in concolic mode[0m
[K	[1;34m	extracting largest symbolic path[0m
[K	[1;34m	extracting instruction trace[0m
[K	[1;37m		[note] program crashed[0m
[K	[1;34m	collecting tainted expressions[0m
[K	[1;34m	collecting memory allocations/de-allocations[0m
[K	[1;34m	collecting pointer mapping[0m
[K	[1;37m		[0m[K     [1;37m[info] Symbolic Mapping: cur -> [bv883576832][0m
[K	[1;37m		[0m[K     [1;37m[info] Symbolic Mapping: (size  @var(pointer, cur)) -> [][0m
[K	[1;37m		[0m[K     [1;37m[info] Symbolic Mapping: (base  @var(pointer, cur)) -> [bv883576832][0m
[K[1;36m

	Fix Localization
====================================================================================================
[0m
[K[1;36m
	Generating Fix Locations
	__________________________________________________________________________________________
[0m
[K	[1;34m	generating taint map[0m
[K	[1;37m		[0m[K     [1;37m[info] found 5630 tainted locations[0m
[K	[1;34m		starting parallel computing[0m
[K	[1;34m		waiting for thread completion[0m
[K	[1;37m		[0m[K     [1;37m[info] found 6 source files[0m
[K	[1;37m		[0m[K     [1;37m[info] found 12 executed functions[0m
[K	[1;34m	generating possible fix locations[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:482:11[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:489:35[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:489:50[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:489:43[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:489:37[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:489:31[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:489:24[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:489:18[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:486:6[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:486:13[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:480:7[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:480:17[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:480:10[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:479:7[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:479:25[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:479:17[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:479:10[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:478:8[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:478:4[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:447:21[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:447:13[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:447:11[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:445:26[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:445:18[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:445:11[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:441:17[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:441:10[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:497:6[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:497:13[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:497:19[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:497:33[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:497:26[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:497:20[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:496:11[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:496:7[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:488:36[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:488:18[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:488:32[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:488:25[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:488:19[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:440:8[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:440:6[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:439:4[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:439:6[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:439:7[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:435:23[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:435:42[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] htmlCurrentChar, /data/vulnloc/libxml2/REDTEAM-
                             CVE-2016-1833/src/HTMLparser.c:435:35[0m
[K[1;36m
	Localizing Constraints
	__________________________________________________________________________________________
[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:435:2
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] (@var(pointer, ctxt->input->cur) < (@var(pointer,
                        crepair_base(ctxt->input->cur)) + @var(integer,
                        crepair_size(crepair_base(ctxt->input->cur)))))[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:439:2
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] (@var(pointer, cur) < (@var(pointer, crepair_base(cur)) + @var(integer,
                        crepair_size(cur))))[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:482:6
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] (@var(pointer, cur) < (@var(pointer, crepair_base(cur)) + @var(integer,
                        crepair_size(cur))))[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:488:13
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] (@var(pointer, cur) < (@var(pointer, crepair_base(cur)) + @var(integer,
                        crepair_size(cur))))[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:486:6
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] (@var(pointer, cur) < (@var(pointer, crepair_base(cur)) + @var(integer,
                        crepair_size(cur))))[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:480:3
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] (@var(pointer, cur) < (@var(pointer, crepair_base(cur)) + @var(integer,
                        crepair_size(cur))))[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:479:3
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] (@var(pointer, cur) < (@var(pointer, crepair_base(cur)) + @var(integer,
                        crepair_size(cur))))[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:478:3
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] (@var(pointer, cur) < (@var(pointer, crepair_base(cur)) + @var(integer,
                        crepair_size(cur))))[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:447:6
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] (@var(pointer, cur) < (@var(pointer, crepair_base(cur)) + @var(integer,
                        crepair_size(cur))))[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:445:6
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] (@var(pointer, cur) < (@var(pointer, crepair_base(cur)) + @var(integer,
                        crepair_size(cur))))[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:441:6
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] (@var(pointer, cur) < (@var(pointer, crepair_base(cur)) + @var(integer,
                        crepair_size(cur))))[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:497:6
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] (@var(pointer, cur) < (@var(pointer, crepair_base(cur)) + @var(integer,
                        crepair_size(cur))))[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:496:6
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] (@var(pointer, cur) < (@var(pointer, crepair_base(cur)) + @var(integer,
                        crepair_size(cur))))[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:440:2
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] (@var(pointer, cur) < (@var(pointer, crepair_base(cur)) + @var(integer,
                        crepair_size(cur))))[0m
[K[1;32m
	localization information saved at /CrashRepair/output/libxml2_REDTEAM-CVE-2016-1833/localization.json[0m
[K[1;32m
	state values saved at /CrashRepair/output/libxml2_REDTEAM-CVE-2016-1833/values/[0m
[K	[1;37m
Run time statistics:
-----------------------
[0m
[K	[1;37mStartup: 0.000 minutes[0m
[K	[1;37mBuild: 0 minutes[0m
[K	[1;37mConcrete Analysis: 0.590 minutes[0m
[K	[1;37mConcolic Analysis: 0.406 minutes[0m
[K	[1;37mTotal Analysis: 1.201 minutes[0m
[K	[1;37mLocalization: 2.490 minutes[0m
[K[1;32m
CRepair finished successfully after 3.704 minutes 
[0m
2025-02-02 12:52:39.313 | WARNING  | analyzer:run:143 - analysis output directory does not exist [/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/analysis]: creating...
2025-02-02 12:52:39.495 | INFO     | scenario:generate:454 - generating candidate repairs in implicated files: {'/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c'}
total_candidates:[{'diff': '@@ -411,104 +411,91 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n-\treturn(0);\n+        return(0);\n \n     if (ctxt->token != 0) {\n-\t*len = 0;\n-\treturn(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        const unsigned char *cur = ctxt->input->cur;\n+\n+        if (cur >= ctxt->input->end)\n+            return -1; // Prevent reading beyond the buffer\n+\n+        unsigned char c;\n+        unsigned int val;\n+\n+        c = *cur;\n+        if (c & 0x80) {\n+            if (cur[1] == 0) {\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                 cur = ctxt->input->cur;\n             }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n+            if ((cur[1] & 0xc0) != 0x80)\n+                goto encoding_error;\n+            if ((c & 0xe0) == 0xe0) {\n \n-\t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if (cur[2] == 0) {\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if ((cur[2] & 0xc0) != 0x80)\n+                    goto encoding_error;\n+                if ((c & 0xf0) == 0xf0) {\n+                    if (cur[3] == 0) {\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n-\t\t    *len = 4;\n-\t\t    val = (cur[0] & 0x7) << 18;\n-\t\t    val |= (cur[1] & 0x3f) << 12;\n-\t\t    val |= (cur[2] & 0x3f) << 6;\n-\t\t    val |= cur[3] & 0x3f;\n-\t\t} else {\n-\t\t  /* 3-byte code */\n-\t\t    *len = 3;\n-\t\t    val = (cur[0] & 0xf) << 12;\n-\t\t    val |= (cur[1] & 0x3f) << 6;\n-\t\t    val |= cur[2] & 0x3f;\n-\t\t}\n-\t    } else {\n-\t      /* 2-byte code */\n-\t\t*len = 2;\n-\t\tval = (cur[0] & 0x1f) << 6;\n-\t\tval |= cur[1] & 0x3f;\n-\t    }\n-\t    if (!IS_CHAR(val)) {\n-\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n-\t    }\n-\t    return(val);\n-\t} else {\n+                    if (((c & 0xf8) != 0xf0) ||\n+                        ((cur[3] & 0xc0) != 0x80))\n+                        goto encoding_error;\n+                    /* 4-byte code */\n+                    *len = 4;\n+                    val = (cur[0] & 0x7) << 18;\n+                    val |= (cur[1] & 0x3f) << 12;\n+                    val |= (cur[2] & 0x3f) << 6;\n+                    val |= cur[3] & 0x3f;\n+                } else {\n+                    /* 3-byte code */\n+                    *len = 3;\n+                    val = (cur[0] & 0xf) << 12;\n+                    val |= (cur[1] & 0x3f) << 6;\n+                    val |= cur[2] & 0x3f;\n+                }\n+            } else {\n+                /* 2-byte code */\n+                *len = 2;\n+                val = (cur[0] & 0x1f) << 6;\n+                val |= cur[1] & 0x3f;\n+            }\n+            if (!IS_CHAR(val)) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", val);\n+            }\n+            return(val);\n+        } else {\n             if ((*ctxt->input->cur == 0) &&\n                 (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n-\t}\n+            /* 1-byte code */\n+            *len = 1;\n+            return((int) *ctxt->input->cur);\n+        }\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n+    \n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n-\treturn((int) *ctxt->input->cur);\n+        return((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,26 +521,19 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n-\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n-\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n-\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n-\t} else {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n-\t}\n-\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-\t\t     "Input is not proper UTF-8, indicate encoding !\\n",\n-\t\t     BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n+                     ctxt->input->cur[0], ctxt->input->cur[1],\n+                     ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                     "Input is not proper UTF-8, indicate encoding !\\n",\n+                     BAD_CAST buffer, NULL);\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n@@ -561,6 +541,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 0, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:435:2'}, {'diff': '@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,21 +422,17 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n \tconst unsigned char *cur = ctxt->input->cur;\n \tunsigned char c;\n \tunsigned int val;\n \n+\t// Ensure that the pointer \'cur\' does not go beyond the input limits\n+\tif (cur >= ctxt->input->end) {\n+\t    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR, "Input pointer is out of bounds\\n", 0);\n+\t    *len = 1;\n+\t    return(\' \');\n+\t}\n+\n \tc = *cur;\n \tif (c & 0x80) {\n \t    if (cur[1] == 0) {\n@@ -497,18 +494,10 @@\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +523,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -561,6 +543,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 1, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:435:2'}, {'diff': '@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,18 +422,12 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n \tconst unsigned char *cur = ctxt->input->cur;\n+\n+\tif (cur >= ctxt->input->end) {\n+\t    return 0; // Prevent accessing past the end\n+\t}\n+\n \tunsigned char c;\n \tunsigned int val;\n \n@@ -460,21 +455,18 @@\n \t\t    if (((c & 0xf8) != 0xf0) ||\n \t\t\t((cur[3] & 0xc0) != 0x80))\n \t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n \t\t    *len = 4;\n \t\t    val = (cur[0] & 0x7) << 18;\n \t\t    val |= (cur[1] & 0x3f) << 12;\n \t\t    val |= (cur[2] & 0x3f) << 6;\n \t\t    val |= cur[3] & 0x3f;\n \t\t} else {\n-\t\t  /* 3-byte code */\n \t\t    *len = 3;\n \t\t    val = (cur[0] & 0xf) << 12;\n \t\t    val |= (cur[1] & 0x3f) << 6;\n \t\t    val |= cur[2] & 0x3f;\n \t\t}\n \t    } else {\n-\t      /* 2-byte code */\n \t\t*len = 2;\n \t\tval = (cur[0] & 0x1f) << 6;\n \t\tval |= cur[1] & 0x3f;\n@@ -485,30 +477,21 @@\n \t    }\n \t    return(val);\n \t} else {\n-            if ((*ctxt->input->cur == 0) &&\n-                (ctxt->input->cur < ctxt->input->end)) {\n+            if ((*cur == 0) &&\n+                (cur < ctxt->input->end)) {\n                     htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n \t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n \t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n+\t    return((int) *cur);\n \t}\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +517,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -561,6 +537,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 2, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:435:2'}, {'diff': '@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,18 +422,16 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n \tconst unsigned char *cur = ctxt->input->cur;\n+\tif (cur == NULL || ctxt->input->cur >= ctxt->input->end) {\n+\t    htmlParseErr(ctxt, XML_ERR_INVALID_CHAR,\n+\t\t\t "Input is not proper UTF-8, indicate encoding !\\n",\n+\t\t\t BAD_CAST "No valid UTF-8 sequence", NULL);\n+\t    ctxt->charset = XML_CHAR_ENCODING_8859_1;\n+\t    *len = 1;\n+\t    return((int) *ctxt->input->cur);\n+\t}\n+\n \tunsigned char c;\n \tunsigned int val;\n \n@@ -497,18 +496,10 @@\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +525,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -561,6 +545,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 3, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:435:2'}, {'diff': '@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,18 +422,15 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n+\tconst unsigned char *cur;\n+\n+\tif (ctxt->input->cur >= ctxt->input->end) {\n+\t    htmlParseErr(ctxt, XML_ERR_INVALID_CHAR, "Input reached end before valid character\\n", NULL);\n+\t    *len = 1;\n+\t    return -1; // Indicate an error\n+\t}\n+\tcur = ctxt->input->cur;\n+\n \tunsigned char c;\n \tunsigned int val;\n \n@@ -497,18 +495,10 @@\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +524,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -561,6 +544,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 4, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:435:2'}, {'diff': '@@ -411,104 +411,85 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n-\treturn(0);\n+        return(0);\n \n     if (ctxt->token != 0) {\n-\t*len = 0;\n-\treturn(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        const unsigned char *cur = ctxt->input->cur;\n+        unsigned char c;\n+        unsigned int val;\n+\n+        if (cur >= ctxt->input->end) {\n+            return 0;  // Prevent dereferencing past input buffer\n+        }\n+\n+        c = *cur;\n+        if (c & 0x80) {\n+            if (cur[1] == 0) {\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                 cur = ctxt->input->cur;\n             }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n-\n-\t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+            if ((cur[1] & 0xc0) != 0x80)\n+                goto encoding_error;\n+            if ((c & 0xe0) == 0xe0) {\n+                if (cur[2] == 0) {\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if ((cur[2] & 0xc0) != 0x80)\n+                    goto encoding_error;\n+                if ((c & 0xf0) == 0xf0) {\n+                    if (cur[3] == 0) {\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n-\t\t    *len = 4;\n-\t\t    val = (cur[0] & 0x7) << 18;\n-\t\t    val |= (cur[1] & 0x3f) << 12;\n-\t\t    val |= (cur[2] & 0x3f) << 6;\n-\t\t    val |= cur[3] & 0x3f;\n-\t\t} else {\n-\t\t  /* 3-byte code */\n-\t\t    *len = 3;\n-\t\t    val = (cur[0] & 0xf) << 12;\n-\t\t    val |= (cur[1] & 0x3f) << 6;\n-\t\t    val |= cur[2] & 0x3f;\n-\t\t}\n-\t    } else {\n-\t      /* 2-byte code */\n-\t\t*len = 2;\n-\t\tval = (cur[0] & 0x1f) << 6;\n-\t\tval |= cur[1] & 0x3f;\n-\t    }\n-\t    if (!IS_CHAR(val)) {\n-\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n-\t    }\n-\t    return(val);\n-\t} else {\n+                    if (((c & 0xf8) != 0xf0) ||\n+                        ((cur[3] & 0xc0) != 0x80))\n+                        goto encoding_error;\n+                    *len = 4;\n+                    val = (cur[0] & 0x7) << 18;\n+                    val |= (cur[1] & 0x3f) << 12;\n+                    val |= (cur[2] & 0x3f) << 6;\n+                    val |= cur[3] & 0x3f;\n+                } else {\n+                    *len = 3;\n+                    val = (cur[0] & 0xf) << 12;\n+                    val |= (cur[1] & 0x3f) << 6;\n+                    val |= cur[2] & 0x3f;\n+                }\n+            } else {\n+                *len = 2;\n+                val = (cur[0] & 0x1f) << 6;\n+                val |= cur[1] & 0x3f;\n+            }\n+            if (!IS_CHAR(val)) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", val);\n+            }\n+            return(val);\n+        } else {\n             if ((*ctxt->input->cur == 0) &&\n                 (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n-\t}\n+            *len = 1;\n+            return((int) *ctxt->input->cur);\n+        }\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n-\treturn((int) *ctxt->input->cur);\n+        return((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,26 +515,18 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n-\n-\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n-\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n-\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n-\t} else {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n-\t}\n-\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-\t\t     "Input is not proper UTF-8, indicate encoding !\\n",\n-\t\t     BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n+                     ctxt->input->cur[0], ctxt->input->cur[1],\n+                     ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                     "Input is not proper UTF-8, indicate encoding !\\n",\n+                     BAD_CAST buffer, NULL);\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n@@ -561,6 +534,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 5, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:439:2'}, {'diff': '@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,21 +422,13 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n \tconst unsigned char *cur = ctxt->input->cur;\n \tunsigned char c;\n \tunsigned int val;\n \n+\tif (cur >= ctxt->input->end) {\n+\t    return 0; // Prevent accessing out of bounds\n+\t}\n \tc = *cur;\n \tif (c & 0x80) {\n \t    if (cur[1] == 0) {\n@@ -485,7 +478,7 @@\n \t    }\n \t    return(val);\n \t} else {\n-            if ((*ctxt->input->cur == 0) &&\n+            if ((cur >= ctxt->input->end) &&\n                 (ctxt->input->cur < ctxt->input->end)) {\n                     htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n \t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n@@ -497,18 +490,10 @@\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +519,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -561,6 +539,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 6, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:439:2'}, {'diff': '@@ -411,104 +411,90 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n-\treturn(0);\n+        return(0);\n \n     if (ctxt->token != 0) {\n-\t*len = 0;\n-\treturn(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        const unsigned char *cur = ctxt->input->cur;\n+        unsigned char c;\n+        unsigned int val;\n+\n+        if (cur >= ctxt->input->end) {\n+            // Handle the case when we reach the end of the input\n+            return 0; // Or appropriate error handling\n+        }\n+\n+        c = *cur;\n+        if (c & 0x80) {\n+            if (cur[1] == 0) {\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                 cur = ctxt->input->cur;\n             }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n-\n-\t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+            if ((cur[1] & 0xc0) != 0x80)\n+                goto encoding_error;\n+            if ((c & 0xe0) == 0xe0) {\n+                if (cur[2] == 0) {\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if ((cur[2] & 0xc0) != 0x80)\n+                    goto encoding_error;\n+                if ((c & 0xf0) == 0xf0) {\n+                    if (cur[3] == 0) {\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n-\t\t    *len = 4;\n-\t\t    val = (cur[0] & 0x7) << 18;\n-\t\t    val |= (cur[1] & 0x3f) << 12;\n-\t\t    val |= (cur[2] & 0x3f) << 6;\n-\t\t    val |= cur[3] & 0x3f;\n-\t\t} else {\n-\t\t  /* 3-byte code */\n-\t\t    *len = 3;\n-\t\t    val = (cur[0] & 0xf) << 12;\n-\t\t    val |= (cur[1] & 0x3f) << 6;\n-\t\t    val |= cur[2] & 0x3f;\n-\t\t}\n-\t    } else {\n-\t      /* 2-byte code */\n-\t\t*len = 2;\n-\t\tval = (cur[0] & 0x1f) << 6;\n-\t\tval |= cur[1] & 0x3f;\n-\t    }\n-\t    if (!IS_CHAR(val)) {\n-\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n-\t    }\n-\t    return(val);\n-\t} else {\n+                    if (((c & 0xf8) != 0xf0) ||\n+                        ((cur[3] & 0xc0) != 0x80))\n+                        goto encoding_error;\n+                    /* 4-byte code */\n+                    *len = 4;\n+                    val = (cur[0] & 0x7) << 18;\n+                    val |= (cur[1] & 0x3f) << 12;\n+                    val |= (cur[2] & 0x3f) << 6;\n+                    val |= cur[3] & 0x3f;\n+                } else {\n+                    /* 3-byte code */\n+                    *len = 3;\n+                    val = (cur[0] & 0xf) << 12;\n+                    val |= (cur[1] & 0x3f) << 6;\n+                    val |= cur[2] & 0x3f;\n+                }\n+            } else {\n+                /* 2-byte code */\n+                *len = 2;\n+                val = (cur[0] & 0x1f) << 6;\n+                val |= cur[1] & 0x3f;\n+            }\n+            if (!IS_CHAR(val)) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", val);\n+            }\n+            return(val);\n+        } else {\n             if ((*ctxt->input->cur == 0) &&\n                 (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n-\t}\n+            /* 1-byte code */\n+            *len = 1;\n+            return((int) *ctxt->input->cur);\n+        }\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n-\treturn((int) *ctxt->input->cur);\n+        return((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,26 +520,19 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n-\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n-\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n-\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n-\t} else {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n-\t}\n-\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-\t\t     "Input is not proper UTF-8, indicate encoding !\\n",\n-\t\t     BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n+                     ctxt->input->cur[0], ctxt->input->cur[1],\n+                     ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                     "Input is not proper UTF-8, indicate encoding !\\n",\n+                     BAD_CAST buffer, NULL);\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n@@ -561,6 +540,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 7, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:439:2'}, {'diff': '@@ -411,104 +411,89 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n-\treturn(0);\n+        return(0);\n \n     if (ctxt->token != 0) {\n-\t*len = 0;\n-\treturn(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        const unsigned char *cur = ctxt->input->cur;\n+\n+        if (cur >= ctxt->input->end) {\n+            htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                            "Attempt to read past input end\\n", 0);\n+            *len = 1;\n+            return(\' \');\n+        }\n+\n+        unsigned char c;\n+        unsigned int val;\n+\n+        c = *cur;\n+        if (c & 0x80) {\n+            if (cur[1] == 0) {\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                 cur = ctxt->input->cur;\n             }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n-\n-\t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+            if ((cur[1] & 0xc0) != 0x80)\n+                goto encoding_error;\n+            if ((c & 0xe0) == 0xe0) {\n+                if (cur[2] == 0) {\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if ((cur[2] & 0xc0) != 0x80)\n+                    goto encoding_error;\n+                if ((c & 0xf0) == 0xf0) {\n+                    if (cur[3] == 0) {\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n-\t\t    *len = 4;\n-\t\t    val = (cur[0] & 0x7) << 18;\n-\t\t    val |= (cur[1] & 0x3f) << 12;\n-\t\t    val |= (cur[2] & 0x3f) << 6;\n-\t\t    val |= cur[3] & 0x3f;\n-\t\t} else {\n-\t\t  /* 3-byte code */\n-\t\t    *len = 3;\n-\t\t    val = (cur[0] & 0xf) << 12;\n-\t\t    val |= (cur[1] & 0x3f) << 6;\n-\t\t    val |= cur[2] & 0x3f;\n-\t\t}\n-\t    } else {\n-\t      /* 2-byte code */\n-\t\t*len = 2;\n-\t\tval = (cur[0] & 0x1f) << 6;\n-\t\tval |= cur[1] & 0x3f;\n-\t    }\n-\t    if (!IS_CHAR(val)) {\n-\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n-\t    }\n-\t    return(val);\n-\t} else {\n+                    if (((c & 0xf8) != 0xf0) ||\n+                        ((cur[3] & 0xc0) != 0x80))\n+                        goto encoding_error;\n+                    *len = 4;\n+                    val = (cur[0] & 0x7) << 18;\n+                    val |= (cur[1] & 0x3f) << 12;\n+                    val |= (cur[2] & 0x3f) << 6;\n+                    val |= cur[3] & 0x3f;\n+                } else {\n+                    *len = 3;\n+                    val = (cur[0] & 0xf) << 12;\n+                    val |= (cur[1] & 0x3f) << 6;\n+                    val |= cur[2] & 0x3f;\n+                }\n+            } else {\n+                *len = 2;\n+                val = (cur[0] & 0x1f) << 6;\n+                val |= cur[1] & 0x3f;\n+            }\n+            if (!IS_CHAR(val)) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", val);\n+            }\n+            return(val);\n+        } else {\n             if ((*ctxt->input->cur == 0) &&\n                 (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n-\t}\n+            *len = 1;\n+            return((int) *ctxt->input->cur);\n+        }\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n-\treturn((int) *ctxt->input->cur);\n+        return((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,26 +519,19 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n-\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n-\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n-\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n-\t} else {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n-\t}\n-\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-\t\t     "Input is not proper UTF-8, indicate encoding !\\n",\n-\t\t     BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n+                     ctxt->input->cur[0], ctxt->input->cur[1],\n+                     ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                     "Input is not proper UTF-8, indicate encoding !\\n",\n+                     BAD_CAST buffer, NULL);\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n@@ -561,6 +539,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 8, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:439:2'}, {'diff': "@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,18 +422,14 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it's valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n \tconst unsigned char *cur = ctxt->input->cur;\n+\n+\tif (cur >= ctxt->input->end) {\n+\t    // Prevent out-of-bounds access\n+\t    *len = 0;\n+\t    return 0;\n+\t}\n+\n \tunsigned char c;\n \tunsigned int val;\n \n@@ -460,21 +457,18 @@\n \t\t    if (((c & 0xf8) != 0xf0) ||\n \t\t\t((cur[3] & 0xc0) != 0x80))\n \t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n \t\t    *len = 4;\n \t\t    val = (cur[0] & 0x7) << 18;\n \t\t    val |= (cur[1] & 0x3f) << 12;\n \t\t    val |= (cur[2] & 0x3f) << 6;\n \t\t    val |= cur[3] & 0x3f;\n \t\t} else {\n-\t\t  /* 3-byte code */\n \t\t    *len = 3;\n \t\t    val = (cur[0] & 0xf) << 12;\n \t\t    val |= (cur[1] & 0x3f) << 6;\n \t\t    val |= cur[2] & 0x3f;\n \t\t}\n \t    } else {\n-\t      /* 2-byte code */\n \t\t*len = 2;\n \t\tval = (cur[0] & 0x1f) << 6;\n \t\tval |= cur[1] & 0x3f;\n@@ -492,23 +486,14 @@\n                 *len = 1;\n                 return(' ');\n             }\n-\t    /* 1-byte code */\n \t    *len = 1;\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it's a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +519,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn't get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don't like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -561,6 +539,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n", 'id': 9, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:439:2'}, {'diff': '@@ -411,104 +411,90 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n-\treturn(0);\n+        return(0);\n \n     if (ctxt->token != 0) {\n-\t*len = 0;\n-\treturn(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        const unsigned char *cur = ctxt->input->cur;\n+        unsigned char c;\n+        unsigned int val;\n+\n+        c = *cur;\n+        if (c & 0x80) {\n+            if (cur[1] == 0) {\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                 cur = ctxt->input->cur;\n             }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n+            if ((cur[1] & 0xc0) != 0x80)\n+                goto encoding_error;\n+            if ((c & 0xe0) == 0xe0) {\n \n-\t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if (cur[2] == 0) {\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if ((cur[2] & 0xc0) != 0x80)\n+                    goto encoding_error;\n+                if ((c & 0xf0) == 0xf0) {\n+                    if (cur[3] == 0) {\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n-\t\t    *len = 4;\n-\t\t    val = (cur[0] & 0x7) << 18;\n-\t\t    val |= (cur[1] & 0x3f) << 12;\n-\t\t    val |= (cur[2] & 0x3f) << 6;\n-\t\t    val |= cur[3] & 0x3f;\n-\t\t} else {\n-\t\t  /* 3-byte code */\n-\t\t    *len = 3;\n-\t\t    val = (cur[0] & 0xf) << 12;\n-\t\t    val |= (cur[1] & 0x3f) << 6;\n-\t\t    val |= cur[2] & 0x3f;\n-\t\t}\n-\t    } else {\n-\t      /* 2-byte code */\n-\t\t*len = 2;\n-\t\tval = (cur[0] & 0x1f) << 6;\n-\t\tval |= cur[1] & 0x3f;\n-\t    }\n-\t    if (!IS_CHAR(val)) {\n-\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n-\t    }\n-\t    return(val);\n-\t} else {\n+                    if (((c & 0xf8) != 0xf0) ||\n+                        ((cur[3] & 0xc0) != 0x80))\n+                        goto encoding_error;\n+                    *len = 4;\n+                    val = (cur[0] & 0x7) << 18;\n+                    val |= (cur[1] & 0x3f) << 12;\n+                    val |= (cur[2] & 0x3f) << 6;\n+                    val |= cur[3] & 0x3f;\n+                } else {\n+                    *len = 3;\n+                    val = (cur[0] & 0xf) << 12;\n+                    val |= (cur[1] & 0x3f) << 6;\n+                    val |= cur[2] & 0x3f;\n+                }\n+            } else {\n+                *len = 2;\n+                val = (cur[0] & 0x1f) << 6;\n+                val |= cur[1] & 0x3f;\n+            }\n+            if (val < 0xD800 || val > 0xDFFF) { // 修补位置，增加范围检查\n+                if (!IS_CHAR(val)) {\n+                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                    "Char 0x%X out of allowed range\\n", val);\n+                }\n+            } else {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X is a surrogate character\\n", val); // 注意处理代理字符\n+                ctxt->charset = XML_CHAR_ENCODING_8859_1;\n+                *len = 1;\n+                return((int) *ctxt->input->cur);\n+            }\n+            return(val);\n+        } else {\n             if ((*ctxt->input->cur == 0) &&\n                 (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n-\t}\n+            *len = 1;\n+            return((int) *ctxt->input->cur);\n+        }\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n-\treturn((int) *ctxt->input->cur);\n+        return((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,26 +520,19 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n-\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n-\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n-\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n-\t} else {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n-\t}\n-\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-\t\t     "Input is not proper UTF-8, indicate encoding !\\n",\n-\t\t     BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n+                     ctxt->input->cur[0], ctxt->input->cur[1],\n+                     ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                     "Input is not proper UTF-8, indicate encoding !\\n",\n+                     BAD_CAST buffer, NULL);\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n@@ -561,6 +540,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 10, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:482:6'}, {'diff': '@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,17 +422,6 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n \tconst unsigned char *cur = ctxt->input->cur;\n \tunsigned char c;\n \tunsigned int val;\n@@ -445,7 +435,6 @@\n \t    if ((cur[1] & 0xc0) != 0x80)\n \t\tgoto encoding_error;\n \t    if ((c & 0xe0) == 0xe0) {\n-\n \t\tif (cur[2] == 0) {\n \t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n@@ -460,25 +449,26 @@\n \t\t    if (((c & 0xf8) != 0xf0) ||\n \t\t\t((cur[3] & 0xc0) != 0x80))\n \t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n \t\t    *len = 4;\n \t\t    val = (cur[0] & 0x7) << 18;\n \t\t    val |= (cur[1] & 0x3f) << 12;\n \t\t    val |= (cur[2] & 0x3f) << 6;\n \t\t    val |= cur[3] & 0x3f;\n \t\t} else {\n-\t\t  /* 3-byte code */\n \t\t    *len = 3;\n \t\t    val = (cur[0] & 0xf) << 12;\n \t\t    val |= (cur[1] & 0x3f) << 6;\n \t\t    val |= cur[2] & 0x3f;\n \t\t}\n \t    } else {\n-\t      /* 2-byte code */\n \t\t*len = 2;\n \t\tval = (cur[0] & 0x1f) << 6;\n \t\tval |= cur[1] & 0x3f;\n \t    }\n+\t    if (val >= 0xD800 && val <= 0xDFFF) { // Check for surrogate pair\n+\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n+\t    }\n \t    if (!IS_CHAR(val)) {\n \t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n \t\t\t\t"Char 0x%X out of allowed range\\n", val);\n@@ -492,23 +482,14 @@\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n \t    *len = 1;\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +515,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -561,6 +535,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 11, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:482:6'}, {'diff': '@@ -411,104 +411,82 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n-\treturn(0);\n+        return(0);\n \n     if (ctxt->token != 0) {\n-\t*len = 0;\n-\treturn(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        const unsigned char *cur = ctxt->input->cur;\n+        unsigned char c;\n+        unsigned int val;\n+\n+        c = *cur;\n+        if (c & 0x80) {\n+            if (cur[1] == 0) {\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                 cur = ctxt->input->cur;\n             }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n+            if ((cur[1] & 0xc0) != 0x80)\n+                goto encoding_error;\n+            if ((c & 0xe0) == 0xe0) {\n \n-\t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if (cur[2] == 0) {\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if ((cur[2] & 0xc0) != 0x80)\n+                    goto encoding_error;\n+                if ((c & 0xf0) == 0xf0) {\n+                    if (cur[3] == 0) {\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n-\t\t    *len = 4;\n-\t\t    val = (cur[0] & 0x7) << 18;\n-\t\t    val |= (cur[1] & 0x3f) << 12;\n-\t\t    val |= (cur[2] & 0x3f) << 6;\n-\t\t    val |= cur[3] & 0x3f;\n-\t\t} else {\n-\t\t  /* 3-byte code */\n-\t\t    *len = 3;\n-\t\t    val = (cur[0] & 0xf) << 12;\n-\t\t    val |= (cur[1] & 0x3f) << 6;\n-\t\t    val |= cur[2] & 0x3f;\n-\t\t}\n-\t    } else {\n-\t      /* 2-byte code */\n-\t\t*len = 2;\n-\t\tval = (cur[0] & 0x1f) << 6;\n-\t\tval |= cur[1] & 0x3f;\n-\t    }\n-\t    if (!IS_CHAR(val)) {\n-\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n-\t    }\n-\t    return(val);\n-\t} else {\n+                    if (((c & 0xf8) != 0xf0) ||\n+                        ((cur[3] & 0xc0) != 0x80))\n+                        goto encoding_error;\n+                    *len = 4;\n+                    val = (cur[0] & 0x7) << 18;\n+                    val |= (cur[1] & 0x3f) << 12;\n+                    val |= (cur[2] & 0x3f) << 6;\n+                    val |= cur[3] & 0x3f;\n+                } else {\n+                    *len = 3;\n+                    val = (cur[0] & 0xf) << 12;\n+                    val |= (cur[1] & 0x3f) << 6;\n+                    val |= cur[2] & 0x3f;\n+                }\n+            } else {\n+                *len = 2;\n+                val = (cur[0] & 0x1f) << 6;\n+                val |= cur[1] & 0x3f;\n+            }\n+            if (val > 0x10FFFF || !IS_CHAR(val)) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", val);\n+            }\n+            return(val);\n+        } else {\n             if ((*ctxt->input->cur == 0) &&\n                 (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n-\t}\n+            *len = 1;\n+            return((int) *ctxt->input->cur);\n+        }\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n-\treturn((int) *ctxt->input->cur);\n+        return((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,26 +512,19 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n-\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n-\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n-\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n-\t} else {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n-\t}\n-\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-\t\t     "Input is not proper UTF-8, indicate encoding !\\n",\n-\t\t     BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n+                     ctxt->input->cur[0], ctxt->input->cur[1],\n+                     ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                     "Input is not proper UTF-8, indicate encoding !\\n",\n+                     BAD_CAST buffer, NULL);\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n@@ -561,6 +532,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 12, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:482:6'}, {'diff': '@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,17 +422,6 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n \tconst unsigned char *cur = ctxt->input->cur;\n \tunsigned char c;\n \tunsigned int val;\n@@ -460,26 +450,23 @@\n \t\t    if (((c & 0xf8) != 0xf0) ||\n \t\t\t((cur[3] & 0xc0) != 0x80))\n \t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n \t\t    *len = 4;\n \t\t    val = (cur[0] & 0x7) << 18;\n \t\t    val |= (cur[1] & 0x3f) << 12;\n \t\t    val |= (cur[2] & 0x3f) << 6;\n \t\t    val |= cur[3] & 0x3f;\n \t\t} else {\n-\t\t  /* 3-byte code */\n \t\t    *len = 3;\n \t\t    val = (cur[0] & 0xf) << 12;\n \t\t    val |= (cur[1] & 0x3f) << 6;\n \t\t    val |= cur[2] & 0x3f;\n \t\t}\n \t    } else {\n-\t      /* 2-byte code */\n \t\t*len = 2;\n \t\tval = (cur[0] & 0x1f) << 6;\n \t\tval |= cur[1] & 0x3f;\n \t    }\n-\t    if (!IS_CHAR(val)) {\n+\t    if (val > 0x10FFFF || !IS_CHAR(val)) {\n \t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n \t\t\t\t"Char 0x%X out of allowed range\\n", val);\n \t    }\n@@ -492,23 +479,14 @@\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n \t    *len = 1;\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +512,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -561,6 +532,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 13, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:482:6'}, {'diff': '@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,17 +422,6 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n \tconst unsigned char *cur = ctxt->input->cur;\n \tunsigned char c;\n \tunsigned int val;\n@@ -460,26 +450,23 @@\n \t\t    if (((c & 0xf8) != 0xf0) ||\n \t\t\t((cur[3] & 0xc0) != 0x80))\n \t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n \t\t    *len = 4;\n \t\t    val = (cur[0] & 0x7) << 18;\n \t\t    val |= (cur[1] & 0x3f) << 12;\n \t\t    val |= (cur[2] & 0x3f) << 6;\n \t\t    val |= cur[3] & 0x3f;\n \t\t} else {\n-\t\t  /* 3-byte code */\n \t\t    *len = 3;\n \t\t    val = (cur[0] & 0xf) << 12;\n \t\t    val |= (cur[1] & 0x3f) << 6;\n \t\t    val |= cur[2] & 0x3f;\n \t\t}\n \t    } else {\n-\t      /* 2-byte code */\n \t\t*len = 2;\n \t\tval = (cur[0] & 0x1f) << 6;\n \t\tval |= cur[1] & 0x3f;\n \t    }\n-\t    if (!IS_CHAR(val)) {\n+\t    if (val > 0x10FFFF || (val >= 0xD800 && val <= 0xDFFF)) {\n \t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n \t\t\t\t"Char 0x%X out of allowed range\\n", val);\n \t    }\n@@ -492,23 +479,14 @@\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n \t    *len = 1;\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +512,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -561,6 +532,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 14, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:482:6'}, {'diff': '@@ -411,106 +411,85 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n-\treturn(0);\n+        return(0);\n \n     if (ctxt->token != 0) {\n-\t*len = 0;\n-\treturn(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        const unsigned char *cur = ctxt->input->cur;\n+        unsigned char c;\n+        unsigned int val;\n+\n+        c = *cur;\n+        if (c & 0x80) {\n+            if (cur[1] == 0) {\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                 cur = ctxt->input->cur;\n             }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n-\n-\t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+            if ((cur[1] & 0xc0) != 0x80)\n+                goto encoding_error;\n+            if ((c & 0xe0) == 0xe0) {\n+                if (cur[2] == 0) {\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if ((cur[2] & 0xc0) != 0x80)\n+                    goto encoding_error;\n+                if ((c & 0xf0) == 0xf0) {\n+                    if (cur[3] == 0) {\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n-\t\t    *len = 4;\n-\t\t    val = (cur[0] & 0x7) << 18;\n-\t\t    val |= (cur[1] & 0x3f) << 12;\n-\t\t    val |= (cur[2] & 0x3f) << 6;\n-\t\t    val |= cur[3] & 0x3f;\n-\t\t} else {\n-\t\t  /* 3-byte code */\n-\t\t    *len = 3;\n-\t\t    val = (cur[0] & 0xf) << 12;\n-\t\t    val |= (cur[1] & 0x3f) << 6;\n-\t\t    val |= cur[2] & 0x3f;\n-\t\t}\n-\t    } else {\n-\t      /* 2-byte code */\n-\t\t*len = 2;\n-\t\tval = (cur[0] & 0x1f) << 6;\n-\t\tval |= cur[1] & 0x3f;\n-\t    }\n-\t    if (!IS_CHAR(val)) {\n-\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n-\t    }\n-\t    return(val);\n-\t} else {\n-            if ((*ctxt->input->cur == 0) &&\n-                (ctxt->input->cur < ctxt->input->end)) {\n+                    if (((c & 0xf8) != 0xf0) ||\n+                        ((cur[3] & 0xc0) != 0x80))\n+                        goto encoding_error;\n+                    *len = 4;\n+                    val = (cur[0] & 0x7) << 18;\n+                    val |= (cur[1] & 0x3f) << 12;\n+                    val |= (cur[2] & 0x3f) << 6;\n+                    val |= cur[3] & 0x3f;\n+                } else {\n+                    *len = 3;\n+                    val = (cur[0] & 0xf) << 12;\n+                    val |= (cur[1] & 0x3f) << 6;\n+                    val |= cur[2] & 0x3f;\n+                }\n+            } else {\n+                *len = 2;\n+                val = (cur[0] & 0x1f) << 6;\n+                val |= cur[1] & 0x3f;\n+            }\n+            if (!IS_CHAR(val)) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", val);\n+            }\n+            return(val);\n+        } else {\n+            if (ctxt->input->cur >= ctxt->input->end) {\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if (ctxt->input->cur >= ctxt->input->end) {\n                     htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n-                *len = 1;\n-                return(\' \');\n+                                    "Char 0x%X out of allowed range\\n", 0);\n+                    *len = 1;\n+                    return(\' \');\n+                }\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n-\t}\n+            *len = 1;\n+            return((int) *ctxt->input->cur);\n+        }\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n-\treturn((int) *ctxt->input->cur);\n+        return((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n-        xmlChar * guess;\n+        xmlChar *guess;\n         xmlCharEncodingHandlerPtr handler;\n \n         guess = htmlFindEncoding(ctxt);\n@@ -534,26 +513,19 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n-\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n-\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n-\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n-\t} else {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n-\t}\n-\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-\t\t     "Input is not proper UTF-8, indicate encoding !\\n",\n-\t\t     BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n+                     ctxt->input->cur[0], ctxt->input->cur[1],\n+                     ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                     "Input is not proper UTF-8, indicate encoding !\\n",\n+                     BAD_CAST buffer, NULL);\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n@@ -561,6 +533,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 15, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:488:13'}, {'diff': '@@ -411,104 +411,81 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n-\treturn(0);\n+        return(0);\n \n     if (ctxt->token != 0) {\n-\t*len = 0;\n-\treturn(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        const unsigned char *cur = ctxt->input->cur;\n+        unsigned char c;\n+        unsigned int val;\n+\n+        c = *cur;\n+        if (c & 0x80) {\n+            if (cur[1] == 0) {\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                 cur = ctxt->input->cur;\n             }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n+            if ((cur[1] & 0xc0) != 0x80)\n+                goto encoding_error;\n+            if ((c & 0xe0) == 0xe0) {\n \n-\t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if (cur[2] == 0) {\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if ((cur[2] & 0xc0) != 0x80)\n+                    goto encoding_error;\n+                if ((c & 0xf0) == 0xf0) {\n+                    if (cur[3] == 0) {\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n-\t\t    *len = 4;\n-\t\t    val = (cur[0] & 0x7) << 18;\n-\t\t    val |= (cur[1] & 0x3f) << 12;\n-\t\t    val |= (cur[2] & 0x3f) << 6;\n-\t\t    val |= cur[3] & 0x3f;\n-\t\t} else {\n-\t\t  /* 3-byte code */\n-\t\t    *len = 3;\n-\t\t    val = (cur[0] & 0xf) << 12;\n-\t\t    val |= (cur[1] & 0x3f) << 6;\n-\t\t    val |= cur[2] & 0x3f;\n-\t\t}\n-\t    } else {\n-\t      /* 2-byte code */\n-\t\t*len = 2;\n-\t\tval = (cur[0] & 0x1f) << 6;\n-\t\tval |= cur[1] & 0x3f;\n-\t    }\n-\t    if (!IS_CHAR(val)) {\n-\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n-\t    }\n-\t    return(val);\n-\t} else {\n-            if ((*ctxt->input->cur == 0) &&\n-                (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+                    if (((c & 0xf8) != 0xf0) ||\n+                        ((cur[3] & 0xc0) != 0x80))\n+                        goto encoding_error;\n+                    *len = 4;\n+                    val = (cur[0] & 0x7) << 18;\n+                    val |= (cur[1] & 0x3f) << 12;\n+                    val |= (cur[2] & 0x3f) << 6;\n+                    val |= cur[3] & 0x3f;\n+                } else {\n+                    *len = 3;\n+                    val = (cur[0] & 0xf) << 12;\n+                    val |= (cur[1] & 0x3f) << 6;\n+                    val |= cur[2] & 0x3f;\n+                }\n+            } else {\n+                *len = 2;\n+                val = (cur[0] & 0x1f) << 6;\n+                val |= cur[1] & 0x3f;\n+            }\n+            if (!IS_CHAR(val)) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", val);\n+            }\n+            return(val);\n+        } else {\n+            if (cur >= ctxt->input->end || (*cur == 0)) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n-\t}\n+            *len = 1;\n+            return((int) *ctxt->input->cur);\n+        }\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n-\treturn((int) *ctxt->input->cur);\n+        return((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,26 +511,19 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n-\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n-\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n-\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n-\t} else {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n-\t}\n-\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-\t\t     "Input is not proper UTF-8, indicate encoding !\\n",\n-\t\t     BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n+                     ctxt->input->cur[0], ctxt->input->cur[1],\n+                     ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                     "Input is not proper UTF-8, indicate encoding !\\n",\n+                     BAD_CAST buffer, NULL);\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n@@ -561,6 +531,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 16, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:488:13'}, {'diff': '@@ -411,104 +411,80 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n-\treturn(0);\n+        return(0);\n \n     if (ctxt->token != 0) {\n-\t*len = 0;\n-\treturn(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        const unsigned char *cur = ctxt->input->cur;\n+        unsigned char c;\n+        unsigned int val;\n+\n+        c = *cur;\n+        if (c & 0x80) {\n+            if (cur[1] == 0) {\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                 cur = ctxt->input->cur;\n             }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n-\n-\t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+            if ((cur[1] & 0xc0) != 0x80)\n+                goto encoding_error;\n+            if ((c & 0xe0) == 0xe0) {\n+                if (cur[2] == 0) {\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if ((cur[2] & 0xc0) != 0x80)\n+                    goto encoding_error;\n+                if ((c & 0xf0) == 0xf0) {\n+                    if (cur[3] == 0) {\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n-\t\t    *len = 4;\n-\t\t    val = (cur[0] & 0x7) << 18;\n-\t\t    val |= (cur[1] & 0x3f) << 12;\n-\t\t    val |= (cur[2] & 0x3f) << 6;\n-\t\t    val |= cur[3] & 0x3f;\n-\t\t} else {\n-\t\t  /* 3-byte code */\n-\t\t    *len = 3;\n-\t\t    val = (cur[0] & 0xf) << 12;\n-\t\t    val |= (cur[1] & 0x3f) << 6;\n-\t\t    val |= cur[2] & 0x3f;\n-\t\t}\n-\t    } else {\n-\t      /* 2-byte code */\n-\t\t*len = 2;\n-\t\tval = (cur[0] & 0x1f) << 6;\n-\t\tval |= cur[1] & 0x3f;\n-\t    }\n-\t    if (!IS_CHAR(val)) {\n-\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n-\t    }\n-\t    return(val);\n-\t} else {\n-            if ((*ctxt->input->cur == 0) &&\n-                (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+                    if (((c & 0xf8) != 0xf0) ||\n+                        ((cur[3] & 0xc0) != 0x80))\n+                        goto encoding_error;\n+                    *len = 4;\n+                    val = (cur[0] & 0x7) << 18;\n+                    val |= (cur[1] & 0x3f) << 12;\n+                    val |= (cur[2] & 0x3f) << 6;\n+                    val |= cur[3] & 0x3f;\n+                } else {\n+                    *len = 3;\n+                    val = (cur[0] & 0xf) << 12;\n+                    val |= (cur[1] & 0x3f) << 6;\n+                    val |= cur[2] & 0x3f;\n+                }\n+            } else {\n+                *len = 2;\n+                val = (cur[0] & 0x1f) << 6;\n+                val |= cur[1] & 0x3f;\n+            }\n+            if (!IS_CHAR(val)) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                    "Char 0x%X out of allowed range\\n", val);\n+            }\n+            return(val);\n+        } else {\n+            if (ctxt->input->cur >= ctxt->input->end) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                    "Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n-\t}\n+            *len = 1;\n+            return((int) *ctxt->input->cur);\n+        }\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n-\treturn((int) *ctxt->input->cur);\n+        return((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -525,7 +501,7 @@\n                 xmlSwitchToEncoding(ctxt, handler);\n             } else {\n                 htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-                             "Unsupported encoding %s", guess, NULL);\n+                            "Unsupported encoding %s", guess, NULL);\n             }\n         }\n         ctxt->charset = XML_CHAR_ENCODING_UTF8;\n@@ -534,26 +510,19 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n-\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n-\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n-\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n-\t} else {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n-\t}\n-\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-\t\t     "Input is not proper UTF-8, indicate encoding !\\n",\n-\t\t     BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n+                        ctxt->input->cur[0], ctxt->input->cur[1],\n+                        ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                     "Input is not proper UTF-8, indicate encoding !\\n",\n+                     BAD_CAST buffer, NULL);\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n@@ -561,6 +530,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 17, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:488:13'}, {'diff': '@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,17 +422,6 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n \tconst unsigned char *cur = ctxt->input->cur;\n \tunsigned char c;\n \tunsigned int val;\n@@ -445,7 +435,6 @@\n \t    if ((cur[1] & 0xc0) != 0x80)\n \t\tgoto encoding_error;\n \t    if ((c & 0xe0) == 0xe0) {\n-\n \t\tif (cur[2] == 0) {\n \t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n@@ -460,21 +449,18 @@\n \t\t    if (((c & 0xf8) != 0xf0) ||\n \t\t\t((cur[3] & 0xc0) != 0x80))\n \t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n \t\t    *len = 4;\n \t\t    val = (cur[0] & 0x7) << 18;\n \t\t    val |= (cur[1] & 0x3f) << 12;\n \t\t    val |= (cur[2] & 0x3f) << 6;\n \t\t    val |= cur[3] & 0x3f;\n \t\t} else {\n-\t\t  /* 3-byte code */\n \t\t    *len = 3;\n \t\t    val = (cur[0] & 0xf) << 12;\n \t\t    val |= (cur[1] & 0x3f) << 6;\n \t\t    val |= cur[2] & 0x3f;\n \t\t}\n \t    } else {\n-\t      /* 2-byte code */\n \t\t*len = 2;\n \t\tval = (cur[0] & 0x1f) << 6;\n \t\tval |= cur[1] & 0x3f;\n@@ -485,30 +471,20 @@\n \t    }\n \t    return(val);\n \t} else {\n-            if ((*ctxt->input->cur == 0) &&\n-                (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+            if (cur >= ctxt->input->end) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n \t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n \t    *len = 1;\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +510,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -561,6 +530,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 18, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:488:13'}, {'diff': '@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,17 +422,6 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n \tconst unsigned char *cur = ctxt->input->cur;\n \tunsigned char c;\n \tunsigned int val;\n@@ -460,21 +450,18 @@\n \t\t    if (((c & 0xf8) != 0xf0) ||\n \t\t\t((cur[3] & 0xc0) != 0x80))\n \t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n \t\t    *len = 4;\n \t\t    val = (cur[0] & 0x7) << 18;\n \t\t    val |= (cur[1] & 0x3f) << 12;\n \t\t    val |= (cur[2] & 0x3f) << 6;\n \t\t    val |= cur[3] & 0x3f;\n \t\t} else {\n-\t\t  /* 3-byte code */\n \t\t    *len = 3;\n \t\t    val = (cur[0] & 0xf) << 12;\n \t\t    val |= (cur[1] & 0x3f) << 6;\n \t\t    val |= cur[2] & 0x3f;\n \t\t}\n \t    } else {\n-\t      /* 2-byte code */\n \t\t*len = 2;\n \t\tval = (cur[0] & 0x1f) << 6;\n \t\tval |= cur[1] & 0x3f;\n@@ -485,30 +472,18 @@\n \t    }\n \t    return(val);\n \t} else {\n-            if ((*ctxt->input->cur == 0) &&\n-                (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n-                *len = 1;\n-                return(\' \');\n+            if (ctxt->input->cur == ctxt->input->end) {\n+                *len = 0;\n+                return 0; // Avoid dereferencing a null pointer.\n             }\n-\t    /* 1-byte code */\n \t    *len = 1;\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +509,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -561,6 +529,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 19, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:488:13'}, {'diff': '@@ -411,104 +411,81 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n-\treturn(0);\n+        return(0);\n \n     if (ctxt->token != 0) {\n-\t*len = 0;\n-\treturn(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        const unsigned char *cur = ctxt->input->cur;\n+        unsigned char c;\n+        unsigned int val;\n+\n+        c = *cur;\n+        if (c & 0x80) {\n+            if (cur[1] == 0) {\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                 cur = ctxt->input->cur;\n             }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n-\n-\t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+            if ((cur[1] & 0xc0) != 0x80)\n+                goto encoding_error;\n+            if ((c & 0xe0) == 0xe0) {\n+                if (cur[2] == 0) {\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if ((cur[2] & 0xc0) != 0x80)\n+                    goto encoding_error;\n+                if ((c & 0xf0) == 0xf0) {\n+                    if (cur[3] == 0) {\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n-\t\t    *len = 4;\n-\t\t    val = (cur[0] & 0x7) << 18;\n-\t\t    val |= (cur[1] & 0x3f) << 12;\n-\t\t    val |= (cur[2] & 0x3f) << 6;\n-\t\t    val |= cur[3] & 0x3f;\n-\t\t} else {\n-\t\t  /* 3-byte code */\n-\t\t    *len = 3;\n-\t\t    val = (cur[0] & 0xf) << 12;\n-\t\t    val |= (cur[1] & 0x3f) << 6;\n-\t\t    val |= cur[2] & 0x3f;\n-\t\t}\n-\t    } else {\n-\t      /* 2-byte code */\n-\t\t*len = 2;\n-\t\tval = (cur[0] & 0x1f) << 6;\n-\t\tval |= cur[1] & 0x3f;\n-\t    }\n-\t    if (!IS_CHAR(val)) {\n-\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n-\t    }\n-\t    return(val);\n-\t} else {\n+                    if (((c & 0xf8) != 0xf0) ||\n+                        ((cur[3] & 0xc0) != 0x80))\n+                        goto encoding_error;\n+                    *len = 4;\n+                    val = (cur[0] & 0x7) << 18;\n+                    val |= (cur[1] & 0x3f) << 12;\n+                    val |= (cur[2] & 0x3f) << 6;\n+                    val |= cur[3] & 0x3f;\n+                } else {\n+                    *len = 3;\n+                    val = (cur[0] & 0xf) << 12;\n+                    val |= (cur[1] & 0x3f) << 6;\n+                    val |= cur[2] & 0x3f;\n+                }\n+            } else {\n+                *len = 2;\n+                val = (cur[0] & 0x1f) << 6;\n+                val |= cur[1] & 0x3f;\n+            }\n+            if (!IS_CHAR(val)) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", val);\n+            }\n+            return(val);\n+        } else {\n             if ((*ctxt->input->cur == 0) &&\n                 (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n-\t}\n+            *len = 1;\n+            return((int) *ctxt->input->cur);\n+        }\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n-\treturn((int) *ctxt->input->cur);\n+        return((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,26 +511,19 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n-\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n-\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n-\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n-\t} else {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n-\t}\n-\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-\t\t     "Input is not proper UTF-8, indicate encoding !\\n",\n-\t\t     BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n+                     ctxt->input->cur[0], ctxt->input->cur[1],\n+                     ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                     "Input is not proper UTF-8, indicate encoding !\\n",\n+                     BAD_CAST buffer, NULL);\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n@@ -561,6 +531,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 20, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:486:6'}, {'diff': '@@ -411,104 +411,84 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n-\treturn(0);\n+        return(0);\n \n     if (ctxt->token != 0) {\n-\t*len = 0;\n-\treturn(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        const unsigned char *cur = ctxt->input->cur;\n+        unsigned char c;\n+        unsigned int val;\n+\n+        c = *cur;\n+        if (c & 0x80) {\n+            if (cur[1] == 0) {\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                 cur = ctxt->input->cur;\n             }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n-\n-\t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+            if ((cur[1] & 0xc0) != 0x80)\n+                goto encoding_error;\n+            if ((c & 0xe0) == 0xe0) {\n+                if (cur[2] == 0) {\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if ((cur[2] & 0xc0) != 0x80)\n+                    goto encoding_error;\n+                if ((c & 0xf0) == 0xf0) {\n+                    if (cur[3] == 0) {\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n-\t\t    *len = 4;\n-\t\t    val = (cur[0] & 0x7) << 18;\n-\t\t    val |= (cur[1] & 0x3f) << 12;\n-\t\t    val |= (cur[2] & 0x3f) << 6;\n-\t\t    val |= cur[3] & 0x3f;\n-\t\t} else {\n-\t\t  /* 3-byte code */\n-\t\t    *len = 3;\n-\t\t    val = (cur[0] & 0xf) << 12;\n-\t\t    val |= (cur[1] & 0x3f) << 6;\n-\t\t    val |= cur[2] & 0x3f;\n-\t\t}\n-\t    } else {\n-\t      /* 2-byte code */\n-\t\t*len = 2;\n-\t\tval = (cur[0] & 0x1f) << 6;\n-\t\tval |= cur[1] & 0x3f;\n-\t    }\n-\t    if (!IS_CHAR(val)) {\n-\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n-\t    }\n-\t    return(val);\n-\t} else {\n+                    if (((c & 0xf8) != 0xf0) ||\n+                        ((cur[3] & 0xc0) != 0x80))\n+                        goto encoding_error;\n+                    *len = 4;\n+                    val = (cur[0] & 0x7) << 18;\n+                    val |= (cur[1] & 0x3f) << 12;\n+                    val |= (cur[2] & 0x3f) << 6;\n+                    val |= cur[3] & 0x3f;\n+                } else {\n+                    *len = 3;\n+                    val = (cur[0] & 0xf) << 12;\n+                    val |= (cur[1] & 0x3f) << 6;\n+                    val |= cur[2] & 0x3f;\n+                }\n+            } else {\n+                *len = 2;\n+                val = (cur[0] & 0x1f) << 6;\n+                val |= cur[1] & 0x3f;\n+            }\n+            if (!IS_CHAR(val)) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", val);\n+                // Return some error value to indicate the issue\n+                return -1;\n+            }\n+            return(val);\n+        } else {\n             if ((*ctxt->input->cur == 0) &&\n                 (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n-\t}\n+            *len = 1;\n+            return((int) *ctxt->input->cur);\n+        }\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n+  \n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n-\treturn((int) *ctxt->input->cur);\n+        return((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,26 +514,19 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n-\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n-\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n-\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n-\t} else {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n-\t}\n-\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-\t\t     "Input is not proper UTF-8, indicate encoding !\\n",\n-\t\t     BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n+                     ctxt->input->cur[0], ctxt->input->cur[1],\n+                     ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                     "Input is not proper UTF-8, indicate encoding !\\n",\n+                     BAD_CAST buffer, NULL);\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n@@ -561,6 +534,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 21, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:486:6'}, {'diff': '@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,17 +422,6 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n \tconst unsigned char *cur = ctxt->input->cur;\n \tunsigned char c;\n \tunsigned int val;\n@@ -445,7 +435,6 @@\n \t    if ((cur[1] & 0xc0) != 0x80)\n \t\tgoto encoding_error;\n \t    if ((c & 0xe0) == 0xe0) {\n-\n \t\tif (cur[2] == 0) {\n \t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n@@ -460,21 +449,18 @@\n \t\t    if (((c & 0xf8) != 0xf0) ||\n \t\t\t((cur[3] & 0xc0) != 0x80))\n \t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n \t\t    *len = 4;\n \t\t    val = (cur[0] & 0x7) << 18;\n \t\t    val |= (cur[1] & 0x3f) << 12;\n \t\t    val |= (cur[2] & 0x3f) << 6;\n \t\t    val |= cur[3] & 0x3f;\n \t\t} else {\n-\t\t  /* 3-byte code */\n \t\t    *len = 3;\n \t\t    val = (cur[0] & 0xf) << 12;\n \t\t    val |= (cur[1] & 0x3f) << 6;\n \t\t    val |= cur[2] & 0x3f;\n \t\t}\n \t    } else {\n-\t      /* 2-byte code */\n \t\t*len = 2;\n \t\tval = (cur[0] & 0x1f) << 6;\n \t\tval |= cur[1] & 0x3f;\n@@ -483,7 +469,7 @@\n \t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n \t\t\t\t"Char 0x%X out of allowed range\\n", val);\n \t    }\n-\t    return(val);\n+\t    return(val < 0x110000 ? val : XML_ERR_INVALID_CHAR);\n \t} else {\n             if ((*ctxt->input->cur == 0) &&\n                 (ctxt->input->cur < ctxt->input->end)) {\n@@ -492,23 +478,14 @@\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n \t    *len = 1;\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +511,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -561,6 +531,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 22, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:486:6'}, {'diff': '@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,17 +422,6 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n \tconst unsigned char *cur = ctxt->input->cur;\n \tunsigned char c;\n \tunsigned int val;\n@@ -460,21 +450,18 @@\n \t\t    if (((c & 0xf8) != 0xf0) ||\n \t\t\t((cur[3] & 0xc0) != 0x80))\n \t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n \t\t    *len = 4;\n \t\t    val = (cur[0] & 0x7) << 18;\n \t\t    val |= (cur[1] & 0x3f) << 12;\n \t\t    val |= (cur[2] & 0x3f) << 6;\n \t\t    val |= cur[3] & 0x3f;\n \t\t} else {\n-\t\t  /* 3-byte code */\n \t\t    *len = 3;\n \t\t    val = (cur[0] & 0xf) << 12;\n \t\t    val |= (cur[1] & 0x3f) << 6;\n \t\t    val |= cur[2] & 0x3f;\n \t\t}\n \t    } else {\n-\t      /* 2-byte code */\n \t\t*len = 2;\n \t\tval = (cur[0] & 0x1f) << 6;\n \t\tval |= cur[1] & 0x3f;\n@@ -483,7 +470,7 @@\n \t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n \t\t\t\t"Char 0x%X out of allowed range\\n", val);\n \t    }\n-\t    return(val);\n+\t    return(val < 0 ? 0 : val); // Added check for negative value\n \t} else {\n             if ((*ctxt->input->cur == 0) &&\n                 (ctxt->input->cur < ctxt->input->end)) {\n@@ -492,23 +479,14 @@\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n \t    *len = 1;\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +512,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -561,6 +532,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 23, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:486:6'}, {'diff': "@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,17 +422,6 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it's valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n \tconst unsigned char *cur = ctxt->input->cur;\n \tunsigned char c;\n \tunsigned int val;\n@@ -445,7 +435,6 @@\n \t    if ((cur[1] & 0xc0) != 0x80)\n \t\tgoto encoding_error;\n \t    if ((c & 0xe0) == 0xe0) {\n-\n \t\tif (cur[2] == 0) {\n \t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n@@ -460,21 +449,18 @@\n \t\t    if (((c & 0xf8) != 0xf0) ||\n \t\t\t((cur[3] & 0xc0) != 0x80))\n \t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n \t\t    *len = 4;\n \t\t    val = (cur[0] & 0x7) << 18;\n \t\t    val |= (cur[1] & 0x3f) << 12;\n \t\t    val |= (cur[2] & 0x3f) << 6;\n \t\t    val |= cur[3] & 0x3f;\n \t\t} else {\n-\t\t  /* 3-byte code */\n \t\t    *len = 3;\n \t\t    val = (cur[0] & 0xf) << 12;\n \t\t    val |= (cur[1] & 0x3f) << 6;\n \t\t    val |= cur[2] & 0x3f;\n \t\t}\n \t    } else {\n-\t      /* 2-byte code */\n \t\t*len = 2;\n \t\tval = (cur[0] & 0x1f) << 6;\n \t\tval |= cur[1] & 0x3f;\n@@ -492,23 +478,14 @@\n                 *len = 1;\n                 return(' ');\n             }\n-\t    /* 1-byte code */\n \t    *len = 1;\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it's a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +511,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn't get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don't like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -561,6 +531,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n", 'id': 24, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:486:6'}, {'diff': '@@ -411,104 +411,85 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n-\treturn(0);\n+        return(0);\n \n     if (ctxt->token != 0) {\n-\t*len = 0;\n-\treturn(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        const unsigned char *cur = ctxt->input->cur;\n+        unsigned char c;\n+        unsigned int val;\n+\n+        c = *cur;\n+        if (c & 0x80) {\n+            if (cur[1] == 0) {\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                 cur = ctxt->input->cur;\n             }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n-\n-\t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+            if ((cur[1] & 0xc0) != 0x80)\n+                goto encoding_error;\n+            if ((c & 0xe0) == 0xe0) {\n+                if (cur[2] == 0) {\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if ((cur[2] & 0xc0) != 0x80)\n+                    goto encoding_error;\n+                if ((c & 0xf0) == 0xf0) {\n+                    if (cur[3] == 0) {\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n-\t\t    *len = 4;\n-\t\t    val = (cur[0] & 0x7) << 18;\n-\t\t    val |= (cur[1] & 0x3f) << 12;\n-\t\t    val |= (cur[2] & 0x3f) << 6;\n-\t\t    val |= cur[3] & 0x3f;\n-\t\t} else {\n-\t\t  /* 3-byte code */\n-\t\t    *len = 3;\n-\t\t    val = (cur[0] & 0xf) << 12;\n-\t\t    val |= (cur[1] & 0x3f) << 6;\n-\t\t    val |= cur[2] & 0x3f;\n-\t\t}\n-\t    } else {\n-\t      /* 2-byte code */\n-\t\t*len = 2;\n-\t\tval = (cur[0] & 0x1f) << 6;\n-\t\tval |= cur[1] & 0x3f;\n-\t    }\n-\t    if (!IS_CHAR(val)) {\n-\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n-\t    }\n-\t    return(val);\n-\t} else {\n+                    if (((c & 0xf8) != 0xf0) ||\n+                        ((cur[3] & 0xc0) != 0x80))\n+                        goto encoding_error;\n+                    /* 4-byte code */\n+                    *len = 4;\n+                    val = (cur[0] & 0x7) << 18;\n+                    val |= (cur[1] & 0x3f) << 12;\n+                    val |= (cur[2] & 0x3f) << 6;\n+                    val |= (cur[3] & 0x3f);\n+                } else {\n+                    /* 3-byte code */\n+                    *len = 3;\n+                    val = (cur[0] & 0xf) << 12;\n+                    val |= (cur[1] & 0x3f) << 6;\n+                    val |= cur[2] & 0x3f;\n+                }\n+            } else {\n+                /* 2-byte code */\n+                *len = 2;\n+                val = (cur[0] & 0x1f) << 6;\n+                val |= cur[1] & 0x3f;\n+            }\n+            if (!IS_CHAR(val)) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", val);\n+            }\n+            return(val);\n+        } else {\n             if ((*ctxt->input->cur == 0) &&\n                 (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n-\t}\n+            /* 1-byte code */\n+            *len = 1;\n+            return((int) *ctxt->input->cur);\n+        }\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n-\treturn((int) *ctxt->input->cur);\n+        return((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,26 +515,19 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n-\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n-\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n-\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n-\t} else {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n-\t}\n-\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-\t\t     "Input is not proper UTF-8, indicate encoding !\\n",\n-\t\t     BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n+                        ctxt->input->cur[0], ctxt->input->cur[1],\n+                        ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                     "Input is not proper UTF-8, indicate encoding !\\n",\n+                     BAD_CAST buffer, NULL);\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n@@ -561,6 +535,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 25, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:480:3'}, {'diff': '@@ -411,104 +411,85 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n-\treturn(0);\n+        return(0);\n \n     if (ctxt->token != 0) {\n-\t*len = 0;\n-\treturn(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        const unsigned char *cur = ctxt->input->cur;\n+        unsigned char c;\n+        unsigned int val;\n+\n+        c = *cur;\n+        if (c & 0x80) {\n+            if (cur[1] == 0) {\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                 cur = ctxt->input->cur;\n             }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n-\n-\t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+            if ((cur[1] & 0xc0) != 0x80)\n+                goto encoding_error;\n+            if ((c & 0xe0) == 0xe0) {\n+                if (cur[2] == 0) {\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if ((cur[2] & 0xc0) != 0x80)\n+                    goto encoding_error;\n+                if ((c & 0xf0) == 0xf0) {\n+                    if (cur[3] == 0) {\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n-\t\t    *len = 4;\n-\t\t    val = (cur[0] & 0x7) << 18;\n-\t\t    val |= (cur[1] & 0x3f) << 12;\n-\t\t    val |= (cur[2] & 0x3f) << 6;\n-\t\t    val |= cur[3] & 0x3f;\n-\t\t} else {\n-\t\t  /* 3-byte code */\n-\t\t    *len = 3;\n-\t\t    val = (cur[0] & 0xf) << 12;\n-\t\t    val |= (cur[1] & 0x3f) << 6;\n-\t\t    val |= cur[2] & 0x3f;\n-\t\t}\n-\t    } else {\n-\t      /* 2-byte code */\n-\t\t*len = 2;\n-\t\tval = (cur[0] & 0x1f) << 6;\n-\t\tval |= cur[1] & 0x3f;\n-\t    }\n-\t    if (!IS_CHAR(val)) {\n-\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n-\t    }\n-\t    return(val);\n-\t} else {\n+                    if (((c & 0xf8) != 0xf0) ||\n+                        ((cur[3] & 0xc0) != 0x80))\n+                        goto encoding_error;\n+                    /* 4-byte code */\n+                    *len = 4;\n+                    val = (cur[0] & 0x7) << 18;\n+                    val |= (cur[1] & 0x3f) << 12;\n+                    val |= (cur[2] & 0x3f) << 6;\n+                    val |= cur[3] & 0x3f;\n+                } else {\n+                    /* 3-byte code */\n+                    *len = 3;\n+                    val = (cur[0] & 0xf) << 12;\n+                    val |= (cur[1] & 0x3f) << 6;\n+                    val |= cur[2] & 0x3f;\n+                }\n+            } else {\n+                /* 2-byte code */\n+                *len = 2;\n+                val = (cur[0] & 0x1f) << 6;\n+                val |= cur[1] & 0x3f;\n+            }\n+            if (!IS_CHAR(val)) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", val);\n+            }\n+            return(val);\n+        } else {\n             if ((*ctxt->input->cur == 0) &&\n                 (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n-\t}\n+            /* 1-byte code */\n+            *len = 1;\n+            return((int) *ctxt->input->cur);\n+        }\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n-\treturn((int) *ctxt->input->cur);\n+        return((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,26 +515,19 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n-\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n-\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n-\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n-\t} else {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n-\t}\n-\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-\t\t     "Input is not proper UTF-8, indicate encoding !\\n",\n-\t\t     BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n+                     ctxt->input->cur[0], ctxt->input->cur[1],\n+                     ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                     "Input is not proper UTF-8, indicate encoding !\\n",\n+                     BAD_CAST buffer, NULL);\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n@@ -561,6 +535,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 26, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:480:3'}, {'diff': '@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,17 +422,6 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n \tconst unsigned char *cur = ctxt->input->cur;\n \tunsigned char c;\n \tunsigned int val;\n@@ -479,7 +469,7 @@\n \t\tval = (cur[0] & 0x1f) << 6;\n \t\tval |= cur[1] & 0x3f;\n \t    }\n-\t    if (!IS_CHAR(val)) {\n+\t    if (!IS_CHAR(val) || (val >= 0x110000)) {\n \t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n \t\t\t\t"Char 0x%X out of allowed range\\n", val);\n \t    }\n@@ -497,18 +487,10 @@\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +516,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -561,6 +536,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 27, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:480:3'}, {'diff': '@@ -411,104 +411,85 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n-\treturn(0);\n+        return(0);\n \n     if (ctxt->token != 0) {\n-\t*len = 0;\n-\treturn(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        const unsigned char *cur = ctxt->input->cur;\n+        unsigned char c;\n+        unsigned int val;\n+\n+        c = *cur;\n+        if (c & 0x80) {\n+            if (cur[1] == 0) {\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                 cur = ctxt->input->cur;\n             }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n-\n-\t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+            if ((cur[1] & 0xc0) != 0x80)\n+                goto encoding_error;\n+            if ((c & 0xe0) == 0xe0) {\n+                if (cur[2] == 0) {\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if ((cur[2] & 0xc0) != 0x80)\n+                    goto encoding_error;\n+                if ((c & 0xf0) == 0xf0) {\n+                    if (cur[3] == 0) {\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n-\t\t    *len = 4;\n-\t\t    val = (cur[0] & 0x7) << 18;\n-\t\t    val |= (cur[1] & 0x3f) << 12;\n-\t\t    val |= (cur[2] & 0x3f) << 6;\n-\t\t    val |= cur[3] & 0x3f;\n-\t\t} else {\n-\t\t  /* 3-byte code */\n-\t\t    *len = 3;\n-\t\t    val = (cur[0] & 0xf) << 12;\n-\t\t    val |= (cur[1] & 0x3f) << 6;\n-\t\t    val |= cur[2] & 0x3f;\n-\t\t}\n-\t    } else {\n-\t      /* 2-byte code */\n-\t\t*len = 2;\n-\t\tval = (cur[0] & 0x1f) << 6;\n-\t\tval |= cur[1] & 0x3f;\n-\t    }\n-\t    if (!IS_CHAR(val)) {\n-\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n-\t    }\n-\t    return(val);\n-\t} else {\n+                    if (((c & 0xf8) != 0xf0) ||\n+                        ((cur[3] & 0xc0) != 0x80))\n+                        goto encoding_error;\n+                    /* 4-byte code */\n+                    *len = 4;\n+                    val = (cur[0] & 0x7) << 18;\n+                    val |= (cur[1] & 0x3f) << 12;\n+                    val |= (cur[2] & 0x3f) << 6;\n+                    val |= cur[3] & 0x3f;\n+                } else {\n+                    /* 3-byte code */\n+                    *len = 3;\n+                    val = (cur[0] & 0xf) << 12;\n+                    val |= (cur[1] & 0x3f) << 6;\n+                    val |= cur[2] & 0x3f;\n+                }\n+            } else {\n+                /* 2-byte code */\n+                *len = 2;\n+                val = (cur[0] & 0x1f) << 6;\n+                val |= cur[1] & 0x3f;\n+            }\n+            if (!IS_CHAR(val)) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", val);\n+            }\n+            return(val);\n+        } else {\n             if ((*ctxt->input->cur == 0) &&\n                 (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n-\t}\n+            /* 1-byte code */\n+            *len = 1;\n+            return((int) *ctxt->input->cur);\n+        }\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n-\treturn((int) *ctxt->input->cur);\n+        return((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,26 +515,19 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n-\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n-\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n-\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n-\t} else {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n-\t}\n-\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-\t\t     "Input is not proper UTF-8, indicate encoding !\\n",\n-\t\t     BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n+                     ctxt->input->cur[0], ctxt->input->cur[1],\n+                     ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                     "Input is not proper UTF-8, indicate encoding !\\n",\n+                     BAD_CAST buffer, NULL);\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n@@ -561,6 +535,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 28, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:480:3'}, {'diff': '@@ -411,104 +411,82 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n-\treturn(0);\n+        return(0);\n \n     if (ctxt->token != 0) {\n-\t*len = 0;\n-\treturn(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        const unsigned char *cur = ctxt->input->cur;\n+        unsigned char c;\n+        unsigned int val;\n+\n+        c = *cur;\n+        if (c & 0x80) {\n+            if (cur[1] == 0) {\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                 cur = ctxt->input->cur;\n             }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n+            if ((cur[1] & 0xc0) != 0x80)\n+                goto encoding_error;\n+            if ((c & 0xe0) == 0xe0) {\n \n-\t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if (cur[2] == 0) {\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if ((cur[2] & 0xc0) != 0x80)\n+                    goto encoding_error;\n+                if ((c & 0xf0) == 0xf0) {\n+                    if (cur[3] == 0) {\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n-\t\t    *len = 4;\n-\t\t    val = (cur[0] & 0x7) << 18;\n-\t\t    val |= (cur[1] & 0x3f) << 12;\n-\t\t    val |= (cur[2] & 0x3f) << 6;\n-\t\t    val |= cur[3] & 0x3f;\n-\t\t} else {\n-\t\t  /* 3-byte code */\n-\t\t    *len = 3;\n-\t\t    val = (cur[0] & 0xf) << 12;\n-\t\t    val |= (cur[1] & 0x3f) << 6;\n-\t\t    val |= cur[2] & 0x3f;\n-\t\t}\n-\t    } else {\n-\t      /* 2-byte code */\n-\t\t*len = 2;\n-\t\tval = (cur[0] & 0x1f) << 6;\n-\t\tval |= cur[1] & 0x3f;\n-\t    }\n-\t    if (!IS_CHAR(val)) {\n-\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n-\t    }\n-\t    return(val);\n-\t} else {\n+                    if (((c & 0xf8) != 0xf0) ||\n+                        ((cur[3] & 0xc0) != 0x80))\n+                        goto encoding_error;\n+                    *len = 4;\n+                    val = (cur[0] & 0x7) << 18;\n+                    val |= (cur[1] & 0x3f) << 12;\n+                    val |= (cur[2] & 0x3f) << 6;\n+                    val |= cur[3] & 0x3f;\n+                } else {\n+                    *len = 3;\n+                    val = (cur[0] & 0xf) << 12;\n+                    val |= (cur[1] & 0x3f) << 6;\n+                    val |= cur[2] & 0x3f;\n+                }\n+            } else {\n+                *len = 2;\n+                val = (cur[0] & 0x1f) << 6;\n+                val |= cur[1] & 0x3f;\n+            }\n+            if (!IS_CHAR(val)) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", val);\n+            }\n+            return(val);\n+        } else {\n             if ((*ctxt->input->cur == 0) &&\n                 (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n-\t}\n+            *len = 1;\n+            return((int) *ctxt->input->cur);\n+        }\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n-\treturn((int) *ctxt->input->cur);\n+        return((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,26 +512,19 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n-\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n-\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n-\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n-\t} else {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n-\t}\n-\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-\t\t     "Input is not proper UTF-8, indicate encoding !\\n",\n-\t\t     BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n+                     ctxt->input->cur[0], ctxt->input->cur[1],\n+                     ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                     "Input is not proper UTF-8, indicate encoding !\\n",\n+                     BAD_CAST buffer, NULL);\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n@@ -561,6 +532,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 29, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:480:3'}, {'diff': '@@ -411,106 +411,88 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n-\treturn(0);\n+        return(0);\n \n     if (ctxt->token != 0) {\n-\t*len = 0;\n-\treturn(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        const unsigned char *cur = ctxt->input->cur;\n+        unsigned char c;\n+        unsigned int val;\n+\n+        c = *cur;\n+        if (c & 0x80) {\n+            if (cur[1] == 0) {\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                 cur = ctxt->input->cur;\n             }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n+            if ((cur[1] & 0xc0) != 0x80)\n+                goto encoding_error;\n+            if ((c & 0xe0) == 0xe0) {\n \n-\t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if (cur[2] == 0) {\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if ((cur[2] & 0xc0) != 0x80)\n+                    goto encoding_error;\n+                if ((c & 0xf0) == 0xf0) {\n+                    if (cur[3] == 0) {\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n-\t\t    *len = 4;\n-\t\t    val = (cur[0] & 0x7) << 18;\n-\t\t    val |= (cur[1] & 0x3f) << 12;\n-\t\t    val |= (cur[2] & 0x3f) << 6;\n-\t\t    val |= cur[3] & 0x3f;\n-\t\t} else {\n-\t\t  /* 3-byte code */\n-\t\t    *len = 3;\n-\t\t    val = (cur[0] & 0xf) << 12;\n-\t\t    val |= (cur[1] & 0x3f) << 6;\n-\t\t    val |= cur[2] & 0x3f;\n-\t\t}\n-\t    } else {\n-\t      /* 2-byte code */\n-\t\t*len = 2;\n-\t\tval = (cur[0] & 0x1f) << 6;\n-\t\tval |= cur[1] & 0x3f;\n-\t    }\n-\t    if (!IS_CHAR(val)) {\n-\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n-\t    }\n-\t    return(val);\n-\t} else {\n+                    if (((c & 0xf8) != 0xf0) ||\n+                        ((cur[3] & 0xc0) != 0x80))\n+                        goto encoding_error;\n+                    /* 4-byte code */\n+                    *len = 4;\n+                    val = (cur[0] & 0x7) << 18;\n+                    val |= (cur[1] & 0x3f) << 12;\n+                    val |= (cur[2] & 0x3f) << 6;\n+                    val |= cur[3] & 0x3f;\n+                } else {\n+                    /* 3-byte code */\n+                    *len = 3;\n+                    val = (cur[0] & 0xf) << 12;\n+                    val |= (cur[1] & 0x3f) << 6;\n+                    val |= cur[2] & 0x3f;\n+                }\n+            } else {\n+                /* 2-byte code */\n+                *len = 2;\n+                val = (cur[0] & 0x1f) << 6;\n+                val |= cur[1] & 0x3f;\n+            }\n+            if (!IS_CHAR(val)) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", val);\n+            }\n+            return(val);\n+        } else {\n             if ((*ctxt->input->cur == 0) &&\n                 (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n-\t}\n+            /* 1-byte code */\n+            *len = 1;\n+            return((int) *ctxt->input->cur);\n+        }\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n-\treturn((int) *ctxt->input->cur);\n+        return((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n-        xmlChar * guess;\n+        xmlChar *guess;\n         xmlCharEncodingHandlerPtr handler;\n \n         guess = htmlFindEncoding(ctxt);\n@@ -534,26 +516,19 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n-\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n-\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n-\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n-\t} else {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n-\t}\n-\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-\t\t     "Input is not proper UTF-8, indicate encoding !\\n",\n-\t\t     BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n+                        ctxt->input->cur[0], ctxt->input->cur[1],\n+                        ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                     "Input is not proper UTF-8, indicate encoding !\\n",\n+                     BAD_CAST buffer, NULL);\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n@@ -561,6 +536,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 30, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:479:3'}, {'diff': "@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,17 +422,6 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it's valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n \tconst unsigned char *cur = ctxt->input->cur;\n \tunsigned char c;\n \tunsigned int val;\n@@ -497,18 +487,10 @@\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it's a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +516,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn't get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don't like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -561,6 +536,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n", 'id': 31, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:479:3'}, {'diff': "@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,17 +422,6 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it's valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n \tconst unsigned char *cur = ctxt->input->cur;\n \tunsigned char c;\n \tunsigned int val;\n@@ -497,18 +487,10 @@\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it's a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +516,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn't get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don't like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -561,6 +536,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n", 'id': 32, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:479:3'}, {'diff': "@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,17 +422,6 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it's valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n \tconst unsigned char *cur = ctxt->input->cur;\n \tunsigned char c;\n \tunsigned int val;\n@@ -497,18 +487,10 @@\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it's a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +516,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn't get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don't like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -561,6 +536,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n", 'id': 33, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:479:3'}, {'diff': '@@ -411,104 +411,81 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n-\treturn(0);\n+        return(0);\n \n     if (ctxt->token != 0) {\n-\t*len = 0;\n-\treturn(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        const unsigned char *cur = ctxt->input->cur;\n+        unsigned char c;\n+        unsigned int val;\n+\n+        c = *cur;\n+        if (c & 0x80) {\n+            if (cur[1] == 0) {\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                 cur = ctxt->input->cur;\n             }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n-\n-\t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+            if ((cur[1] & 0xc0) != 0x80)\n+                goto encoding_error;\n+            if ((c & 0xe0) == 0xe0) {\n+                if (cur[2] == 0) {\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if ((cur[2] & 0xc0) != 0x80)\n+                    goto encoding_error;\n+                if ((c & 0xf0) == 0xf0) {\n+                    if (cur[3] == 0) {\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n-\t\t    *len = 4;\n-\t\t    val = (cur[0] & 0x7) << 18;\n-\t\t    val |= (cur[1] & 0x3f) << 12;\n-\t\t    val |= (cur[2] & 0x3f) << 6;\n-\t\t    val |= cur[3] & 0x3f;\n-\t\t} else {\n-\t\t  /* 3-byte code */\n-\t\t    *len = 3;\n-\t\t    val = (cur[0] & 0xf) << 12;\n-\t\t    val |= (cur[1] & 0x3f) << 6;\n-\t\t    val |= cur[2] & 0x3f;\n-\t\t}\n-\t    } else {\n-\t      /* 2-byte code */\n-\t\t*len = 2;\n-\t\tval = (cur[0] & 0x1f) << 6;\n-\t\tval |= cur[1] & 0x3f;\n-\t    }\n-\t    if (!IS_CHAR(val)) {\n-\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n-\t    }\n-\t    return(val);\n-\t} else {\n+                    if (((c & 0xf8) != 0xf0) ||\n+                        ((cur[3] & 0xc0) != 0x80))\n+                        goto encoding_error;\n+                    *len = 4;\n+                    val = (cur[0] & 0x7) << 18;\n+                    val |= (cur[1] & 0x3f) << 12;\n+                    val |= (cur[2] & 0x3f) << 6;\n+                    val |= cur[3] & 0x3f;\n+                } else {\n+                    *len = 3;\n+                    val = (cur[0] & 0xf) << 12;\n+                    val |= (cur[1] & 0x3f) << 6;\n+                    val |= cur[2] & 0x3f;\n+                }\n+            } else {\n+                *len = 2;\n+                val = (cur[0] & 0x1f) << 6;\n+                val |= cur[1] & 0x3f;\n+            }\n+            if (!IS_CHAR(val)) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", val);\n+            }\n+            return(val);\n+        } else {\n             if ((*ctxt->input->cur == 0) &&\n                 (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n-\t}\n+            *len = 1;\n+            return((int) *ctxt->input->cur);\n+        }\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n-\treturn((int) *ctxt->input->cur);\n+        return((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,26 +511,19 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n-\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n-\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n-\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n-\t} else {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n-\t}\n-\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-\t\t     "Input is not proper UTF-8, indicate encoding !\\n",\n-\t\t     BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n+                     ctxt->input->cur[0], ctxt->input->cur[1],\n+                     ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                     "Input is not proper UTF-8, indicate encoding !\\n",\n+                     BAD_CAST buffer, NULL);\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n@@ -561,6 +531,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 34, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:479:3'}, {'diff': '@@ -411,104 +411,82 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n-\treturn(0);\n+        return(0);\n \n     if (ctxt->token != 0) {\n-\t*len = 0;\n-\treturn(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        const unsigned char *cur = ctxt->input->cur;\n+        unsigned char c;\n+        unsigned int val;\n+\n+        c = *cur;\n+        if (c & 0x80) {\n+            if (cur[1] == 0) {\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                 cur = ctxt->input->cur;\n             }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n+            if ((cur[1] & 0xc0) != 0x80)\n+                goto encoding_error;\n+            if ((c & 0xe0) == 0xe0) {\n \n-\t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if (cur[2] == 0) {\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if ((cur[2] & 0xc0) != 0x80)\n+                    goto encoding_error;\n+                if ((c & 0xf0) == 0xf0) {\n+                    if (cur[3] == 0) {\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n-\t\t    *len = 4;\n-\t\t    val = (cur[0] & 0x7) << 18;\n-\t\t    val |= (cur[1] & 0x3f) << 12;\n-\t\t    val |= (cur[2] & 0x3f) << 6;\n-\t\t    val |= cur[3] & 0x3f;\n-\t\t} else {\n-\t\t  /* 3-byte code */\n-\t\t    *len = 3;\n-\t\t    val = (cur[0] & 0xf) << 12;\n-\t\t    val |= (cur[1] & 0x3f) << 6;\n-\t\t    val |= cur[2] & 0x3f;\n-\t\t}\n-\t    } else {\n-\t      /* 2-byte code */\n-\t\t*len = 2;\n-\t\tval = (cur[0] & 0x1f) << 6;\n-\t\tval |= cur[1] & 0x3f;\n-\t    }\n-\t    if (!IS_CHAR(val)) {\n-\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n-\t    }\n-\t    return(val);\n-\t} else {\n+                    if (((c & 0xf8) != 0xf0) ||\n+                        ((cur[3] & 0xc0) != 0x80))\n+                        goto encoding_error;\n+                    *len = 4;\n+                    val = (cur[0] & 0x7) << 18;\n+                    val |= (cur[1] & 0x3f) << 12;\n+                    val |= (cur[2] & 0x3f) << 6;\n+                    val |= cur[3] & 0x3f;\n+                } else {\n+                    *len = 3;\n+                    val = (cur[0] & 0xf) << 12;\n+                    val |= (cur[1] & 0x3f) << 6;\n+                    val |= cur[2] & 0x3f;\n+                }\n+            } else {\n+                *len = 2;\n+                val = (cur[0] & 0x1f) << 6;\n+                val |= cur[1] & 0x3f;\n+            }\n+            if (!IS_CHAR(val)) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", val);\n+            }\n+            return(val);\n+        } else {\n             if ((*ctxt->input->cur == 0) &&\n                 (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n-\t}\n+            *len = 1;\n+            return((int) *ctxt->input->cur);\n+        }\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n-\treturn((int) *ctxt->input->cur);\n+        return((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,26 +512,19 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n-\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n-\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n-\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n-\t} else {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n-\t}\n-\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-\t\t     "Input is not proper UTF-8, indicate encoding !\\n",\n-\t\t     BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n+                     ctxt->input->cur[0], ctxt->input->cur[1],\n+                     ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                     "Input is not proper UTF-8, indicate encoding !\\n",\n+                     BAD_CAST buffer, NULL);\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n@@ -561,6 +532,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 35, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:478:3'}, {'diff': '@@ -411,104 +411,86 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n-\treturn(0);\n+        return(0);\n \n     if (ctxt->token != 0) {\n-\t*len = 0;\n-\treturn(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        const unsigned char *cur = ctxt->input->cur;\n+        unsigned char c;\n+        unsigned int val;\n+\n+        c = *cur;\n+        if (c & 0x80) {\n+            if (cur[1] == 0) {\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                 cur = ctxt->input->cur;\n             }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n+            if ((cur[1] & 0xc0) != 0x80)\n+                goto encoding_error;\n+            if ((c & 0xe0) == 0xe0) {\n \n-\t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if (cur[2] == 0) {\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if ((cur[2] & 0xc0) != 0x80)\n+                    goto encoding_error;\n+                if ((c & 0xf0) == 0xf0) {\n+                    if (cur[3] == 0) {\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n-\t\t    *len = 4;\n-\t\t    val = (cur[0] & 0x7) << 18;\n-\t\t    val |= (cur[1] & 0x3f) << 12;\n-\t\t    val |= (cur[2] & 0x3f) << 6;\n-\t\t    val |= cur[3] & 0x3f;\n-\t\t} else {\n-\t\t  /* 3-byte code */\n-\t\t    *len = 3;\n-\t\t    val = (cur[0] & 0xf) << 12;\n-\t\t    val |= (cur[1] & 0x3f) << 6;\n-\t\t    val |= cur[2] & 0x3f;\n-\t\t}\n-\t    } else {\n-\t      /* 2-byte code */\n-\t\t*len = 2;\n-\t\tval = (cur[0] & 0x1f) << 6;\n-\t\tval |= cur[1] & 0x3f;\n-\t    }\n-\t    if (!IS_CHAR(val)) {\n-\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n-\t    }\n-\t    return(val);\n-\t} else {\n+                    if (((c & 0xf8) != 0xf0) ||\n+                        ((cur[3] & 0xc0) != 0x80))\n+                        goto encoding_error;\n+                    /* 4-byte code */\n+                    *len = 4;\n+                    val = (cur[0] & 0x7) << 18;\n+                    val |= (cur[1] & 0x3f) << 12;\n+                    val |= (cur[2] & 0x3f) << 6;\n+                    val |= cur[3] & 0x3f;\n+                } else {\n+                    /* 3-byte code */\n+                    *len = 3;\n+                    val = (cur[0] & 0xf) << 12;\n+                    val |= (cur[1] & 0x3f) << 6;\n+                    val |= cur[2] & 0x3f;\n+                }\n+            } else {\n+                /* 2-byte code */\n+                *len = 2;\n+                val = (cur[0] & 0x1f) << 6;\n+                val |= cur[1] & 0x3f;\n+            }\n+            if (!IS_CHAR(val)) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                    "Char 0x%X out of allowed range\\n", val);\n+            }\n+            return(val);\n+        } else {\n             if ((*ctxt->input->cur == 0) &&\n                 (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                    "Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n-\t}\n+            /* 1-byte code */\n+            *len = 1;\n+            return((int) *ctxt->input->cur);\n+        }\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n-\treturn((int) *ctxt->input->cur);\n+        return((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,26 +516,19 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n-\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n-\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n-\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n-\t} else {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n-\t}\n-\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-\t\t     "Input is not proper UTF-8, indicate encoding !\\n",\n-\t\t     BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n+                ctxt->input->cur[0], ctxt->input->cur[1],\n+                ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+            "Input is not proper UTF-8, indicate encoding !\\n",\n+            BAD_CAST buffer, NULL);\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n@@ -561,6 +536,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 36, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:478:3'}, {'diff': "@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,17 +422,6 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it's valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n \tconst unsigned char *cur = ctxt->input->cur;\n \tunsigned char c;\n \tunsigned int val;\n@@ -467,14 +457,20 @@\n \t\t    val |= (cur[2] & 0x3f) << 6;\n \t\t    val |= cur[3] & 0x3f;\n \t\t} else {\n-\t\t  /* 3-byte code */\n+\t\t    /* 3-byte code */\n \t\t    *len = 3;\n \t\t    val = (cur[0] & 0xf) << 12;\n \t\t    val |= (cur[1] & 0x3f) << 6;\n \t\t    val |= cur[2] & 0x3f;\n \t\t}\n \t    } else {\n-\t      /* 2-byte code */\n+\t\t/* 2-byte code */\n+\t\tif (cur[1] == 0) {\n+\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                    cur = ctxt->input->cur;\n+                }\n+\t\tif ((cur[1] & 0xc0) != 0x80)\n+\t\t    goto encoding_error;\n \t\t*len = 2;\n \t\tval = (cur[0] & 0x1f) << 6;\n \t\tval |= cur[1] & 0x3f;\n@@ -497,18 +493,10 @@\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it's a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +522,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn't get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don't like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -561,6 +542,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n", 'id': 37, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:478:3'}, {'diff': "@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,17 +422,6 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it's valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n \tconst unsigned char *cur = ctxt->input->cur;\n \tunsigned char c;\n \tunsigned int val;\n@@ -475,6 +465,10 @@\n \t\t}\n \t    } else {\n \t      /* 2-byte code */\n+\t\tif (cur[1] == 0) {\n+\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                    cur = ctxt->input->cur;\n+                }\n \t\t*len = 2;\n \t\tval = (cur[0] & 0x1f) << 6;\n \t\tval |= cur[1] & 0x3f;\n@@ -497,18 +491,10 @@\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it's a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +520,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn't get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don't like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -561,6 +540,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n", 'id': 38, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:478:3'}, {'diff': "@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,17 +422,6 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it's valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n \tconst unsigned char *cur = ctxt->input->cur;\n \tunsigned char c;\n \tunsigned int val;\n@@ -467,14 +457,18 @@\n \t\t    val |= (cur[2] & 0x3f) << 6;\n \t\t    val |= cur[3] & 0x3f;\n \t\t} else {\n-\t\t  /* 3-byte code */\n+\t\t    /* 3-byte code */\n \t\t    *len = 3;\n \t\t    val = (cur[0] & 0xf) << 12;\n \t\t    val |= (cur[1] & 0x3f) << 6;\n \t\t    val |= cur[2] & 0x3f;\n \t\t}\n \t    } else {\n-\t      /* 2-byte code */\n+\t\t/* 2-byte code */\n+\t\tif (cur[1] == 0) {\n+\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                    cur = ctxt->input->cur;\n+                }\n \t\t*len = 2;\n \t\tval = (cur[0] & 0x1f) << 6;\n \t\tval |= cur[1] & 0x3f;\n@@ -497,18 +491,10 @@\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it's a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +520,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn't get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don't like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -561,6 +540,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n", 'id': 39, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:478:3'}, {'diff': '@@ -411,104 +411,81 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n-\treturn(0);\n+        return(0);\n \n     if (ctxt->token != 0) {\n-\t*len = 0;\n-\treturn(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        const unsigned char *cur = ctxt->input->cur;\n+        unsigned char c;\n+        unsigned int val;\n+\n+        c = *cur;\n+        if (c & 0x80) {\n+            if (cur[1] == 0) {\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                 cur = ctxt->input->cur;\n             }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n-\n-\t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+            if ((cur[1] & 0xc0) != 0x80)\n+                goto encoding_error;\n+            if ((c & 0xe0) == 0xe0) {\n+                if (cur[2] == 0) {\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if ((cur[2] & 0xc0) != 0x80)\n+                    goto encoding_error;\n+                if ((c & 0xf0) == 0xf0) {\n+                    if (cur[3] == 0) {\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n-\t\t    *len = 4;\n-\t\t    val = (cur[0] & 0x7) << 18;\n-\t\t    val |= (cur[1] & 0x3f) << 12;\n-\t\t    val |= (cur[2] & 0x3f) << 6;\n-\t\t    val |= cur[3] & 0x3f;\n-\t\t} else {\n-\t\t  /* 3-byte code */\n-\t\t    *len = 3;\n-\t\t    val = (cur[0] & 0xf) << 12;\n-\t\t    val |= (cur[1] & 0x3f) << 6;\n-\t\t    val |= cur[2] & 0x3f;\n-\t\t}\n-\t    } else {\n-\t      /* 2-byte code */\n-\t\t*len = 2;\n-\t\tval = (cur[0] & 0x1f) << 6;\n-\t\tval |= cur[1] & 0x3f;\n-\t    }\n-\t    if (!IS_CHAR(val)) {\n-\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n-\t    }\n-\t    return(val);\n-\t} else {\n+                    if (((c & 0xf8) != 0xf0) ||\n+                        ((cur[3] & 0xc0) != 0x80))\n+                        goto encoding_error;\n+                    *len = 4;\n+                    val = (cur[0] & 0x7) << 18;\n+                    val |= (cur[1] & 0x3f) << 12;\n+                    val |= (cur[2] & 0x3f) << 6;\n+                    val |= cur[3] & 0x3f;\n+                } else {\n+                    *len = 3;\n+                    val = (cur[0] & 0xf) << 12;\n+                    val |= (cur[1] & 0x3f) << 6;\n+                    val |= cur[2] & 0x3f;\n+                }\n+            } else {\n+                *len = 2;\n+                val = (cur[0] & 0x1f) << 6;\n+                val |= cur[1] & 0x3f;\n+            }\n+            if (!IS_CHAR(val)) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", val);\n+            }\n+            return(val);\n+        } else {\n             if ((*ctxt->input->cur == 0) &&\n                 (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n-\t}\n+            *len = 1;\n+            return((int) *ctxt->input->cur);\n+        }\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n-\treturn((int) *ctxt->input->cur);\n+        return((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,26 +511,19 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n-\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n-\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n-\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n-\t} else {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n-\t}\n-\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-\t\t     "Input is not proper UTF-8, indicate encoding !\\n",\n-\t\t     BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n+                        ctxt->input->cur[0], ctxt->input->cur[1],\n+                        ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                     "Input is not proper UTF-8, indicate encoding !\\n",\n+                     BAD_CAST buffer, NULL);\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n@@ -561,6 +531,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 40, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:447:6'}, {'diff': '@@ -411,106 +411,84 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n-\treturn(0);\n+        return(0);\n \n     if (ctxt->token != 0) {\n-\t*len = 0;\n-\treturn(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        const unsigned char *cur = ctxt->input->cur;\n+        unsigned char c;\n+        unsigned int val;\n+\n+        c = *cur;\n+        if (c & 0x80) {\n+            if (cur[1] == 0) {\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                 cur = ctxt->input->cur;\n             }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n+            if ((cur[1] & 0xc0) != 0x80)\n+                goto encoding_error;\n+            if ((c & 0xe0) == 0xe0) {\n \n-\t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if (cur[2] == 0) {\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if ((cur[2] & 0xc0) != 0x80)\n+                    goto encoding_error;\n+                if ((c & 0xf0) == 0xf0) {\n+                    if (cur[3] == 0) {\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n-\t\t    *len = 4;\n-\t\t    val = (cur[0] & 0x7) << 18;\n-\t\t    val |= (cur[1] & 0x3f) << 12;\n-\t\t    val |= (cur[2] & 0x3f) << 6;\n-\t\t    val |= cur[3] & 0x3f;\n-\t\t} else {\n-\t\t  /* 3-byte code */\n-\t\t    *len = 3;\n-\t\t    val = (cur[0] & 0xf) << 12;\n-\t\t    val |= (cur[1] & 0x3f) << 6;\n-\t\t    val |= cur[2] & 0x3f;\n-\t\t}\n-\t    } else {\n-\t      /* 2-byte code */\n-\t\t*len = 2;\n-\t\tval = (cur[0] & 0x1f) << 6;\n-\t\tval |= cur[1] & 0x3f;\n-\t    }\n-\t    if (!IS_CHAR(val)) {\n-\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n-\t    }\n-\t    return(val);\n-\t} else {\n-            if ((*ctxt->input->cur == 0) &&\n-                (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+                    if (((c & 0xf8) != 0xf0) ||\n+                        ((cur[3] & 0xc0) != 0x80))\n+                        goto encoding_error;\n+\n+                    *len = 4;\n+                    val = (cur[0] & 0x7) << 18;\n+                    val |= (cur[1] & 0x3f) << 12;\n+                    val |= (cur[2] & 0x3f) << 6;\n+                    val |= cur[3] & 0x3f;\n+                } else {\n+                    *len = 3;\n+                    val = (cur[0] & 0xf) << 12;\n+                    val |= (cur[1] & 0x3f) << 6;\n+                    val |= cur[2] & 0x3f;\n+                }\n+            } else {\n+                *len = 2;\n+                val = (cur[0] & 0x1f) << 6;\n+                val |= cur[1] & 0x3f;\n+            }\n+            if (!IS_CHAR(val)) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                    "Char 0x%X out of allowed range\\n", val);\n+            }\n+            return(val);\n+        } else {\n+            if (cur + 1 >= ctxt->input->end) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                    "Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n-\t}\n+            *len = 1;\n+            return((int) *ctxt->input->cur);\n+        }\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n-\treturn((int) *ctxt->input->cur);\n+        return((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n-        xmlChar * guess;\n+        xmlChar *guess;\n         xmlCharEncodingHandlerPtr handler;\n \n         guess = htmlFindEncoding(ctxt);\n@@ -525,7 +503,7 @@\n                 xmlSwitchToEncoding(ctxt, handler);\n             } else {\n                 htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-                             "Unsupported encoding %s", guess, NULL);\n+                    "Unsupported encoding %s", guess, NULL);\n             }\n         }\n         ctxt->charset = XML_CHAR_ENCODING_UTF8;\n@@ -534,26 +512,19 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n-\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n-\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n-\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n-\t} else {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n-\t}\n-\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-\t\t     "Input is not proper UTF-8, indicate encoding !\\n",\n-\t\t     BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n+                ctxt->input->cur[0], ctxt->input->cur[1],\n+                ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+            "Input is not proper UTF-8, indicate encoding !\\n",\n+            BAD_CAST buffer, NULL);\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n@@ -561,6 +532,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 41, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:447:6'}, {'diff': '@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,17 +422,6 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n \tconst unsigned char *cur = ctxt->input->cur;\n \tunsigned char c;\n \tunsigned int val;\n@@ -445,7 +435,6 @@\n \t    if ((cur[1] & 0xc0) != 0x80)\n \t\tgoto encoding_error;\n \t    if ((c & 0xe0) == 0xe0) {\n-\n \t\tif (cur[2] == 0) {\n \t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n@@ -460,21 +449,18 @@\n \t\t    if (((c & 0xf8) != 0xf0) ||\n \t\t\t((cur[3] & 0xc0) != 0x80))\n \t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n \t\t    *len = 4;\n \t\t    val = (cur[0] & 0x7) << 18;\n \t\t    val |= (cur[1] & 0x3f) << 12;\n \t\t    val |= (cur[2] & 0x3f) << 6;\n \t\t    val |= cur[3] & 0x3f;\n \t\t} else {\n-\t\t  /* 3-byte code */\n \t\t    *len = 3;\n \t\t    val = (cur[0] & 0xf) << 12;\n \t\t    val |= (cur[1] & 0x3f) << 6;\n \t\t    val |= cur[2] & 0x3f;\n \t\t}\n \t    } else {\n-\t      /* 2-byte code */\n \t\t*len = 2;\n \t\tval = (cur[0] & 0x1f) << 6;\n \t\tval |= cur[1] & 0x3f;\n@@ -483,7 +469,7 @@\n \t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n \t\t\t\t"Char 0x%X out of allowed range\\n", val);\n \t    }\n-\t    return(val);\n+ \t    return(val);\n \t} else {\n             if ((*ctxt->input->cur == 0) &&\n                 (ctxt->input->cur < ctxt->input->end)) {\n@@ -492,23 +478,14 @@\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n \t    *len = 1;\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +511,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -561,6 +531,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 42, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:447:6'}, {'diff': "@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,17 +422,6 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it's valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n \tconst unsigned char *cur = ctxt->input->cur;\n \tunsigned char c;\n \tunsigned int val;\n@@ -445,7 +435,6 @@\n \t    if ((cur[1] & 0xc0) != 0x80)\n \t\tgoto encoding_error;\n \t    if ((c & 0xe0) == 0xe0) {\n-\n \t\tif (cur[2] == 0) {\n \t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n@@ -460,21 +449,18 @@\n \t\t    if (((c & 0xf8) != 0xf0) ||\n \t\t\t((cur[3] & 0xc0) != 0x80))\n \t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n \t\t    *len = 4;\n \t\t    val = (cur[0] & 0x7) << 18;\n \t\t    val |= (cur[1] & 0x3f) << 12;\n \t\t    val |= (cur[2] & 0x3f) << 6;\n \t\t    val |= cur[3] & 0x3f;\n \t\t} else {\n-\t\t  /* 3-byte code */\n \t\t    *len = 3;\n \t\t    val = (cur[0] & 0xf) << 12;\n \t\t    val |= (cur[1] & 0x3f) << 6;\n \t\t    val |= cur[2] & 0x3f;\n \t\t}\n \t    } else {\n-\t      /* 2-byte code */\n \t\t*len = 2;\n \t\tval = (cur[0] & 0x1f) << 6;\n \t\tval |= cur[1] & 0x3f;\n@@ -492,23 +478,14 @@\n                 *len = 1;\n                 return(' ');\n             }\n-\t    /* 1-byte code */\n \t    *len = 1;\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it's a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +511,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn't get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don't like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -561,6 +531,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n", 'id': 43, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:447:6'}, {'diff': "@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,17 +422,6 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it's valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n \tconst unsigned char *cur = ctxt->input->cur;\n \tunsigned char c;\n \tunsigned int val;\n@@ -445,20 +435,16 @@\n \t    if ((cur[1] & 0xc0) != 0x80)\n \t\tgoto encoding_error;\n \t    if ((c & 0xe0) == 0xe0) {\n+                // Additional check for invalid UTF-8 continuation bytes\n+                if (cur[2] == 0 || (cur[2] & 0xc0) != 0x80) {\n+                    goto encoding_error;\n+                }\n \n-\t\tif (cur[2] == 0) {\n+\t\tif (cur[3] == 0) {\n \t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n-                        cur = ctxt->input->cur;\n-                    }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n+\t\tif (((c & 0xf8) != 0xf0) || ((cur[3] & 0xc0) != 0x80))\n \t\t\tgoto encoding_error;\n \t\t    /* 4-byte code */\n \t\t    *len = 4;\n@@ -497,18 +483,10 @@\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it's a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +512,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn't get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don't like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -561,6 +532,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n", 'id': 44, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:447:6'}, {'diff': '@@ -411,104 +411,80 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n-\treturn(0);\n+        return(0);\n \n     if (ctxt->token != 0) {\n-\t*len = 0;\n-\treturn(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        const unsigned char *cur = ctxt->input->cur;\n+        unsigned char c;\n+        unsigned int val;\n+\n+        c = *cur;\n+        if (c & 0x80) {\n+            if (cur[1] == 0) {\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                 cur = ctxt->input->cur;\n             }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n-\n-\t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+            if (cur[1] == 0 || (cur[1] & 0xc0) != 0x80) // Added safety check for cur[1] being 0\n+                goto encoding_error;\n+            if ((c & 0xe0) == 0xe0) {\n+                if (cur[2] == 0) {\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if (cur[2] == 0 || (cur[2] & 0xc0) != 0x80) // Added safety check for cur[2] being 0\n+                    goto encoding_error;\n+                if ((c & 0xf0) == 0xf0) {\n+                    if (cur[3] == 0) {\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n-\t\t    *len = 4;\n-\t\t    val = (cur[0] & 0x7) << 18;\n-\t\t    val |= (cur[1] & 0x3f) << 12;\n-\t\t    val |= (cur[2] & 0x3f) << 6;\n-\t\t    val |= cur[3] & 0x3f;\n-\t\t} else {\n-\t\t  /* 3-byte code */\n-\t\t    *len = 3;\n-\t\t    val = (cur[0] & 0xf) << 12;\n-\t\t    val |= (cur[1] & 0x3f) << 6;\n-\t\t    val |= cur[2] & 0x3f;\n-\t\t}\n-\t    } else {\n-\t      /* 2-byte code */\n-\t\t*len = 2;\n-\t\tval = (cur[0] & 0x1f) << 6;\n-\t\tval |= cur[1] & 0x3f;\n-\t    }\n-\t    if (!IS_CHAR(val)) {\n-\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n-\t    }\n-\t    return(val);\n-\t} else {\n+                    if (cur[3] == 0 || ((c & 0xf8) != 0xf0) || ((cur[3] & 0xc0) != 0x80)) // Added safety check for cur[3] being 0\n+                        goto encoding_error;\n+                    *len = 4;\n+                    val = (cur[0] & 0x7) << 18;\n+                    val |= (cur[1] & 0x3f) << 12;\n+                    val |= (cur[2] & 0x3f) << 6;\n+                    val |= cur[3] & 0x3f;\n+                } else {\n+                    *len = 3;\n+                    val = (cur[0] & 0xf) << 12;\n+                    val |= (cur[1] & 0x3f) << 6;\n+                    val |= cur[2] & 0x3f;\n+                }\n+            } else {\n+                *len = 2;\n+                val = (cur[0] & 0x1f) << 6;\n+                val |= cur[1] & 0x3f;\n+            }\n+            if (!IS_CHAR(val)) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", val);\n+            }\n+            return(val);\n+        } else {\n             if ((*ctxt->input->cur == 0) &&\n                 (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n-\t}\n+            *len = 1;\n+            return((int) *ctxt->input->cur);\n+        }\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n-\treturn((int) *ctxt->input->cur);\n+        return((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,26 +510,19 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n-\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n-\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n-\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n-\t} else {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n-\t}\n-\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-\t\t     "Input is not proper UTF-8, indicate encoding !\\n",\n-\t\t     BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n+                     ctxt->input->cur[0], ctxt->input->cur[1],\n+                     ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                     "Input is not proper UTF-8, indicate encoding !\\n",\n+                     BAD_CAST buffer, NULL);\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n@@ -561,6 +530,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 45, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:445:6'}, {'diff': '@@ -411,104 +411,85 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n-\treturn(0);\n+        return(0);\n \n     if (ctxt->token != 0) {\n-\t*len = 0;\n-\treturn(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        const unsigned char *cur = ctxt->input->cur;\n+        unsigned char c;\n+        unsigned int val;\n+\n+        c = *cur;\n+        if (c & 0x80) {\n+            if (cur[1] == 0) {\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                 cur = ctxt->input->cur;\n             }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n-\n-\t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+            if (cur[1] == 0 || (cur[1] & 0xc0) != 0x80) // Modified check here to avoid out-of-bounds\n+                goto encoding_error;\n+            if ((c & 0xe0) == 0xe0) {\n+                if (cur[2] == 0) {\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if (cur[2] == 0 || (cur[2] & 0xc0) != 0x80) // Modified check here to avoid out-of-bounds\n+                    goto encoding_error;\n+                if ((c & 0xf0) == 0xf0) {\n+                    if (cur[3] == 0) {\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n-\t\t    *len = 4;\n-\t\t    val = (cur[0] & 0x7) << 18;\n-\t\t    val |= (cur[1] & 0x3f) << 12;\n-\t\t    val |= (cur[2] & 0x3f) << 6;\n-\t\t    val |= cur[3] & 0x3f;\n-\t\t} else {\n-\t\t  /* 3-byte code */\n-\t\t    *len = 3;\n-\t\t    val = (cur[0] & 0xf) << 12;\n-\t\t    val |= (cur[1] & 0x3f) << 6;\n-\t\t    val |= cur[2] & 0x3f;\n-\t\t}\n-\t    } else {\n-\t      /* 2-byte code */\n-\t\t*len = 2;\n-\t\tval = (cur[0] & 0x1f) << 6;\n-\t\tval |= cur[1] & 0x3f;\n-\t    }\n-\t    if (!IS_CHAR(val)) {\n-\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n-\t    }\n-\t    return(val);\n-\t} else {\n+                    if (cur[3] == 0 || ((c & 0xf8) != 0xf0) ||\n+                        ((cur[3] & 0xc0) != 0x80)) // Modified check here to avoid out-of-bounds\n+                        goto encoding_error;\n+                    /* 4-byte code */\n+                    *len = 4;\n+                    val = (cur[0] & 0x7) << 18;\n+                    val |= (cur[1] & 0x3f) << 12;\n+                    val |= (cur[2] & 0x3f) << 6;\n+                    val |= cur[3] & 0x3f;\n+                } else {\n+                    /* 3-byte code */\n+                    *len = 3;\n+                    val = (cur[0] & 0xf) << 12;\n+                    val |= (cur[1] & 0x3f) << 6;\n+                    val |= cur[2] & 0x3f;\n+                }\n+            } else {\n+                /* 2-byte code */\n+                *len = 2;\n+                val = (cur[0] & 0x1f) << 6;\n+                val |= cur[1] & 0x3f;\n+            }\n+            if (!IS_CHAR(val)) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                    "Char 0x%X out of allowed range\\n", val);\n+            }\n+            return(val);\n+        } else {\n             if ((*ctxt->input->cur == 0) &&\n                 (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                    "Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n-\t}\n+            /* 1-byte code */\n+            *len = 1;\n+            return((int) *ctxt->input->cur);\n+        }\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n-\treturn((int) *ctxt->input->cur);\n+        return((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,26 +515,19 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n-\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n-\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n-\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n-\t} else {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n-\t}\n-\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-\t\t     "Input is not proper UTF-8, indicate encoding !\\n",\n-\t\t     BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n+                     ctxt->input->cur[0], ctxt->input->cur[1],\n+                     ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                     "Input is not proper UTF-8, indicate encoding !\\n",\n+                     BAD_CAST buffer, NULL);\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n@@ -561,6 +535,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 46, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:445:6'}, {'diff': '@@ -411,106 +411,86 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n-\treturn(0);\n+        return(0);\n \n     if (ctxt->token != 0) {\n-\t*len = 0;\n-\treturn(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        const unsigned char *cur = ctxt->input->cur;\n+        unsigned char c;\n+        unsigned int val;\n+\n+        c = *cur;\n+        if (c & 0x80) {\n+            if (cur[1] == 0) {\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                 cur = ctxt->input->cur;\n             }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n-\n-\t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+            if (cur[1] == 0 || (cur[1] & 0xc0) != 0x80)  // Fixed line to avoid out-of-bounds access\n+                goto encoding_error;\n+            if ((c & 0xe0) == 0xe0) {\n+                if (cur[2] == 0) {\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if (cur[2] == 0 || (cur[2] & 0xc0) != 0x80)  // Fixed line to avoid out-of-bounds access\n+                    goto encoding_error;\n+                if ((c & 0xf0) == 0xf0) {\n+                    if (cur[3] == 0) {\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n-\t\t    *len = 4;\n-\t\t    val = (cur[0] & 0x7) << 18;\n-\t\t    val |= (cur[1] & 0x3f) << 12;\n-\t\t    val |= (cur[2] & 0x3f) << 6;\n-\t\t    val |= cur[3] & 0x3f;\n-\t\t} else {\n-\t\t  /* 3-byte code */\n-\t\t    *len = 3;\n-\t\t    val = (cur[0] & 0xf) << 12;\n-\t\t    val |= (cur[1] & 0x3f) << 6;\n-\t\t    val |= cur[2] & 0x3f;\n-\t\t}\n-\t    } else {\n-\t      /* 2-byte code */\n-\t\t*len = 2;\n-\t\tval = (cur[0] & 0x1f) << 6;\n-\t\tval |= cur[1] & 0x3f;\n-\t    }\n-\t    if (!IS_CHAR(val)) {\n-\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n-\t    }\n-\t    return(val);\n-\t} else {\n+                    if (cur[3] == 0 || ((c & 0xf8) != 0xf0) || ((cur[3] & 0xc0) != 0x80))  // Fixed line to avoid out-of-bounds access\n+                        goto encoding_error;\n+                    /* 4-byte code */\n+                    *len = 4;\n+                    val = (cur[0] & 0x7) << 18;\n+                    val |= (cur[1] & 0x3f) << 12;\n+                    val |= (cur[2] & 0x3f) << 6;\n+                    val |= cur[3] & 0x3f;\n+                } else {\n+                    /* 3-byte code */\n+                    *len = 3;\n+                    val = (cur[0] & 0xf) << 12;\n+                    val |= (cur[1] & 0x3f) << 6;\n+                    val |= cur[2] & 0x3f;\n+                }\n+            } else {\n+                /* 2-byte code */\n+                *len = 2;\n+                val = (cur[0] & 0x1f) << 6;\n+                val |= cur[1] & 0x3f;\n+            }\n+            if (!IS_CHAR(val)) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", val);\n+            }\n+            return(val);\n+        } else {\n             if ((*ctxt->input->cur == 0) &&\n                 (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n-\t}\n+            /* 1-byte code */\n+            *len = 1;\n+            return((int) *ctxt->input->cur);\n+        }\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n-\treturn((int) *ctxt->input->cur);\n+        return((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n-        xmlChar * guess;\n+        xmlChar *guess;\n         xmlCharEncodingHandlerPtr handler;\n \n         guess = htmlFindEncoding(ctxt);\n@@ -534,26 +514,19 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n-\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n-\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n-\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n-\t} else {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n-\t}\n-\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-\t\t     "Input is not proper UTF-8, indicate encoding !\\n",\n-\t\t     BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n+                     ctxt->input->cur[0], ctxt->input->cur[1],\n+                     ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                     "Input is not proper UTF-8, indicate encoding !\\n",\n+                     BAD_CAST buffer, NULL);\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n@@ -561,6 +534,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 47, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:445:6'}, {'diff': '@@ -411,104 +411,86 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n-\treturn(0);\n+        return(0);\n \n     if (ctxt->token != 0) {\n-\t*len = 0;\n-\treturn(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        const unsigned char *cur = ctxt->input->cur;\n+        unsigned char c;\n+        unsigned int val;\n+\n+        c = *cur;\n+        if (c & 0x80) {\n+            if (cur[1] == 0) {\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                 cur = ctxt->input->cur;\n             }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n-\n-\t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+            if ((cur[1] & 0xc0) != 0x80) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "UTF-8 encoding error: expected continuation byte.\\n", 0);\n+                ctxt->charset = XML_CHAR_ENCODING_8859_1; // Switch encoding on error\n+                *len = 1;\n+                return((int) *ctxt->input->cur);\n+            }\n+            if ((c & 0xe0) == 0xe0) {\n+                if (cur[2] == 0) {\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if ((cur[2] & 0xc0) != 0x80)\n+                    goto encoding_error;\n+                if ((c & 0xf0) == 0xf0) {\n+                    if (cur[3] == 0) {\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n-\t\t    *len = 4;\n-\t\t    val = (cur[0] & 0x7) << 18;\n-\t\t    val |= (cur[1] & 0x3f) << 12;\n-\t\t    val |= (cur[2] & 0x3f) << 6;\n-\t\t    val |= cur[3] & 0x3f;\n-\t\t} else {\n-\t\t  /* 3-byte code */\n-\t\t    *len = 3;\n-\t\t    val = (cur[0] & 0xf) << 12;\n-\t\t    val |= (cur[1] & 0x3f) << 6;\n-\t\t    val |= cur[2] & 0x3f;\n-\t\t}\n-\t    } else {\n-\t      /* 2-byte code */\n-\t\t*len = 2;\n-\t\tval = (cur[0] & 0x1f) << 6;\n-\t\tval |= cur[1] & 0x3f;\n-\t    }\n-\t    if (!IS_CHAR(val)) {\n-\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n-\t    }\n-\t    return(val);\n-\t} else {\n+                    if (((c & 0xf8) != 0xf0) ||\n+                        ((cur[3] & 0xc0) != 0x80))\n+                        goto encoding_error;\n+                    *len = 4;\n+                    val = (cur[0] & 0x7) << 18;\n+                    val |= (cur[1] & 0x3f) << 12;\n+                    val |= (cur[2] & 0x3f) << 6;\n+                    val |= cur[3] & 0x3f;\n+                } else {\n+                    *len = 3;\n+                    val = (cur[0] & 0xf) << 12;\n+                    val |= (cur[1] & 0x3f) << 6;\n+                    val |= cur[2] & 0x3f;\n+                }\n+            } else {\n+                *len = 2;\n+                val = (cur[0] & 0x1f) << 6;\n+                val |= cur[1] & 0x3f;\n+            }\n+            if (!IS_CHAR(val)) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", val);\n+            }\n+            return(val);\n+        } else {\n             if ((*ctxt->input->cur == 0) &&\n                 (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n-\t}\n+            *len = 1;\n+            return((int) *ctxt->input->cur);\n+        }\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n-\treturn((int) *ctxt->input->cur);\n+        return((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,26 +516,19 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n-\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n-\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n-\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n-\t} else {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n-\t}\n-\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-\t\t     "Input is not proper UTF-8, indicate encoding !\\n",\n-\t\t     BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n+                     ctxt->input->cur[0], ctxt->input->cur[1],\n+                     ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                     "Input is not proper UTF-8, indicate encoding !\\n",\n+                     BAD_CAST buffer, NULL);\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n@@ -561,6 +536,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 48, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:445:6'}, {'diff': '@@ -411,104 +411,100 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n-\treturn(0);\n+        return(0);\n \n     if (ctxt->token != 0) {\n-\t*len = 0;\n-\treturn(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        const unsigned char *cur = ctxt->input->cur;\n+        unsigned char c;\n+        unsigned int val;\n+\n+        c = *cur;\n+        if (c & 0x80) {\n+            if (cur[1] == 0) {\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                 cur = ctxt->input->cur;\n             }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n-\n-\t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+            if ((cur[1] & 0xc0) != 0x80) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Invalid UTF-8 continuation byte\\n", 0);\n+                ctxt->charset = XML_CHAR_ENCODING_8859_1;\n+                *len = 1;\n+                return((int) *cur);\n+            }\n+            if ((c & 0xe0) == 0xe0) {\n+                if (cur[2] == 0) {\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if ((cur[2] & 0xc0) != 0x80) {\n+                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                    "Invalid UTF-8 continuation byte\\n", 0);\n+                    ctxt->charset = XML_CHAR_ENCODING_8859_1;\n+                    *len = 1;\n+                    return((int) *cur);\n+                }\n+                if ((c & 0xf0) == 0xf0) {\n+                    if (cur[3] == 0) {\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n-\t\t    *len = 4;\n-\t\t    val = (cur[0] & 0x7) << 18;\n-\t\t    val |= (cur[1] & 0x3f) << 12;\n-\t\t    val |= (cur[2] & 0x3f) << 6;\n-\t\t    val |= cur[3] & 0x3f;\n-\t\t} else {\n-\t\t  /* 3-byte code */\n-\t\t    *len = 3;\n-\t\t    val = (cur[0] & 0xf) << 12;\n-\t\t    val |= (cur[1] & 0x3f) << 6;\n-\t\t    val |= cur[2] & 0x3f;\n-\t\t}\n-\t    } else {\n-\t      /* 2-byte code */\n-\t\t*len = 2;\n-\t\tval = (cur[0] & 0x1f) << 6;\n-\t\tval |= cur[1] & 0x3f;\n-\t    }\n-\t    if (!IS_CHAR(val)) {\n-\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n-\t    }\n-\t    return(val);\n-\t} else {\n+                    if (((c & 0xf8) != 0xf0) ||\n+                        ((cur[3] & 0xc0) != 0x80)) {\n+                        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                        "Invalid UTF-8 continuation byte\\n", 0);\n+                        ctxt->charset = XML_CHAR_ENCODING_8859_1;\n+                        *len = 1;\n+                        return((int) *cur);\n+                    }\n+                    /* 4-byte code */\n+                    *len = 4;\n+                    val = (cur[0] & 0x7) << 18;\n+                    val |= (cur[1] & 0x3f) << 12;\n+                    val |= (cur[2] & 0x3f) << 6;\n+                    val |= cur[3] & 0x3f;\n+                } else {\n+                    /* 3-byte code */\n+                    *len = 3;\n+                    val = (cur[0] & 0xf) << 12;\n+                    val |= (cur[1] & 0x3f) << 6;\n+                    val |= cur[2] & 0x3f;\n+                }\n+            } else {\n+                /* 2-byte code */\n+                *len = 2;\n+                val = (cur[0] & 0x1f) << 6;\n+                val |= cur[1] & 0x3f;\n+            }\n+            if (!IS_CHAR(val)) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", val);\n+            }\n+            return(val);\n+        } else {\n             if ((*ctxt->input->cur == 0) &&\n                 (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n-\t}\n+            /* 1-byte code */\n+            *len = 1;\n+            return((int) *ctxt->input->cur);\n+        }\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n-\treturn((int) *ctxt->input->cur);\n+        return((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,26 +530,19 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n-\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n-\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n-\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n-\t} else {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n-\t}\n-\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-\t\t     "Input is not proper UTF-8, indicate encoding !\\n",\n-\t\t     BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n+                     ctxt->input->cur[0], ctxt->input->cur[1],\n+                     ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                     "Input is not proper UTF-8, indicate encoding !\\n",\n+                     BAD_CAST buffer, NULL);\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n@@ -561,6 +550,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 49, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:445:6'}, {'diff': '@@ -411,104 +411,83 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n-\treturn(0);\n+        return(0);\n \n     if (ctxt->token != 0) {\n-\t*len = 0;\n-\treturn(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        const unsigned char *cur = ctxt->input->cur;\n+        unsigned char c;\n+        unsigned int val;\n+\n+        c = *cur;\n+        if (c & 0x80) {\n+            if (cur[1] == 0) {\n+                if (cur >= ctxt->input->end) return 0; // Check end bounds\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                 cur = ctxt->input->cur;\n             }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n-\n-\t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+            if ((cur[1] & 0xc0) != 0x80)\n+                goto encoding_error;\n+            if ((c & 0xe0) == 0xe0) {\n+                if (cur[2] == 0) {\n+                    if (cur + 1 >= ctxt->input->end) return 0; // Check end bounds\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if ((cur[2] & 0xc0) != 0x80)\n+                    goto encoding_error;\n+                if ((c & 0xf0) == 0xf0) {\n+                    if (cur[3] == 0) {\n+                        if (cur + 2 >= ctxt->input->end) return 0; // Check end bounds\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n-\t\t    *len = 4;\n-\t\t    val = (cur[0] & 0x7) << 18;\n-\t\t    val |= (cur[1] & 0x3f) << 12;\n-\t\t    val |= (cur[2] & 0x3f) << 6;\n-\t\t    val |= cur[3] & 0x3f;\n-\t\t} else {\n-\t\t  /* 3-byte code */\n-\t\t    *len = 3;\n-\t\t    val = (cur[0] & 0xf) << 12;\n-\t\t    val |= (cur[1] & 0x3f) << 6;\n-\t\t    val |= cur[2] & 0x3f;\n-\t\t}\n-\t    } else {\n-\t      /* 2-byte code */\n-\t\t*len = 2;\n-\t\tval = (cur[0] & 0x1f) << 6;\n-\t\tval |= cur[1] & 0x3f;\n-\t    }\n-\t    if (!IS_CHAR(val)) {\n-\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n-\t    }\n-\t    return(val);\n-\t} else {\n-            if ((*ctxt->input->cur == 0) &&\n-                (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+                    if (((c & 0xf8) != 0xf0) ||\n+                        ((cur[3] & 0xc0) != 0x80))\n+                        goto encoding_error;\n+                    *len = 4;\n+                    val = (cur[0] & 0x7) << 18;\n+                    val |= (cur[1] & 0x3f) << 12;\n+                    val |= (cur[2] & 0x3f) << 6;\n+                    val |= cur[3] & 0x3f;\n+                } else {\n+                    *len = 3;\n+                    val = (cur[0] & 0xf) << 12;\n+                    val |= (cur[1] & 0x3f) << 6;\n+                    val |= cur[2] & 0x3f;\n+                }\n+            } else {\n+                *len = 2;\n+                val = (cur[0] & 0x1f) << 6;\n+                val |= cur[1] & 0x3f;\n+            }\n+            if (!IS_CHAR(val)) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", val);\n+            }\n+            return(val);\n+        } else {\n+            if ((cur == 0) && (ctxt->input->cur < ctxt->input->end)) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n-\t}\n+            *len = 1;\n+            return((int) *ctxt->input->cur);\n+        }\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n-\treturn((int) *ctxt->input->cur);\n+        return((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,26 +513,19 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n-\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n-\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n-\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n-\t} else {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n-\t}\n-\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-\t\t     "Input is not proper UTF-8, indicate encoding !\\n",\n-\t\t     BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n+                     ctxt->input->cur[0], ctxt->input->cur[1],\n+                     ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                     "Input is not proper UTF-8, indicate encoding !\\n",\n+                     BAD_CAST buffer, NULL);\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n@@ -561,6 +533,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 50, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:441:6'}, {'diff': '@@ -411,104 +411,102 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n-\treturn(0);\n+        return(0);\n \n     if (ctxt->token != 0) {\n-\t*len = 0;\n-\treturn(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        const unsigned char *cur = ctxt->input->cur;\n+        unsigned char c;\n+        unsigned int val;\n+\n+        c = *cur;\n+        if (c & 0x80) {\n+            if (cur[1] == 0) {\n+                if (cur >= ctxt->input->end) {\n+                    htmlParseErr(ctxt, XML_ERR_INVALID_CHAR, "Input is not proper UTF-8, indicate encoding !", NULL, NULL);\n+                    ctxt->charset = XML_CHAR_ENCODING_8859_1;\n+                    *len = 1;\n+                    return((int) *cur);\n+                }\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                 cur = ctxt->input->cur;\n             }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n-\n-\t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+            if ((cur[1] & 0xc0) != 0x80)\n+                goto encoding_error;\n+            if ((c & 0xe0) == 0xe0) {\n+                if (cur[2] == 0) {\n+                    if (cur >= ctxt->input->end) {\n+                        htmlParseErr(ctxt, XML_ERR_INVALID_CHAR, "Input is not proper UTF-8, indicate encoding !", NULL, NULL);\n+                        ctxt->charset = XML_CHAR_ENCODING_8859_1;\n+                        *len = 1;\n+                        return((int) *cur);\n+                    }\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if ((cur[2] & 0xc0) != 0x80)\n+                    goto encoding_error;\n+                if ((c & 0xf0) == 0xf0) {\n+                    if (cur[3] == 0) {\n+                        if (cur >= ctxt->input->end) {\n+                            htmlParseErr(ctxt, XML_ERR_INVALID_CHAR, "Input is not proper UTF-8, indicate encoding !", NULL, NULL);\n+                            ctxt->charset = XML_CHAR_ENCODING_8859_1;\n+                            *len = 1;\n+                            return((int) *cur);\n+                        }\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n-\t\t    *len = 4;\n-\t\t    val = (cur[0] & 0x7) << 18;\n-\t\t    val |= (cur[1] & 0x3f) << 12;\n-\t\t    val |= (cur[2] & 0x3f) << 6;\n-\t\t    val |= cur[3] & 0x3f;\n-\t\t} else {\n-\t\t  /* 3-byte code */\n-\t\t    *len = 3;\n-\t\t    val = (cur[0] & 0xf) << 12;\n-\t\t    val |= (cur[1] & 0x3f) << 6;\n-\t\t    val |= cur[2] & 0x3f;\n-\t\t}\n-\t    } else {\n-\t      /* 2-byte code */\n-\t\t*len = 2;\n-\t\tval = (cur[0] & 0x1f) << 6;\n-\t\tval |= cur[1] & 0x3f;\n-\t    }\n-\t    if (!IS_CHAR(val)) {\n-\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n-\t    }\n-\t    return(val);\n-\t} else {\n+                    if (((c & 0xf8) != 0xf0) || ((cur[3] & 0xc0) != 0x80))\n+                        goto encoding_error;\n+                    /* 4-byte code */\n+                    *len = 4;\n+                    val = (cur[0] & 0x7) << 18;\n+                    val |= (cur[1] & 0x3f) << 12;\n+                    val |= (cur[2] & 0x3f) << 6;\n+                    val |= cur[3] & 0x3f;\n+                } else {\n+                    /* 3-byte code */\n+                    *len = 3;\n+                    val = (cur[0] & 0xf) << 12;\n+                    val |= (cur[1] & 0x3f) << 6;\n+                    val |= cur[2] & 0x3f;\n+                }\n+            } else {\n+                /* 2-byte code */\n+                *len = 2;\n+                val = (cur[0] & 0x1f) << 6;\n+                val |= cur[1] & 0x3f;\n+            }\n+            if (!IS_CHAR(val)) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", val);\n+            }\n+            return(val);\n+        } else {\n             if ((*ctxt->input->cur == 0) &&\n                 (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n-\t}\n+            /* 1-byte code */\n+            *len = 1;\n+            return((int) *ctxt->input->cur);\n+        }\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n-\treturn((int) *ctxt->input->cur);\n+        return((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,26 +532,19 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n-\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n-\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n-\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n-\t} else {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n-\t}\n-\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-\t\t     "Input is not proper UTF-8, indicate encoding !\\n",\n-\t\t     BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n+                     ctxt->input->cur[0], ctxt->input->cur[1],\n+                     ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                     "Input is not proper UTF-8, indicate encoding !\\n",\n+                     BAD_CAST buffer, NULL);\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n@@ -561,6 +552,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 51, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:441:6'}, {'diff': '@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,60 +422,67 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n-                cur = ctxt->input->cur;\n+        const unsigned char *cur = ctxt->input->cur;\n+        unsigned char c;\n+        unsigned int val;\n+\n+        c = *cur;\n+        if (c & 0x80) {\n+            if (cur[1] == 0) {\n+\t\tif (cur + 1 < ctxt->input->end) {\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                    cur = ctxt->input->cur;\n+                } else {\n+                    htmlParseErr(ctxt, XML_ERR_INVALID_CHAR,\n+                                 "Unexpected end of input\\n", NULL);\n+                    *len = 1;\n+                    return (int)(*cur);\n+                }\n             }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n+            if ((cur[1] & 0xc0) != 0x80)\n \t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n+            if ((c & 0xe0) == 0xe0) {\n \n \t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n-                    cur = ctxt->input->cur;\n-                }\n+\t\t    if (cur + 2 < ctxt->input->end) {\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                        cur = ctxt->input->cur;\n+                    } else {\n+                        htmlParseErr(ctxt, XML_ERR_INVALID_CHAR,\n+                                     "Unexpected end of input\\n", NULL);\n+                        *len = 2;\n+                        return (int)(*cur);\n+                    }\n+\t\t}\n \t\tif ((cur[2] & 0xc0) != 0x80)\n \t\t    goto encoding_error;\n \t\tif ((c & 0xf0) == 0xf0) {\n \t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n-                        cur = ctxt->input->cur;\n-                    }\n+\t\t\tif (cur + 3 < ctxt->input->end) {\n+                            xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                            cur = ctxt->input->cur;\n+                        } else {\n+                            htmlParseErr(ctxt, XML_ERR_INVALID_CHAR,\n+                                         "Unexpected end of input\\n", NULL);\n+                            *len = 3;\n+                            return (int)(*cur);\n+                        }\n+\t\t    }\n \t\t    if (((c & 0xf8) != 0xf0) ||\n \t\t\t((cur[3] & 0xc0) != 0x80))\n \t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n \t\t    *len = 4;\n \t\t    val = (cur[0] & 0x7) << 18;\n \t\t    val |= (cur[1] & 0x3f) << 12;\n \t\t    val |= (cur[2] & 0x3f) << 6;\n \t\t    val |= cur[3] & 0x3f;\n \t\t} else {\n-\t\t  /* 3-byte code */\n \t\t    *len = 3;\n \t\t    val = (cur[0] & 0xf) << 12;\n \t\t    val |= (cur[1] & 0x3f) << 6;\n \t\t    val |= cur[2] & 0x3f;\n \t\t}\n \t    } else {\n-\t      /* 2-byte code */\n \t\t*len = 2;\n \t\tval = (cur[0] & 0x1f) << 6;\n \t\tval |= cur[1] & 0x3f;\n@@ -485,30 +493,21 @@\n \t    }\n \t    return(val);\n \t} else {\n-            if ((*ctxt->input->cur == 0) &&\n+\t    if ((*ctxt->input->cur == 0) &&\n                 (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n \t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n \t    *len = 1;\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +533,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -561,6 +553,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 52, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:441:6'}, {'diff': '@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,17 +422,6 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n \tconst unsigned char *cur = ctxt->input->cur;\n \tunsigned char c;\n \tunsigned int val;\n@@ -441,7 +431,14 @@\n \t    if (cur[1] == 0) {\n \t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                 cur = ctxt->input->cur;\n-            }\n+                if (cur[1] == 0) {\n+                    /* Handle potential failure of input growth gracefully */\n+                    htmlParseErr(ctxt, XML_ERR_INVALID_CHAR,\n+                                 "Unexpected end of input while processing UTF-8\\n", NULL);\n+                    *len = 1;\n+                    return (int)*cur;\n+                }\n+\t    }\n \t    if ((cur[1] & 0xc0) != 0x80)\n \t\tgoto encoding_error;\n \t    if ((c & 0xe0) == 0xe0) {\n@@ -449,14 +446,26 @@\n \t\tif (cur[2] == 0) {\n \t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n-                }\n+                    if (cur[2] == 0) {\n+                        htmlParseErr(ctxt, XML_ERR_INVALID_CHAR,\n+                                     "Unexpected end of input while processing UTF-8\\n", NULL);\n+                        *len = 1;\n+                        return (int)*cur;\n+                    }\n+\t\t}\n \t\tif ((cur[2] & 0xc0) != 0x80)\n \t\t    goto encoding_error;\n \t\tif ((c & 0xf0) == 0xf0) {\n \t\t    if (cur[3] == 0) {\n \t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n-                    }\n+                        if (cur[3] == 0) {\n+                            htmlParseErr(ctxt, XML_ERR_INVALID_CHAR,\n+                                         "Unexpected end of input while processing UTF-8\\n", NULL);\n+                            *len = 1;\n+                            return (int)*cur;\n+                        }\n+\t\t    }\n \t\t    if (((c & 0xf8) != 0xf0) ||\n \t\t\t((cur[3] & 0xc0) != 0x80))\n \t\t\tgoto encoding_error;\n@@ -467,14 +476,14 @@\n \t\t    val |= (cur[2] & 0x3f) << 6;\n \t\t    val |= cur[3] & 0x3f;\n \t\t} else {\n-\t\t  /* 3-byte code */\n+\t\t    /* 3-byte code */\n \t\t    *len = 3;\n \t\t    val = (cur[0] & 0xf) << 12;\n \t\t    val |= (cur[1] & 0x3f) << 6;\n \t\t    val |= cur[2] & 0x3f;\n \t\t}\n \t    } else {\n-\t      /* 2-byte code */\n+\t\t/* 2-byte code */\n \t\t*len = 2;\n \t\tval = (cur[0] & 0x1f) << 6;\n \t\tval |= cur[1] & 0x3f;\n@@ -497,18 +506,10 @@\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +535,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -561,6 +555,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 53, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:441:6'}, {'diff': '@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,17 +422,6 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n \tconst unsigned char *cur = ctxt->input->cur;\n \tunsigned char c;\n \tunsigned int val;\n@@ -439,14 +429,23 @@\n \tc = *cur;\n \tif (c & 0x80) {\n \t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+\t\tif (cur >= ctxt->input->end) {\n+\t\t    htmlParseErr(ctxt, XML_ERR_INVALID_CHAR, "Unexpected end of input\\n", NULL);\n+\t\t    *len = 1;\n+\t\t    return(\' \');\n+                }\n+\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                 cur = ctxt->input->cur;\n             }\n \t    if ((cur[1] & 0xc0) != 0x80)\n \t\tgoto encoding_error;\n \t    if ((c & 0xe0) == 0xe0) {\n-\n \t\tif (cur[2] == 0) {\n+\t\t    if (cur >= ctxt->input->end) {\n+\t\t\thtmlParseErr(ctxt, XML_ERR_INVALID_CHAR, "Unexpected end of input\\n", NULL);\n+\t\t\t*len = 1;\n+\t\t\treturn(\' \');\n+                    }\n \t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n@@ -454,27 +453,29 @@\n \t\t    goto encoding_error;\n \t\tif ((c & 0xf0) == 0xf0) {\n \t\t    if (cur[3] == 0) {\n+\t\t\tif (cur >= ctxt->input->end) {\n+\t\t\t    htmlParseErr(ctxt, XML_ERR_INVALID_CHAR, "Unexpected end of input\\n", NULL);\n+\t\t\t    *len = 1;\n+\t\t\t    return(\' \');\n+                        }\n \t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n \t\t    if (((c & 0xf8) != 0xf0) ||\n \t\t\t((cur[3] & 0xc0) != 0x80))\n \t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n \t\t    *len = 4;\n \t\t    val = (cur[0] & 0x7) << 18;\n \t\t    val |= (cur[1] & 0x3f) << 12;\n \t\t    val |= (cur[2] & 0x3f) << 6;\n \t\t    val |= cur[3] & 0x3f;\n \t\t} else {\n-\t\t  /* 3-byte code */\n \t\t    *len = 3;\n \t\t    val = (cur[0] & 0xf) << 12;\n \t\t    val |= (cur[1] & 0x3f) << 6;\n \t\t    val |= cur[2] & 0x3f;\n \t\t}\n \t    } else {\n-\t      /* 2-byte code */\n \t\t*len = 2;\n \t\tval = (cur[0] & 0x1f) << 6;\n \t\tval |= cur[1] & 0x3f;\n@@ -492,23 +493,14 @@\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n \t    *len = 1;\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +526,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -561,6 +546,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 54, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:441:6'}, {'diff': "@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,17 +422,6 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it's valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n \tconst unsigned char *cur = ctxt->input->cur;\n \tunsigned char c;\n \tunsigned int val;\n@@ -445,7 +435,6 @@\n \t    if ((cur[1] & 0xc0) != 0x80)\n \t\tgoto encoding_error;\n \t    if ((c & 0xe0) == 0xe0) {\n-\n \t\tif (cur[2] == 0) {\n \t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n@@ -460,21 +449,18 @@\n \t\t    if (((c & 0xf8) != 0xf0) ||\n \t\t\t((cur[3] & 0xc0) != 0x80))\n \t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n \t\t    *len = 4;\n \t\t    val = (cur[0] & 0x7) << 18;\n \t\t    val |= (cur[1] & 0x3f) << 12;\n \t\t    val |= (cur[2] & 0x3f) << 6;\n \t\t    val |= cur[3] & 0x3f;\n \t\t} else {\n-\t\t  /* 3-byte code */\n \t\t    *len = 3;\n \t\t    val = (cur[0] & 0xf) << 12;\n \t\t    val |= (cur[1] & 0x3f) << 6;\n \t\t    val |= cur[2] & 0x3f;\n \t\t}\n \t    } else {\n-\t      /* 2-byte code */\n \t\t*len = 2;\n \t\tval = (cur[0] & 0x1f) << 6;\n \t\tval |= cur[1] & 0x3f;\n@@ -492,23 +478,14 @@\n                 *len = 1;\n                 return(' ');\n             }\n-\t    /* 1-byte code */\n \t    *len = 1;\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it's a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +511,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn't get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don't like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -561,6 +531,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n", 'id': 55, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:497:6'}, {'diff': '@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,17 +422,6 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n \tconst unsigned char *cur = ctxt->input->cur;\n \tunsigned char c;\n \tunsigned int val;\n@@ -460,21 +450,18 @@\n \t\t    if (((c & 0xf8) != 0xf0) ||\n \t\t\t((cur[3] & 0xc0) != 0x80))\n \t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n \t\t    *len = 4;\n \t\t    val = (cur[0] & 0x7) << 18;\n \t\t    val |= (cur[1] & 0x3f) << 12;\n \t\t    val |= (cur[2] & 0x3f) << 6;\n \t\t    val |= cur[3] & 0x3f;\n \t\t} else {\n-\t\t  /* 3-byte code */\n \t\t    *len = 3;\n \t\t    val = (cur[0] & 0xf) << 12;\n \t\t    val |= (cur[1] & 0x3f) << 6;\n \t\t    val |= cur[2] & 0x3f;\n \t\t}\n \t    } else {\n-\t      /* 2-byte code */\n \t\t*len = 2;\n \t\tval = (cur[0] & 0x1f) << 6;\n \t\tval |= cur[1] & 0x3f;\n@@ -487,28 +474,19 @@\n \t} else {\n             if ((*ctxt->input->cur == 0) &&\n                 (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n \t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n \t    *len = 1;\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -531,16 +509,9 @@\n         ctxt->charset = XML_CHAR_ENCODING_UTF8;\n     }\n \n-    return(xmlCurrentChar(ctxt, len));\n+    return(htmlCurrentChar(ctxt, len)); // Updated this line to ensure we call the right handling for the character state.\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -561,6 +532,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 56, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:497:6'}, {'diff': "@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,17 +422,6 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it's valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n \tconst unsigned char *cur = ctxt->input->cur;\n \tunsigned char c;\n \tunsigned int val;\n@@ -460,21 +450,18 @@\n \t\t    if (((c & 0xf8) != 0xf0) ||\n \t\t\t((cur[3] & 0xc0) != 0x80))\n \t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n \t\t    *len = 4;\n \t\t    val = (cur[0] & 0x7) << 18;\n \t\t    val |= (cur[1] & 0x3f) << 12;\n \t\t    val |= (cur[2] & 0x3f) << 6;\n \t\t    val |= cur[3] & 0x3f;\n \t\t} else {\n-\t\t  /* 3-byte code */\n \t\t    *len = 3;\n \t\t    val = (cur[0] & 0xf) << 12;\n \t\t    val |= (cur[1] & 0x3f) << 6;\n \t\t    val |= cur[2] & 0x3f;\n \t\t}\n \t    } else {\n-\t      /* 2-byte code */\n \t\t*len = 2;\n \t\tval = (cur[0] & 0x1f) << 6;\n \t\tval |= cur[1] & 0x3f;\n@@ -492,23 +479,14 @@\n                 *len = 1;\n                 return(' ');\n             }\n-\t    /* 1-byte code */\n \t    *len = 1;\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it's a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +512,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn't get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don't like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -557,10 +528,11 @@\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n-    *len = 1;\n-    return((int) *ctxt->input->cur);\n+    *len = 1; // This line has been retained for *len assignment\n+    return((int) *ctxt->input->cur); // This line should be modified to ensure safe return\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n", 'id': 57, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:497:6'}, {'diff': '@@ -411,104 +411,82 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n-\treturn(0);\n+        return(0);\n \n     if (ctxt->token != 0) {\n-\t*len = 0;\n-\treturn(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        const unsigned char *cur = ctxt->input->cur;\n+        unsigned char c;\n+        unsigned int val;\n+\n+        c = *cur;\n+        if (c & 0x80) {\n+            if (cur[1] == 0) {\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                 cur = ctxt->input->cur;\n             }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n+            if ((cur[1] & 0xc0) != 0x80)\n+                goto encoding_error;\n+            if ((c & 0xe0) == 0xe0) {\n \n-\t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if (cur[2] == 0) {\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if ((cur[2] & 0xc0) != 0x80)\n+                    goto encoding_error;\n+                if ((c & 0xf0) == 0xf0) {\n+                    if (cur[3] == 0) {\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n-\t\t    *len = 4;\n-\t\t    val = (cur[0] & 0x7) << 18;\n-\t\t    val |= (cur[1] & 0x3f) << 12;\n-\t\t    val |= (cur[2] & 0x3f) << 6;\n-\t\t    val |= cur[3] & 0x3f;\n-\t\t} else {\n-\t\t  /* 3-byte code */\n-\t\t    *len = 3;\n-\t\t    val = (cur[0] & 0xf) << 12;\n-\t\t    val |= (cur[1] & 0x3f) << 6;\n-\t\t    val |= cur[2] & 0x3f;\n-\t\t}\n-\t    } else {\n-\t      /* 2-byte code */\n-\t\t*len = 2;\n-\t\tval = (cur[0] & 0x1f) << 6;\n-\t\tval |= cur[1] & 0x3f;\n-\t    }\n-\t    if (!IS_CHAR(val)) {\n-\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n-\t    }\n-\t    return(val);\n-\t} else {\n+                    if (((c & 0xf8) != 0xf0) ||\n+                        ((cur[3] & 0xc0) != 0x80))\n+                        goto encoding_error;\n+                    *len = 4;\n+                    val = (cur[0] & 0x7) << 18;\n+                    val |= (cur[1] & 0x3f) << 12;\n+                    val |= (cur[2] & 0x3f) << 6;\n+                    val |= cur[3] & 0x3f;\n+                } else {\n+                    *len = 3;\n+                    val = (cur[0] & 0xf) << 12;\n+                    val |= (cur[1] & 0x3f) << 6;\n+                    val |= cur[2] & 0x3f;\n+                }\n+            } else {\n+                *len = 2;\n+                val = (cur[0] & 0x1f) << 6;\n+                val |= cur[1] & 0x3f;\n+            }\n+            if (!IS_CHAR(val)) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", val);\n+            }\n+            return(val);\n+        } else {\n             if ((*ctxt->input->cur == 0) &&\n                 (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n-\t}\n+            *len = 1;\n+            return((int) *ctxt->input->cur);\n+        }\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n-\treturn((int) *ctxt->input->cur);\n+        return((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,33 +512,32 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n-\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n-\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n-\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n-\t} else {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n-\t}\n-\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-\t\t     "Input is not proper UTF-8, indicate encoding !\\n",\n-\t\t     BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n+                     ctxt->input->cur[0], ctxt->input->cur[1],\n+                     ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                     "Input is not proper UTF-8, indicate encoding !\\n",\n+                     BAD_CAST buffer, NULL);\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n-    *len = 1;\n-    return((int) *ctxt->input->cur);\n+    if (ctxt->input->cur < ctxt->input->end) { // Added check to avoid dereferencing beyond input end\n+        *len = 1;\n+        return((int) *ctxt->input->cur);\n+    } else {\n+        *len = 1; // Set len appropriately\n+        return(0); // Return an error indicator if no valid character is available\n+    }\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 58, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:497:6'}, {'diff': '@@ -411,104 +411,82 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n-\treturn(0);\n+        return(0);\n \n     if (ctxt->token != 0) {\n-\t*len = 0;\n-\treturn(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        const unsigned char *cur = ctxt->input->cur;\n+        unsigned char c;\n+        unsigned int val;\n+\n+        c = *cur;\n+        if (c & 0x80) {\n+            if (cur[1] == 0) {\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                 cur = ctxt->input->cur;\n             }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n+            if ((cur[1] & 0xc0) != 0x80)\n+                goto encoding_error;\n+            if ((c & 0xe0) == 0xe0) {\n \n-\t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if (cur[2] == 0) {\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if ((cur[2] & 0xc0) != 0x80)\n+                    goto encoding_error;\n+                if ((c & 0xf0) == 0xf0) {\n+                    if (cur[3] == 0) {\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n-\t\t    *len = 4;\n-\t\t    val = (cur[0] & 0x7) << 18;\n-\t\t    val |= (cur[1] & 0x3f) << 12;\n-\t\t    val |= (cur[2] & 0x3f) << 6;\n-\t\t    val |= cur[3] & 0x3f;\n-\t\t} else {\n-\t\t  /* 3-byte code */\n-\t\t    *len = 3;\n-\t\t    val = (cur[0] & 0xf) << 12;\n-\t\t    val |= (cur[1] & 0x3f) << 6;\n-\t\t    val |= cur[2] & 0x3f;\n-\t\t}\n-\t    } else {\n-\t      /* 2-byte code */\n-\t\t*len = 2;\n-\t\tval = (cur[0] & 0x1f) << 6;\n-\t\tval |= cur[1] & 0x3f;\n-\t    }\n-\t    if (!IS_CHAR(val)) {\n-\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n-\t    }\n-\t    return(val);\n-\t} else {\n+                    if (((c & 0xf8) != 0xf0) ||\n+                        ((cur[3] & 0xc0) != 0x80))\n+                        goto encoding_error;\n+                    *len = 4;\n+                    val = (cur[0] & 0x7) << 18;\n+                    val |= (cur[1] & 0x3f) << 12;\n+                    val |= (cur[2] & 0x3f) << 6;\n+                    val |= cur[3] & 0x3f;\n+                } else {\n+                    *len = 3;\n+                    val = (cur[0] & 0xf) << 12;\n+                    val |= (cur[1] & 0x3f) << 6;\n+                    val |= cur[2] & 0x3f;\n+                }\n+            } else {\n+                *len = 2;\n+                val = (cur[0] & 0x1f) << 6;\n+                val |= cur[1] & 0x3f;\n+            }\n+            if (!IS_CHAR(val)) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", val);\n+            }\n+            return(val);\n+        } else {\n             if ((*ctxt->input->cur == 0) &&\n                 (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n-\t}\n+            *len = 1;\n+            return((int) *cur); // Modified line\n+        }\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n-\treturn((int) *ctxt->input->cur);\n+        return((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,26 +512,19 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n-\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n-\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n-\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n-\t} else {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n-\t}\n-\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-\t\t     "Input is not proper UTF-8, indicate encoding !\\n",\n-\t\t     BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n+                     ctxt->input->cur[0], ctxt->input->cur[1],\n+                     ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                     "Input is not proper UTF-8, indicate encoding !\\n",\n+                     BAD_CAST buffer, NULL);\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n@@ -561,6 +532,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 59, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:497:6'}, {'diff': '@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,17 +422,6 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n \tconst unsigned char *cur = ctxt->input->cur;\n \tunsigned char c;\n \tunsigned int val;\n@@ -460,21 +450,18 @@\n \t\t    if (((c & 0xf8) != 0xf0) ||\n \t\t\t((cur[3] & 0xc0) != 0x80))\n \t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n \t\t    *len = 4;\n \t\t    val = (cur[0] & 0x7) << 18;\n \t\t    val |= (cur[1] & 0x3f) << 12;\n \t\t    val |= (cur[2] & 0x3f) << 6;\n \t\t    val |= cur[3] & 0x3f;\n \t\t} else {\n-\t\t  /* 3-byte code */\n \t\t    *len = 3;\n \t\t    val = (cur[0] & 0xf) << 12;\n \t\t    val |= (cur[1] & 0x3f) << 6;\n \t\t    val |= cur[2] & 0x3f;\n \t\t}\n \t    } else {\n-\t      /* 2-byte code */\n \t\t*len = 2;\n \t\tval = (cur[0] & 0x1f) << 6;\n \t\tval |= cur[1] & 0x3f;\n@@ -489,26 +476,17 @@\n                 (ctxt->input->cur < ctxt->input->end)) {\n                     htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n \t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n-                *len = 1;\n+                *len = 1;  // Modified\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n \t    *len = 1;\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +512,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -557,10 +528,11 @@\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n-    *len = 1;\n+    *len = 1;  // Modified\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 60, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:496:6'}, {'diff': "@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,17 +422,6 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it's valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n \tconst unsigned char *cur = ctxt->input->cur;\n \tunsigned char c;\n \tunsigned int val;\n@@ -497,18 +487,10 @@\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it's a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +516,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn't get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don't like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -557,10 +532,11 @@\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n-    *len = 1;\n+    *len = 1; // Next code flow is not right\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n", 'id': 61, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:496:6'}, {'diff': '@@ -411,104 +411,82 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n-\treturn(0);\n+        return(0);\n \n     if (ctxt->token != 0) {\n-\t*len = 0;\n-\treturn(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        const unsigned char *cur = ctxt->input->cur;\n+        unsigned char c;\n+        unsigned int val;\n+\n+        c = *cur;\n+        if (c & 0x80) {\n+            if (cur[1] == 0) {\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                 cur = ctxt->input->cur;\n             }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n+            if ((cur[1] & 0xc0) != 0x80)\n+                goto encoding_error;\n+            if ((c & 0xe0) == 0xe0) {\n \n-\t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if (cur[2] == 0) {\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if ((cur[2] & 0xc0) != 0x80)\n+                    goto encoding_error;\n+                if ((c & 0xf0) == 0xf0) {\n+                    if (cur[3] == 0) {\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n-\t\t    *len = 4;\n-\t\t    val = (cur[0] & 0x7) << 18;\n-\t\t    val |= (cur[1] & 0x3f) << 12;\n-\t\t    val |= (cur[2] & 0x3f) << 6;\n-\t\t    val |= cur[3] & 0x3f;\n-\t\t} else {\n-\t\t  /* 3-byte code */\n-\t\t    *len = 3;\n-\t\t    val = (cur[0] & 0xf) << 12;\n-\t\t    val |= (cur[1] & 0x3f) << 6;\n-\t\t    val |= cur[2] & 0x3f;\n-\t\t}\n-\t    } else {\n-\t      /* 2-byte code */\n-\t\t*len = 2;\n-\t\tval = (cur[0] & 0x1f) << 6;\n-\t\tval |= cur[1] & 0x3f;\n-\t    }\n-\t    if (!IS_CHAR(val)) {\n-\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n-\t    }\n-\t    return(val);\n-\t} else {\n+                    if (((c & 0xf8) != 0xf0) ||\n+                        ((cur[3] & 0xc0) != 0x80))\n+                        goto encoding_error;\n+                    *len = 4;\n+                    val = (cur[0] & 0x7) << 18;\n+                    val |= (cur[1] & 0x3f) << 12;\n+                    val |= (cur[2] & 0x3f) << 6;\n+                    val |= cur[3] & 0x3f;\n+                } else {\n+                    *len = 3;\n+                    val = (cur[0] & 0xf) << 12;\n+                    val |= (cur[1] & 0x3f) << 6;\n+                    val |= cur[2] & 0x3f;\n+                }\n+            } else {\n+                *len = 2;\n+                val = (cur[0] & 0x1f) << 6;\n+                val |= cur[1] & 0x3f;\n+            }\n+            if (!IS_CHAR(val)) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", val);\n+            }\n+            return(val);\n+        } else {\n             if ((*ctxt->input->cur == 0) &&\n                 (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n-\t}\n+            *len = 1;\n+            return((int) *ctxt->input->cur);\n+        }\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n-\treturn((int) *ctxt->input->cur);\n+        return((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,33 +512,27 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n-\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n-\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n-\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n-\t} else {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n-\t}\n-\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-\t\t     "Input is not proper UTF-8, indicate encoding !\\n",\n-\t\t     BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n+                     ctxt->input->cur[0], ctxt->input->cur[1],\n+                     ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                     "Input is not proper UTF-8, indicate encoding !\\n",\n+                     BAD_CAST buffer, NULL);\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n-    *len = 1;\n+    *len = -1; // Updated line to handle incorrect input length\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 62, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:496:6'}, {'diff': '@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,17 +422,6 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n \tconst unsigned char *cur = ctxt->input->cur;\n \tunsigned char c;\n \tunsigned int val;\n@@ -460,21 +450,18 @@\n \t\t    if (((c & 0xf8) != 0xf0) ||\n \t\t\t((cur[3] & 0xc0) != 0x80))\n \t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n \t\t    *len = 4;\n \t\t    val = (cur[0] & 0x7) << 18;\n \t\t    val |= (cur[1] & 0x3f) << 12;\n \t\t    val |= (cur[2] & 0x3f) << 6;\n \t\t    val |= cur[3] & 0x3f;\n \t\t} else {\n-\t\t  /* 3-byte code */\n \t\t    *len = 3;\n \t\t    val = (cur[0] & 0xf) << 12;\n \t\t    val |= (cur[1] & 0x3f) << 6;\n \t\t    val |= cur[2] & 0x3f;\n \t\t}\n \t    } else {\n-\t      /* 2-byte code */\n \t\t*len = 2;\n \t\tval = (cur[0] & 0x1f) << 6;\n \t\tval |= cur[1] & 0x3f;\n@@ -489,26 +476,17 @@\n                 (ctxt->input->cur < ctxt->input->end)) {\n                     htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n \t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n-                *len = 1;\n+                *len = 0; // Modified to prevent returning a value for an invalid character\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n+\t    *len = 1; // Unchanged\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +512,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -557,10 +528,11 @@\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n-    *len = 1;\n+    *len = 0; // Modified to prevent returning a value for an invalid character\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 63, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:496:6'}, {'diff': '@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,17 +422,6 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n \tconst unsigned char *cur = ctxt->input->cur;\n \tunsigned char c;\n \tunsigned int val;\n@@ -467,14 +457,14 @@\n \t\t    val |= (cur[2] & 0x3f) << 6;\n \t\t    val |= cur[3] & 0x3f;\n \t\t} else {\n-\t\t  /* 3-byte code */\n+\t\t    /* 3-byte code */\n \t\t    *len = 3;\n \t\t    val = (cur[0] & 0xf) << 12;\n \t\t    val |= (cur[1] & 0x3f) << 6;\n \t\t    val |= cur[2] & 0x3f;\n \t\t}\n \t    } else {\n-\t      /* 2-byte code */\n+\t\t/* 2-byte code */\n \t\t*len = 2;\n \t\tval = (cur[0] & 0x1f) << 6;\n \t\tval |= cur[1] & 0x3f;\n@@ -489,7 +479,7 @@\n                 (ctxt->input->cur < ctxt->input->end)) {\n                     htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n \t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n-                *len = 1;\n+                *len = 1;  // Prevent invalid return length\n                 return(\' \');\n             }\n \t    /* 1-byte code */\n@@ -497,18 +487,10 @@\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +516,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -557,10 +532,11 @@\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n-    *len = 1;\n+    *len = 1;  // Prevent returning the length of incorrect characters\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 64, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:496:6'}, {'diff': '@@ -411,104 +411,87 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n-\treturn(0);\n+        return(0);\n \n     if (ctxt->token != 0) {\n-\t*len = 0;\n-\treturn(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n-                cur = ctxt->input->cur;\n-            }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n-\n-\t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        const unsigned char *cur = ctxt->input->cur;\n+        unsigned char c;\n+        unsigned int val;\n+\n+        c = *cur;\n+        if (cur < ctxt->input->end) {  // Check if we are within bounds\n+            if (c & 0x80) {\n+                if (cur[1] == 0) {\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if ((cur[1] & 0xc0) != 0x80)\n+                    goto encoding_error;\n+                if ((c & 0xe0) == 0xe0) {\n+                    if (cur[2] == 0) {\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n-\t\t    *len = 4;\n-\t\t    val = (cur[0] & 0x7) << 18;\n-\t\t    val |= (cur[1] & 0x3f) << 12;\n-\t\t    val |= (cur[2] & 0x3f) << 6;\n-\t\t    val |= cur[3] & 0x3f;\n-\t\t} else {\n-\t\t  /* 3-byte code */\n-\t\t    *len = 3;\n-\t\t    val = (cur[0] & 0xf) << 12;\n-\t\t    val |= (cur[1] & 0x3f) << 6;\n-\t\t    val |= cur[2] & 0x3f;\n-\t\t}\n-\t    } else {\n-\t      /* 2-byte code */\n-\t\t*len = 2;\n-\t\tval = (cur[0] & 0x1f) << 6;\n-\t\tval |= cur[1] & 0x3f;\n-\t    }\n-\t    if (!IS_CHAR(val)) {\n-\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n-\t    }\n-\t    return(val);\n-\t} else {\n-            if ((*ctxt->input->cur == 0) &&\n-                (ctxt->input->cur < ctxt->input->end)) {\n+                    if ((cur[2] & 0xc0) != 0x80)\n+                        goto encoding_error;\n+                    if ((c & 0xf0) == 0xf0) {\n+                        if (cur[3] == 0) {\n+                            xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                            cur = ctxt->input->cur;\n+                        }\n+                        if (((c & 0xf8) != 0xf0) ||\n+                            ((cur[3] & 0xc0) != 0x80))\n+                            goto encoding_error;\n+                        /* 4-byte code */\n+                        *len = 4;\n+                        val = (cur[0] & 0x7) << 18;\n+                        val |= (cur[1] & 0x3f) << 12;\n+                        val |= (cur[2] & 0x3f) << 6;\n+                        val |= cur[3] & 0x3f;\n+                    } else {\n+                        /* 3-byte code */\n+                        *len = 3;\n+                        val = (cur[0] & 0xf) << 12;\n+                        val |= (cur[1] & 0x3f) << 6;\n+                        val |= cur[2] & 0x3f;\n+                    }\n+                } else {\n+                    /* 2-byte code */\n+                    *len = 2;\n+                    val = (cur[0] & 0x1f) << 6;\n+                    val |= cur[1] & 0x3f;\n+                }\n+                if (!IS_CHAR(val)) {\n                     htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+                                    "Char 0x%X out of allowed range\\n", val);\n+                }\n+                return(val);\n+            } else {\n+                if ((*ctxt->input->cur == 0) &&\n+                    (ctxt->input->cur < ctxt->input->end)) {\n+                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                    "Char 0x%X out of allowed range\\n", 0);\n+                    *len = 1;\n+                    return(\' \');\n+                }\n+                /* 1-byte code */\n                 *len = 1;\n-                return(\' \');\n+                return((int) *ctxt->input->cur);\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n-\t}\n+        }\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n-\treturn((int) *ctxt->input->cur);\n+        return((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,26 +517,19 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n-\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n-\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n-\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n-\t} else {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n-\t}\n-\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-\t\t     "Input is not proper UTF-8, indicate encoding !\\n",\n-\t\t     BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n+                     ctxt->input->cur[0], ctxt->input->cur[1],\n+                     ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                     "Input is not proper UTF-8, indicate encoding !\\n",\n+                     BAD_CAST buffer, NULL);\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n@@ -561,6 +537,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 65, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:440:2'}, {'diff': '@@ -411,106 +411,90 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n-\treturn(0);\n+        return(0);\n \n     if (ctxt->token != 0) {\n-\t*len = 0;\n-\treturn(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n-                cur = ctxt->input->cur;\n-            }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n-\n-\t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        const unsigned char *cur = ctxt->input->cur;\n+        unsigned char c;\n+        unsigned int val;\n+\n+        c = *cur;\n+        if (cur < ctxt->input->end) { // Added check for buffer limits\n+            if (c & 0x80) {\n+                if (cur[1] == 0) {\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if ((cur[1] & 0xc0) != 0x80)\n+                    goto encoding_error;\n+                if ((c & 0xe0) == 0xe0) {\n+                    if (cur[2] == 0) {\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n-\t\t    *len = 4;\n-\t\t    val = (cur[0] & 0x7) << 18;\n-\t\t    val |= (cur[1] & 0x3f) << 12;\n-\t\t    val |= (cur[2] & 0x3f) << 6;\n-\t\t    val |= cur[3] & 0x3f;\n-\t\t} else {\n-\t\t  /* 3-byte code */\n-\t\t    *len = 3;\n-\t\t    val = (cur[0] & 0xf) << 12;\n-\t\t    val |= (cur[1] & 0x3f) << 6;\n-\t\t    val |= cur[2] & 0x3f;\n-\t\t}\n-\t    } else {\n-\t      /* 2-byte code */\n-\t\t*len = 2;\n-\t\tval = (cur[0] & 0x1f) << 6;\n-\t\tval |= cur[1] & 0x3f;\n-\t    }\n-\t    if (!IS_CHAR(val)) {\n-\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n-\t    }\n-\t    return(val);\n-\t} else {\n-            if ((*ctxt->input->cur == 0) &&\n-                (ctxt->input->cur < ctxt->input->end)) {\n+                    if ((cur[2] & 0xc0) != 0x80)\n+                        goto encoding_error;\n+                    if ((c & 0xf0) == 0xf0) {\n+                        if (cur[3] == 0) {\n+                            xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                            cur = ctxt->input->cur;\n+                        }\n+                        if (((c & 0xf8) != 0xf0) ||\n+                            ((cur[3] & 0xc0) != 0x80))\n+                            goto encoding_error;\n+                        *len = 4;\n+                        val = (cur[0] & 0x7) << 18;\n+                        val |= (cur[1] & 0x3f) << 12;\n+                        val |= (cur[2] & 0x3f) << 6;\n+                        val |= cur[3] & 0x3f;\n+                    } else {\n+                        *len = 3;\n+                        val = (cur[0] & 0xf) << 12;\n+                        val |= (cur[1] & 0x3f) << 6;\n+                        val |= cur[2] & 0x3f;\n+                    }\n+                } else {\n+                    *len = 2;\n+                    val = (cur[0] & 0x1f) << 6;\n+                    val |= cur[1] & 0x3f;\n+                }\n+                if (!IS_CHAR(val)) {\n+                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                    "Char 0x%X out of allowed range\\n", val);\n+                }\n+                return(val);\n+            } else {\n+                if ((*ctxt->input->cur == 0) &&\n+                    (ctxt->input->cur < ctxt->input->end)) {\n                     htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+                                    "Char 0x%X out of allowed range\\n", 0);\n+                    *len = 1;\n+                    return(\' \');\n+                }\n                 *len = 1;\n-                return(\' \');\n+                return((int) *ctxt->input->cur);\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n-\t}\n+        } else {\n+            htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                            "Char 0x%X out of allowed range\\n", 0);\n+            *len = 1;\n+            return(\' \');\n+        }\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n-\treturn((int) *ctxt->input->cur);\n+        return((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n-        xmlChar * guess;\n+        xmlChar *guess;\n         xmlCharEncodingHandlerPtr handler;\n \n         guess = htmlFindEncoding(ctxt);\n@@ -534,26 +518,19 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n-\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n-\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n-\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n-\t} else {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n-\t}\n-\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-\t\t     "Input is not proper UTF-8, indicate encoding !\\n",\n-\t\t     BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n+                     ctxt->input->cur[0], ctxt->input->cur[1],\n+                     ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                     "Input is not proper UTF-8, indicate encoding !\\n",\n+                     BAD_CAST buffer, NULL);\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n@@ -561,6 +538,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 66, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:440:2'}, {'diff': '@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,21 +422,16 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n \tconst unsigned char *cur = ctxt->input->cur;\n \tunsigned char c;\n \tunsigned int val;\n \n+\tif (cur >= ctxt->input->end) {\n+\t    htmlParseErr(ctxt, XML_ERR_INVALID_CHAR,\n+\t\t\t "Reading beyond input limits\\n", NULL);\n+\t    return 0;\n+\t}\n+\n \tc = *cur;\n \tif (c & 0x80) {\n \t    if (cur[1] == 0) {\n@@ -460,21 +456,18 @@\n \t\t    if (((c & 0xf8) != 0xf0) ||\n \t\t\t((cur[3] & 0xc0) != 0x80))\n \t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n \t\t    *len = 4;\n \t\t    val = (cur[0] & 0x7) << 18;\n \t\t    val |= (cur[1] & 0x3f) << 12;\n \t\t    val |= (cur[2] & 0x3f) << 6;\n \t\t    val |= cur[3] & 0x3f;\n \t\t} else {\n-\t\t  /* 3-byte code */\n \t\t    *len = 3;\n \t\t    val = (cur[0] & 0xf) << 12;\n \t\t    val |= (cur[1] & 0x3f) << 6;\n \t\t    val |= cur[2] & 0x3f;\n \t\t}\n \t    } else {\n-\t      /* 2-byte code */\n \t\t*len = 2;\n \t\tval = (cur[0] & 0x1f) << 6;\n \t\tval |= cur[1] & 0x3f;\n@@ -492,23 +485,14 @@\n                 *len = 1;\n                 return(\' \');\n             }\n-\t    /* 1-byte code */\n \t    *len = 1;\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +518,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -561,6 +538,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 67, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:440:2'}, {'diff': '@@ -411,106 +411,70 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n-\treturn(0);\n+        return(0);\n \n     if (ctxt->token != 0) {\n-\t*len = 0;\n-\treturn(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n-\tconst unsigned char *cur = ctxt->input->cur;\n-\tunsigned char c;\n-\tunsigned int val;\n-\n-\tc = *cur;\n-\tif (c & 0x80) {\n-\t    if (cur[1] == 0) {\n-\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n-                cur = ctxt->input->cur;\n-            }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n-\t    if ((c & 0xe0) == 0xe0) {\n-\n-\t\tif (cur[2] == 0) {\n-\t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n-                    cur = ctxt->input->cur;\n+        const unsigned char *cur = ctxt->input->cur;\n+        unsigned char c;\n+        unsigned int val;\n+\n+        c = *cur;\n+        if ((c & 0x80) && cur < ctxt->input->end) {  // Modified to check boundaries\n+            // Remove the inner bounds checks from below, as they are already being checked here.\n+            if ((cur[1] & 0xc0) != 0x80)\n+                goto encoding_error;\n+            if ((c & 0xe0) == 0xe0) {\n+                if ((cur[2] & 0xc0) != 0x80)\n+                    goto encoding_error;\n+                if ((c & 0xf0) == 0xf0) {\n+                    if ((cur[3] & 0xc0) != 0x80)\n+                        goto encoding_error;\n+                    /* 4-byte code */\n+                    *len = 4;\n+                    val = (cur[0] & 0x7) << 18;\n+                    val |= (cur[1] & 0x3f) << 12;\n+                    val |= (cur[2] & 0x3f) << 6;\n+                    val |= cur[3] & 0x3f;\n+                } else {\n+                    /* 3-byte code */\n+                    *len = 3;\n+                    val = (cur[0] & 0xf) << 12;\n+                    val |= (cur[1] & 0x3f) << 6;\n+                    val |= cur[2] & 0x3f;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n-\t\tif ((c & 0xf0) == 0xf0) {\n-\t\t    if (cur[3] == 0) {\n-\t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n-                        cur = ctxt->input->cur;\n-                    }\n-\t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n-\t\t    /* 4-byte code */\n-\t\t    *len = 4;\n-\t\t    val = (cur[0] & 0x7) << 18;\n-\t\t    val |= (cur[1] & 0x3f) << 12;\n-\t\t    val |= (cur[2] & 0x3f) << 6;\n-\t\t    val |= cur[3] & 0x3f;\n-\t\t} else {\n-\t\t  /* 3-byte code */\n-\t\t    *len = 3;\n-\t\t    val = (cur[0] & 0xf) << 12;\n-\t\t    val |= (cur[1] & 0x3f) << 6;\n-\t\t    val |= cur[2] & 0x3f;\n-\t\t}\n-\t    } else {\n-\t      /* 2-byte code */\n-\t\t*len = 2;\n-\t\tval = (cur[0] & 0x1f) << 6;\n-\t\tval |= cur[1] & 0x3f;\n-\t    }\n-\t    if (!IS_CHAR(val)) {\n-\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", val);\n-\t    }\n-\t    return(val);\n-\t} else {\n-            if ((*ctxt->input->cur == 0) &&\n-                (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+            } else {\n+                /* 2-byte code */\n+                *len = 2;\n+                val = (cur[0] & 0x1f) << 6;\n+                val |= cur[1] & 0x3f;\n+            }\n+            if (!IS_CHAR(val)) {\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                "Char 0x%X out of allowed range\\n", val);\n+            }\n+            return(val);\n+        } else {\n+            if (cur < ctxt->input->end) { // Check if within bounds\n+                /* 1-byte code */\n                 *len = 1;\n-                return(\' \');\n+                return((int) *cur);\n             }\n-\t    /* 1-byte code */\n-\t    *len = 1;\n-\t    return((int) *ctxt->input->cur);\n-\t}\n+        }\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n-\treturn((int) *ctxt->input->cur);\n+        return((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n-        xmlChar * guess;\n+        xmlChar *guess;\n         xmlCharEncodingHandlerPtr handler;\n \n         guess = htmlFindEncoding(ctxt);\n@@ -534,26 +498,19 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n-\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n-\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n-\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n-\t} else {\n-\t    snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n-\t}\n-\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-\t\t     "Input is not proper UTF-8, indicate encoding !\\n",\n-\t\t     BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n",\n+                     ctxt->input->cur[0], ctxt->input->cur[1],\n+                     ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, "Bytes: 0x%02X\\n", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                     "Input is not proper UTF-8, indicate encoding !\\n",\n+                     BAD_CAST buffer, NULL);\n     }\n \n     ctxt->charset = XML_CHAR_ENCODING_8859_1;\n@@ -561,6 +518,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 68, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:440:2'}, {'diff': '@@ -411,6 +411,7 @@\n  * Returns the current char value and its length\n  */\n \n+\n static int\n htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n     if (ctxt->instate == XML_PARSER_EOF)\n@@ -421,17 +422,6 @@\n \treturn(ctxt->token);\n     }\n     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-\t/*\n-\t * We are supposed to handle UTF8, check it\'s valid\n-\t * From rfc2044: encoding of the Unicode values on UTF-8:\n-\t *\n-\t * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-\t * 0000 0000-0000 007F   0xxxxxxx\n-\t * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-\t * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-\t *\n-\t * Check for the 0x110000 limit too\n-\t */\n \tconst unsigned char *cur = ctxt->input->cur;\n \tunsigned char c;\n \tunsigned int val;\n@@ -442,24 +432,32 @@\n \t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                 cur = ctxt->input->cur;\n             }\n-\t    if ((cur[1] & 0xc0) != 0x80)\n-\t\tgoto encoding_error;\n+\t    if ((cur[1] & 0xc0) != 0x80) {\n+\t        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+\t        return -1; // Error handling for invalid character\n+\t    }\n \t    if ((c & 0xe0) == 0xe0) {\n-\n \t\tif (cur[2] == 0) {\n \t\t    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-\t\tif ((cur[2] & 0xc0) != 0x80)\n-\t\t    goto encoding_error;\n+\t\tif ((cur[2] & 0xc0) != 0x80) {\n+\t\t    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+\t\t\t\t    "Char 0x%X out of allowed range\\n", 0);\n+\t\t    return -1; // Error handling for invalid character\n+\t\t}\n \t\tif ((c & 0xf0) == 0xf0) {\n \t\t    if (cur[3] == 0) {\n \t\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n \t\t    if (((c & 0xf8) != 0xf0) ||\n-\t\t\t((cur[3] & 0xc0) != 0x80))\n-\t\t\tgoto encoding_error;\n+\t\t\t((cur[3] & 0xc0) != 0x80)) {\n+\t\t\thtmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+\t\t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n+\t\t\treturn -1; // Error handling for invalid character\n+\t\t    }\n \t\t    /* 4-byte code */\n \t\t    *len = 4;\n \t\t    val = (cur[0] & 0x7) << 18;\n@@ -467,14 +465,14 @@\n \t\t    val |= (cur[2] & 0x3f) << 6;\n \t\t    val |= cur[3] & 0x3f;\n \t\t} else {\n-\t\t  /* 3-byte code */\n+\t\t    /* 3-byte code */\n \t\t    *len = 3;\n \t\t    val = (cur[0] & 0xf) << 12;\n \t\t    val |= (cur[1] & 0x3f) << 6;\n \t\t    val |= cur[2] & 0x3f;\n \t\t}\n \t    } else {\n-\t      /* 2-byte code */\n+\t\t/* 2-byte code */\n \t\t*len = 2;\n \t\tval = (cur[0] & 0x1f) << 6;\n \t\tval |= cur[1] & 0x3f;\n@@ -487,7 +485,7 @@\n \t} else {\n             if ((*ctxt->input->cur == 0) &&\n                 (ctxt->input->cur < ctxt->input->end)) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n \t\t\t\t"Char 0x%X out of allowed range\\n", 0);\n                 *len = 1;\n                 return(\' \');\n@@ -497,18 +495,10 @@\n \t    return((int) *ctxt->input->cur);\n \t}\n     }\n-    /*\n-     * Assume it\'s a fixed length encoding (1) with\n-     * a compatible encoding for the ASCII set, since\n-     * XML constructs only use < 128 chars\n-     */\n     *len = 1;\n     if ((int) *ctxt->input->cur < 0x80)\n \treturn((int) *ctxt->input->cur);\n \n-    /*\n-     * Humm this is bad, do an automatic flow conversion\n-     */\n     {\n         xmlChar * guess;\n         xmlCharEncodingHandlerPtr handler;\n@@ -534,13 +524,6 @@\n     return(xmlCurrentChar(ctxt, len));\n \n encoding_error:\n-    /*\n-     * If we detect an UTF8 error that probably mean that the\n-     * input encoding didn\'t get properly advertized in the\n-     * declaration header. Report the error and switch the encoding\n-     * to ISO-Latin-1 (if you don\'t like this policy, just declare the\n-     * encoding !)\n-     */\n     {\n         char buffer[150];\n \n@@ -561,6 +544,7 @@\n     return((int) *ctxt->input->cur);\n }\n \n+\n /**\n  * htmlSkipBlankChars:\n  * @ctxt:  the HTML parser context\n', 'id': 69, 'location': '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/HTMLparser.c:440:2'}]2025-02-02 13:03:13.070 | INFO     | scenario:validate:475 - beginning candidate patch evaluation with time limit: 45 minutes
2025-02-02 13:03:13.072 | DEBUG    | scenario:rebuild:369 - original environment: environ({'CONDA_SHLVL': '2', 'LC_ALL': 'C.UTF-8', 'LS_COLORS': 'rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:', 'LD_LIBRARY_PATH': '/opt/crashrepair/lib:/CrashRepair/lib:/klee/build/lib:', 'CONDA_EXE': '/root/anaconda3/bin/conda', 'LANG': 'C.UTF-8', 'TZ': 'Asia/Shanghai', 'HOSTNAME': 'fea22102047d', 'OLDPWD': '/orchestrator', 'CONDA_PREFIX': '/root/anaconda3/envs/CrashRepair', '_CE_M': '', 'CC': 'crepair-cc', 'LLVM_COMPILER': 'clang', 'CONDA_PREFIX_1': '/root/anaconda3', 'PWD': '/orchestrator/crashrepair', 'HOME': '/root', 'CONDA_PYTHON_EXE': '/root/anaconda3/bin/python', '_CE_CONDA': '', 'CONDA_PROMPT_MODIFIER': '(CrashRepair) ', 'CXX': 'crepair-cxx', 'TERM': 'xterm', 'SHLVL': '2', 'PYTHONPATH': '/usr/lib/python3.8/site-packages:', 'PATH': '/root/anaconda3/envs/CrashRepair/bin:/root/anaconda3/condabin:~/anaconda3/bin:/opt/crashrepair/bin:/CrashRepair/compiler:/klee/build/bin:/opt/llvm-6/bin:/klee/build/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin', 'CONDA_DEFAULT_ENV': 'CrashRepair', '_': '/root/anaconda3/envs/CrashRepair/bin/python'})
2025-02-02 13:03:13.072 | DEBUG    | scenario:rebuild:382 - injecting ghost function into CFLAGS during build: -lcrepair_ghost
2025-02-02 13:03:13.072 | DEBUG    | scenario:rebuild:398 - using environment: {'INJECT_CFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address', 'INJECT_CXXFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address', 'INJECT_LDFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address'}
2025-02-02 13:03:13.072 | DEBUG    | shell:__call__:41 - executing: make clean
Making clean in include
make[1]: Entering directory '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/include'
Making clean in libxml
make[2]: Entering directory '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/include/libxml'
rm -rf .libs _libs
rm -f *.lo
make[2]: Leaving directory '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/include/libxml'
make[2]: Entering directory '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/include'
rm -rf .libs _libs
rm -f *.lo
make[2]: Leaving directory '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/include'
make[1]: Leaving directory '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/include'
Making clean in .
make[1]: Entering directory '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src'
 rm -f xmllint xmlcatalog
test -z "runxmlconf.log test.out xml2Conf.sh *.gcda *.gcno *.res" || rm -f runxmlconf.log test.out xml2Conf.sh *.gcda *.gcno *.res
test -z "libxml2.la" || rm -f libxml2.la
rm -f ./so_locations
rm -rf .libs _libs
test -z "testdso.la" || rm -f testdso.la
rm -f ./so_locations
 rm -f testSchemas testRelax testSAX testHTML testXPath testURI testThreads testC14N testAutomata testRegexp testReader testapi testModule runtest runsuite testchar testdict runxmlconf testrecurse testlimits
rm -f *.o
rm -f *.lo
make[1]: Leaving directory '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src'
Making clean in doc
make[1]: Entering directory '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/doc'
Making clean in .
make[2]: Entering directory '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/doc'
rm -rf .libs _libs
rm -f *~ *.bak *.hierarchy *.signals *-unused.txt
rm -f *.lo
make[2]: Leaving directory '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/doc'
Making clean in devhelp
make[2]: Entering directory '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/doc/devhelp'
rm -rf .libs _libs
rm -f *.lo
make[2]: Leaving directory '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/doc/devhelp'
Making clean in examples
make[2]: Entering directory '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/doc/examples'
test -z "*.tmp" || rm -f *.tmp
rm -rf .libs _libs
test -f Makefile.am || rm -f test?.xml
 rm -f io1 io2 parse1 parse2 parse3 parse4 reader1 reader2 reader3 reader4 testWriter tree1 tree2 xpath1 xpath2
rm -f *.o
rm -f *.lo
make[2]: Leaving directory '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/doc/examples'
make[1]: Leaving directory '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/doc'
Making clean in example
make[1]: Entering directory '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/example'
rm -rf .libs _libs
 rm -f gjobread
rm -f *.o
rm -f *.lo
make[1]: Leaving directory '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/example'
Making clean in xstc
make[1]: Entering directory '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/xstc'
test -z "nist-test.py ms-test.py sun-test.py test.log" || rm -f nist-test.py ms-test.py sun-test.py test.log
rm -rf .libs _libs
rm -f *.lo
make[1]: Leaving directory '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/xstc'
Making clean in python
make[1]: Entering directory '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/python'
Making clean in .
make[2]: Entering directory '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/python'
test -z "*.pyc" || rm -f *.pyc
rm -rf .libs _libs
test -z "libxml2mod.la" || rm -f libxml2mod.la
rm -f ./so_locations
rm -f *.o
rm -f *.lo
make[2]: Leaving directory '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/python'
Making clean in tests
make[2]: Entering directory '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/python/tests'
test -z "core tmp.xml *.pyc" || rm -f core tmp.xml *.pyc
rm -rf .libs _libs
rm -f *.lo
make[2]: Leaving directory '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/python/tests'
make[1]: Leaving directory '/data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/python'
2025-02-02 13:03:13.172 | DEBUG    | shell:__call__:41 - executing: make CFLAGS="${INJECT_CFLAGS}" CXXFLAGS="${INJECT_CXXFLAGS}" LDFLAGS="${INJECT_LDFLAGS}" xmllint
  CC       xmllint.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       SAX.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       entities.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       encoding.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       error.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       parserInternals.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       parser.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       tree.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       hash.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       list.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       xmlIO.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       xmlmemory.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       uri.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       valid.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       xlink.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       HTMLparser.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       HTMLtree.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       debugXML.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       xpath.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
xpath.c:12406:28: warning: comparison of two values with different enumeration types ('xmlElementType' and 'xmlXPathTypeVal') [-Wenum-compare]
                    } else if (cur->type == type) {
                               ~~~~~~~~~ ^  ~~~~
1 warning generated.
xpath.c:12406:28: warning: comparison of two values with different enumeration types ('xmlElementType' and 'xmlXPathTypeVal') [-Wenum-compare]
                    } else if (cur->type == type) {
                               ~~~~~~~~~ ^  ~~~~
1 warning generated.
  CC       xpointer.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       xinclude.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       nanohttp.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
nanohttp.c:1002:67: warning: passing 'int *' to parameter of type 'socklen_t *' (aka 'unsigned int *') converts between pointers to integer types with different sign [-Wpointer-sign]
        if (getsockopt(s, SOL_SOCKET, SO_ERROR, (char *) &status, &len) <
                                                                  ^~~~
/usr/include/x86_64-linux-gnu/sys/socket.h:210:32: note: passing argument to parameter '__optlen' here
                       socklen_t *__restrict __optlen) __THROW;
                                             ^
nanohttp.c:1537:38: warning: while loop has empty body [-Wempty-body]
        while ( xmlNanoHTTPRecv(ctxt) > 0 ) ;
                                            ^
nanohttp.c:1537:38: note: put the semicolon on a separate line to silence this warning
2 warnings generated.
nanohttp.c:1002:67: warning: passing 'int *' to parameter of type 'socklen_t *' (aka 'unsigned int *') converts between pointers to integer types with different sign [-Wpointer-sign]
        if (getsockopt(s, SOL_SOCKET, SO_ERROR, (char *) &status, &len) <
                                                                  ^~~~
/usr/include/x86_64-linux-gnu/sys/socket.h:210:32: note: passing argument to parameter '__optlen' here
                       socklen_t *__restrict __optlen) __THROW;
                                             ^
nanohttp.c:1537:38: warning: while loop has empty body [-Wempty-body]
        while ( xmlNanoHTTPRecv(ctxt) > 0 ) ;
                                            ^
nanohttp.c:1537:38: note: put the semicolon on a separate line to silence this warning
2 warnings generated.
  CC       nanoftp.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
nanoftp.c:1479:66: warning: passing 'int *' to parameter of type 'socklen_t *' (aka 'unsigned int *') converts between pointers to integer types with different sign [-Wpointer-sign]
        getsockname(ctxt->dataFd, (struct sockaddr *) &dataAddr, &dataAddrLen);
                                                                 ^~~~~~~~~~~~
/usr/include/x86_64-linux-gnu/sys/socket.h:117:26: note: passing argument to parameter '__len' here
                        socklen_t *__restrict __len) __THROW;
                                              ^
nanoftp.c:1492:66: warning: passing 'int *' to parameter of type 'socklen_t *' (aka 'unsigned int *') converts between pointers to integer types with different sign [-Wpointer-sign]
        getsockname(ctxt->dataFd, (struct sockaddr *) &dataAddr, &dataAddrLen);
                                                                 ^~~~~~~~~~~~
/usr/include/x86_64-linux-gnu/sys/socket.h:117:26: note: passing argument to parameter '__len' here
                        socklen_t *__restrict __len) __THROW;
                                              ^
2 warnings generated.
nanoftp.c:1479:66: warning: passing 'int *' to parameter of type 'socklen_t *' (aka 'unsigned int *') converts between pointers to integer types with different sign [-Wpointer-sign]
        getsockname(ctxt->dataFd, (struct sockaddr *) &dataAddr, &dataAddrLen);
                                                                 ^~~~~~~~~~~~
/usr/include/x86_64-linux-gnu/sys/socket.h:117:26: note: passing argument to parameter '__len' here
                        socklen_t *__restrict __len) __THROW;
                                              ^
nanoftp.c:1492:66: warning: passing 'int *' to parameter of type 'socklen_t *' (aka 'unsigned int *') converts between pointers to integer types with different sign [-Wpointer-sign]
        getsockname(ctxt->dataFd, (struct sockaddr *) &dataAddr, &dataAddrLen);
                                                                 ^~~~~~~~~~~~
/usr/include/x86_64-linux-gnu/sys/socket.h:117:26: note: passing argument to parameter '__len' here
                        socklen_t *__restrict __len) __THROW;
                                              ^
2 warnings generated.
  CC       catalog.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       globals.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       threads.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       c14n.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       xmlstring.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       buf.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       xmlregexp.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       xmlschemas.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       xmlschemastypes.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       xmlunicode.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       xmlreader.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       relaxng.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       dict.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       SAX2.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       xmlwriter.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       legacy.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       chvalid.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       pattern.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       xmlsave.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       xmlmodule.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       schematron.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CC       xzlib.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CCLD     libxml2.la
ar: `u' modifier ignored since `D' is the default (see `U')
  CCLD     xmllint
2025-02-02 13:03:22.219 | INFO     | scenario:evaluate:635 - evaluating candidate patch #0:
@@ -411,104 +411,91 @@
  * Returns the current char value and its length
  */
 
+
 static int
 htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {
     if (ctxt->instate == XML_PARSER_EOF)
-	return(0);
+        return(0);
 
     if (ctxt->token != 0) {
-	*len = 0;
-	return(ctxt->token);
+        *len = 0;
+        return(ctxt->token);
     }
     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {
-	/*
-	 * We are supposed to handle UTF8, check it's valid
-	 * From rfc2044: encoding of the Unicode values on UTF-8:
-	 *
-	 * UCS-4 range (hex.)           UTF-8 octet sequence (binary)
-	 * 0000 0000-0000 007F   0xxxxxxx
-	 * 0000 0080-0000 07FF   110xxxxx 10xxxxxx
-	 * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx
-	 *
-	 * Check for the 0x110000 limit too
-	 */
-	const unsigned char *cur = ctxt->input->cur;
-	unsigned char c;
-	unsigned int val;
-
-	c = *cur;
-	if (c & 0x80) {
-	    if (cur[1] == 0) {
-		xmlParserInputGrow(ctxt->input, INPUT_CHUNK);
+        const unsigned char *cur = ctxt->input->cur;
+
+        if (cur >= ctxt->input->end)
+            return -1; // Prevent reading beyond the buffer
+
+        unsigned char c;
+        unsigned int val;
+
+        c = *cur;
+        if (c & 0x80) {
+            if (cur[1] == 0) {
+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);
                 cur = ctxt->input->cur;
             }
-	    if ((cur[1] & 0xc0) != 0x80)
-		goto encoding_error;
-	    if ((c & 0xe0) == 0xe0) {
+            if ((cur[1] & 0xc0) != 0x80)
+                goto encoding_error;
+            if ((c & 0xe0) == 0xe0) {
 
-		if (cur[2] == 0) {
-		    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);
+                if (cur[2] == 0) {
+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);
                     cur = ctxt->input->cur;
                 }
-		if ((cur[2] & 0xc0) != 0x80)
-		    goto encoding_error;
-		if ((c & 0xf0) == 0xf0) {
-		    if (cur[3] == 0) {
-			xmlParserInputGrow(ctxt->input, INPUT_CHUNK);
+                if ((cur[2] & 0xc0) != 0x80)
+                    goto encoding_error;
+                if ((c & 0xf0) == 0xf0) {
+                    if (cur[3] == 0) {
+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);
                         cur = ctxt->input->cur;
                     }
-		    if (((c & 0xf8) != 0xf0) ||
-			((cur[3] & 0xc0) != 0x80))
-			goto encoding_error;
-		    /* 4-byte code */
-		    *len = 4;
-		    val = (cur[0] & 0x7) << 18;
-		    val |= (cur[1] & 0x3f) << 12;
-		    val |= (cur[2] & 0x3f) << 6;
-		    val |= cur[3] & 0x3f;
-		} else {
-		  /* 3-byte code */
-		    *len = 3;
-		    val = (cur[0] & 0xf) << 12;
-		    val |= (cur[1] & 0x3f) << 6;
-		    val |= cur[2] & 0x3f;
-		}
-	    } else {
-	      /* 2-byte code */
-		*len = 2;
-		val = (cur[0] & 0x1f) << 6;
-		val |= cur[1] & 0x3f;
-	    }
-	    if (!IS_CHAR(val)) {
-	        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
-				"Char 0x%X out of allowed range\n", val);
-	    }
-	    return(val);
-	} else {
+                    if (((c & 0xf8) != 0xf0) ||
+                        ((cur[3] & 0xc0) != 0x80))
+                        goto encoding_error;
+                    /* 4-byte code */
+                    *len = 4;
+                    val = (cur[0] & 0x7) << 18;
+                    val |= (cur[1] & 0x3f) << 12;
+                    val |= (cur[2] & 0x3f) << 6;
+                    val |= cur[3] & 0x3f;
+                } else {
+                    /* 3-byte code */
+                    *len = 3;
+                    val = (cur[0] & 0xf) << 12;
+                    val |= (cur[1] & 0x3f) << 6;
+                    val |= cur[2] & 0x3f;
+                }
+            } else {
+                /* 2-byte code */
+                *len = 2;
+                val = (cur[0] & 0x1f) << 6;
+                val |= cur[1] & 0x3f;
+            }
+            if (!IS_CHAR(val)) {
+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
+                                "Char 0x%X out of allowed range\n", val);
+            }
+            return(val);
+        } else {
             if ((*ctxt->input->cur == 0) &&
                 (ctxt->input->cur < ctxt->input->end)) {
-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
-				"Char 0x%X out of allowed range\n", 0);
+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
+                                "Char 0x%X out of allowed range\n", 0);
                 *len = 1;
                 return(' ');
             }
-	    /* 1-byte code */
-	    *len = 1;
-	    return((int) *ctxt->input->cur);
-	}
+            /* 1-byte code */
+            *len = 1;
+            return((int) *ctxt->input->cur);
+        }
     }
-    /*
-     * Assume it's a fixed length encoding (1) with
-     * a compatible encoding for the ASCII set, since
-     * XML constructs only use < 128 chars
-     */
+    
     *len = 1;
     if ((int) *ctxt->input->cur < 0x80)
-	return((int) *ctxt->input->cur);
+        return((int) *ctxt->input->cur);
 
-    /*
-     * Humm this is bad, do an automatic flow conversion
-     */
     {
         xmlChar * guess;
         xmlCharEncodingHandlerPtr handler;
@@ -534,26 +521,19 @@
     return(xmlCurrentChar(ctxt, len));
 
 encoding_error:
-    /*
-     * If we detect an UTF8 error that probably mean that the
-     * input encoding didn't get properly advertized in the
-     * declaration header. Report the error and switch the encoding
-     * to ISO-Latin-1 (if you don't like this policy, just declare the
-     * encoding !)
-     */
     {
         char buffer[150];
 
-	if (ctxt->input->end - ctxt->input->cur >= 4) {
-	    snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",
-			    ctxt->input->cur[0], ctxt->input->cur[1],
-			    ctxt->input->cur[2], ctxt->input->cur[3]);
-	} else {
-	    snprintf(buffer, 149, "Bytes: 0x%02X\n", ctxt->input->cur[0]);
-	}
-	htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,
-		     "Input is not proper UTF-8, indicate encoding !\n",
-		     BAD_CAST buffer, NULL);
+        if (ctxt->input->end - ctxt->input->cur >= 4) {
+            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",
+                     ctxt->input->cur[0], ctxt->input->cur[1],
+                     ctxt->input->cur[2], ctxt->input->cur[3]);
+        } else {
+            snprintf(buffer, 149, "Bytes: 0x%02X\n", ctxt->input->cur[0]);
+        }
+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,
+                     "Input is not proper UTF-8, indicate encoding !\n",
+                     BAD_CAST buffer, NULL);
     }
 
     ctxt->charset = XML_CHAR_ENCODING_8859_1;
@@ -561,6 +541,7 @@
     return((int) *ctxt->input->cur);
 }
 
+
 /**
  * htmlSkipBlankChars:
  * @ctxt:  the HTML parser context

2025-02-02 13:03:22.231 | DEBUG    | scenario:rebuild:369 - original environment: environ({'CONDA_SHLVL': '2', 'LC_ALL': 'C.UTF-8', 'LS_COLORS': 'rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:', 'LD_LIBRARY_PATH': '/opt/crashrepair/lib:/CrashRepair/lib:/klee/build/lib:', 'CONDA_EXE': '/root/anaconda3/bin/conda', 'LANG': 'C.UTF-8', 'TZ': 'Asia/Shanghai', 'HOSTNAME': 'fea22102047d', 'OLDPWD': '/orchestrator', 'CONDA_PREFIX': '/root/anaconda3/envs/CrashRepair', '_CE_M': '', 'CC': 'crepair-cc', 'LLVM_COMPILER': 'clang', 'CONDA_PREFIX_1': '/root/anaconda3', 'PWD': '/orchestrator/crashrepair', 'HOME': '/root', 'CONDA_PYTHON_EXE': '/root/anaconda3/bin/python', '_CE_CONDA': '', 'CONDA_PROMPT_MODIFIER': '(CrashRepair) ', 'CXX': 'crepair-cxx', 'TERM': 'xterm', 'SHLVL': '2', 'PYTHONPATH': '/usr/lib/python3.8/site-packages:', 'PATH': '/root/anaconda3/envs/CrashRepair/bin:/root/anaconda3/condabin:~/anaconda3/bin:/opt/crashrepair/bin:/CrashRepair/compiler:/klee/build/bin:/opt/llvm-6/bin:/klee/build/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin', 'CONDA_DEFAULT_ENV': 'CrashRepair', '_': '/root/anaconda3/envs/CrashRepair/bin/python'})
2025-02-02 13:03:22.231 | DEBUG    | scenario:rebuild:382 - injecting ghost function into CFLAGS during build: -lcrepair_ghost
2025-02-02 13:03:22.231 | DEBUG    | scenario:rebuild:398 - using environment: {'INJECT_CFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address', 'INJECT_CXXFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address', 'INJECT_LDFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address'}
2025-02-02 13:03:22.231 | DEBUG    | shell:__call__:41 - executing: make CFLAGS="${INJECT_CFLAGS}" CXXFLAGS="${INJECT_CXXFLAGS}" LDFLAGS="${INJECT_LDFLAGS}" xmllint
  CC       HTMLparser.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CCLD     libxml2.la
ar: `u' modifier ignored since `D' is the default (see `U')
  CCLD     xmllint
2025-02-02 13:03:22.779 | DEBUG    | scenario:evaluate:655 - testing candidate #0 against test #crash...
2025-02-02 13:03:22.779 | DEBUG    | shell:__call__:41 - executing: /data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/xmllint --html /CrashRepair/experiments/vulnloc/libxml2/REDTEAM-CVE-2016-1833/exploit
2025-02-02 13:03:55.335 | INFO     | scenario:evaluate:676 - candidate patch #0 failed to compile
2025-02-02 13:03:55.908 | INFO     | scenario:evaluate:635 - evaluating candidate patch #1:
@@ -411,6 +411,7 @@
  * Returns the current char value and its length
  */
 
+
 static int
 htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {
     if (ctxt->instate == XML_PARSER_EOF)
@@ -421,21 +422,17 @@
 	return(ctxt->token);
     }
     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {
-	/*
-	 * We are supposed to handle UTF8, check it's valid
-	 * From rfc2044: encoding of the Unicode values on UTF-8:
-	 *
-	 * UCS-4 range (hex.)           UTF-8 octet sequence (binary)
-	 * 0000 0000-0000 007F   0xxxxxxx
-	 * 0000 0080-0000 07FF   110xxxxx 10xxxxxx
-	 * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx
-	 *
-	 * Check for the 0x110000 limit too
-	 */
 	const unsigned char *cur = ctxt->input->cur;
 	unsigned char c;
 	unsigned int val;
 
+	// Ensure that the pointer 'cur' does not go beyond the input limits
+	if (cur >= ctxt->input->end) {
+	    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR, "Input pointer is out of bounds\n", 0);
+	    *len = 1;
+	    return(' ');
+	}
+
 	c = *cur;
 	if (c & 0x80) {
 	    if (cur[1] == 0) {
@@ -497,18 +494,10 @@
 	    return((int) *ctxt->input->cur);
 	}
     }
-    /*
-     * Assume it's a fixed length encoding (1) with
-     * a compatible encoding for the ASCII set, since
-     * XML constructs only use < 128 chars
-     */
     *len = 1;
     if ((int) *ctxt->input->cur < 0x80)
 	return((int) *ctxt->input->cur);
 
-    /*
-     * Humm this is bad, do an automatic flow conversion
-     */
     {
         xmlChar * guess;
         xmlCharEncodingHandlerPtr handler;
@@ -534,13 +523,6 @@
     return(xmlCurrentChar(ctxt, len));
 
 encoding_error:
-    /*
-     * If we detect an UTF8 error that probably mean that the
-     * input encoding didn't get properly advertized in the
-     * declaration header. Report the error and switch the encoding
-     * to ISO-Latin-1 (if you don't like this policy, just declare the
-     * encoding !)
-     */
     {
         char buffer[150];
 
@@ -561,6 +543,7 @@
     return((int) *ctxt->input->cur);
 }
 
+
 /**
  * htmlSkipBlankChars:
  * @ctxt:  the HTML parser context

2025-02-02 13:03:55.957 | DEBUG    | scenario:rebuild:369 - original environment: environ({'CONDA_SHLVL': '2', 'LC_ALL': 'C.UTF-8', 'LS_COLORS': 'rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:', 'LD_LIBRARY_PATH': '/opt/crashrepair/lib:/CrashRepair/lib:/klee/build/lib:', 'CONDA_EXE': '/root/anaconda3/bin/conda', 'LANG': 'C.UTF-8', 'TZ': 'Asia/Shanghai', 'HOSTNAME': 'fea22102047d', 'OLDPWD': '/orchestrator', 'CONDA_PREFIX': '/root/anaconda3/envs/CrashRepair', '_CE_M': '', 'CC': 'crepair-cc', 'LLVM_COMPILER': 'clang', 'CONDA_PREFIX_1': '/root/anaconda3', 'PWD': '/orchestrator/crashrepair', 'HOME': '/root', 'CONDA_PYTHON_EXE': '/root/anaconda3/bin/python', '_CE_CONDA': '', 'CONDA_PROMPT_MODIFIER': '(CrashRepair) ', 'CXX': 'crepair-cxx', 'TERM': 'xterm', 'SHLVL': '2', 'PYTHONPATH': '/usr/lib/python3.8/site-packages:', 'PATH': '/root/anaconda3/envs/CrashRepair/bin:/root/anaconda3/condabin:~/anaconda3/bin:/opt/crashrepair/bin:/CrashRepair/compiler:/klee/build/bin:/opt/llvm-6/bin:/klee/build/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin', 'CONDA_DEFAULT_ENV': 'CrashRepair', '_': '/root/anaconda3/envs/CrashRepair/bin/python'})
2025-02-02 13:03:55.957 | DEBUG    | scenario:rebuild:382 - injecting ghost function into CFLAGS during build: -lcrepair_ghost
2025-02-02 13:03:55.957 | DEBUG    | scenario:rebuild:398 - using environment: {'INJECT_CFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address', 'INJECT_CXXFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address', 'INJECT_LDFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address'}
2025-02-02 13:03:55.957 | DEBUG    | shell:__call__:41 - executing: make CFLAGS="${INJECT_CFLAGS}" CXXFLAGS="${INJECT_CXXFLAGS}" LDFLAGS="${INJECT_LDFLAGS}" xmllint
  CC       HTMLparser.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CCLD     libxml2.la
ar: `u' modifier ignored since `D' is the default (see `U')
  CCLD     xmllint
2025-02-02 13:03:56.570 | DEBUG    | scenario:evaluate:655 - testing candidate #1 against test #crash...
2025-02-02 13:03:56.570 | DEBUG    | shell:__call__:41 - executing: /data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/xmllint --html /CrashRepair/experiments/vulnloc/libxml2/REDTEAM-CVE-2016-1833/exploit
2025-02-02 13:03:56.920 | DEBUG    | test:run:189 - test failed: unexpected exit code (actual: 139, expected: 0)
2025-02-02 13:03:56.920 | INFO     | scenario:evaluate:662 - candidate #1 fails test #crash
2025-02-02 13:03:56.963 | INFO     | scenario:evaluate:635 - evaluating candidate patch #2:
@@ -411,6 +411,7 @@
  * Returns the current char value and its length
  */
 
+
 static int
 htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {
     if (ctxt->instate == XML_PARSER_EOF)
@@ -421,18 +422,12 @@
 	return(ctxt->token);
     }
     if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {
-	/*
-	 * We are supposed to handle UTF8, check it's valid
-	 * From rfc2044: encoding of the Unicode values on UTF-8:
-	 *
-	 * UCS-4 range (hex.)           UTF-8 octet sequence (binary)
-	 * 0000 0000-0000 007F   0xxxxxxx
-	 * 0000 0080-0000 07FF   110xxxxx 10xxxxxx
-	 * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx
-	 *
-	 * Check for the 0x110000 limit too
-	 */
 	const unsigned char *cur = ctxt->input->cur;
+
+	if (cur >= ctxt->input->end) {
+	    return 0; // Prevent accessing past the end
+	}
+
 	unsigned char c;
 	unsigned int val;
 
@@ -460,21 +455,18 @@
 		    if (((c & 0xf8) != 0xf0) ||
 			((cur[3] & 0xc0) != 0x80))
 			goto encoding_error;
-		    /* 4-byte code */
 		    *len = 4;
 		    val = (cur[0] & 0x7) << 18;
 		    val |= (cur[1] & 0x3f) << 12;
 		    val |= (cur[2] & 0x3f) << 6;
 		    val |= cur[3] & 0x3f;
 		} else {
-		  /* 3-byte code */
 		    *len = 3;
 		    val = (cur[0] & 0xf) << 12;
 		    val |= (cur[1] & 0x3f) << 6;
 		    val |= cur[2] & 0x3f;
 		}
 	    } else {
-	      /* 2-byte code */
 		*len = 2;
 		val = (cur[0] & 0x1f) << 6;
 		val |= cur[1] & 0x3f;
@@ -485,30 +477,21 @@
 	    }
 	    return(val);
 	} else {
-            if ((*ctxt->input->cur == 0) &&
-                (ctxt->input->cur < ctxt->input->end)) {
+            if ((*cur == 0) &&
+                (cur < ctxt->input->end)) {
                     htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
 				"Char 0x%X out of allowed range\n", 0);
                 *len = 1;
                 return(' ');
             }
-	    /* 1-byte code */
 	    *len = 1;
-	    return((int) *ctxt->input->cur);
+	    return((int) *cur);
 	}
     }
-    /*
-     * Assume it's a fixed length encoding (1) with
-     * a compatible encoding for the ASCII set, since
-     * XML constructs only use < 128 chars
-     */
     *len = 1;
     if ((int) *ctxt->input->cur < 0x80)
 	return((int) *ctxt->input->cur);
 
-    /*
-     * Humm this is bad, do an automatic flow conversion
-     */
     {
         xmlChar * guess;
         xmlCharEncodingHandlerPtr handler;
@@ -534,13 +517,6 @@
     return(xmlCurrentChar(ctxt, len));
 
 encoding_error:
-    /*
-     * If we detect an UTF8 error that probably mean that the
-     * input encoding didn't get properly advertized in the
-     * declaration header. Report the error and switch the encoding
-     * to ISO-Latin-1 (if you don't like this policy, just declare the
-     * encoding !)
-     */
     {
         char buffer[150];
 
@@ -561,6 +537,7 @@
     return((int) *ctxt->input->cur);
 }
 
+
 /**
  * htmlSkipBlankChars:
  * @ctxt:  the HTML parser context

2025-02-02 13:03:57.003 | DEBUG    | scenario:rebuild:369 - original environment: environ({'CONDA_SHLVL': '2', 'LC_ALL': 'C.UTF-8', 'LS_COLORS': 'rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:', 'LD_LIBRARY_PATH': '/opt/crashrepair/lib:/CrashRepair/lib:/klee/build/lib:', 'CONDA_EXE': '/root/anaconda3/bin/conda', 'LANG': 'C.UTF-8', 'TZ': 'Asia/Shanghai', 'HOSTNAME': 'fea22102047d', 'OLDPWD': '/orchestrator', 'CONDA_PREFIX': '/root/anaconda3/envs/CrashRepair', '_CE_M': '', 'CC': 'crepair-cc', 'LLVM_COMPILER': 'clang', 'CONDA_PREFIX_1': '/root/anaconda3', 'PWD': '/orchestrator/crashrepair', 'HOME': '/root', 'CONDA_PYTHON_EXE': '/root/anaconda3/bin/python', '_CE_CONDA': '', 'CONDA_PROMPT_MODIFIER': '(CrashRepair) ', 'CXX': 'crepair-cxx', 'TERM': 'xterm', 'SHLVL': '2', 'PYTHONPATH': '/usr/lib/python3.8/site-packages:', 'PATH': '/root/anaconda3/envs/CrashRepair/bin:/root/anaconda3/condabin:~/anaconda3/bin:/opt/crashrepair/bin:/CrashRepair/compiler:/klee/build/bin:/opt/llvm-6/bin:/klee/build/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin', 'CONDA_DEFAULT_ENV': 'CrashRepair', '_': '/root/anaconda3/envs/CrashRepair/bin/python'})
2025-02-02 13:03:57.004 | DEBUG    | scenario:rebuild:382 - injecting ghost function into CFLAGS during build: -lcrepair_ghost
2025-02-02 13:03:57.004 | DEBUG    | scenario:rebuild:398 - using environment: {'INJECT_CFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address', 'INJECT_CXXFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address', 'INJECT_LDFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address'}
2025-02-02 13:03:57.004 | DEBUG    | shell:__call__:41 - executing: make CFLAGS="${INJECT_CFLAGS}" CXXFLAGS="${INJECT_CXXFLAGS}" LDFLAGS="${INJECT_LDFLAGS}" xmllint
  CC       HTMLparser.lo
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
  CCLD     libxml2.la
ar: `u' modifier ignored since `D' is the default (see `U')
  CCLD     xmllint
2025-02-02 13:03:57.597 | DEBUG    | scenario:evaluate:655 - testing candidate #2 against test #crash...
2025-02-02 13:03:57.598 | DEBUG    | shell:__call__:41 - executing: /data/vulnloc/libxml2/REDTEAM-CVE-2016-1833/src/xmllint --html /CrashRepair/experiments/vulnloc/libxml2/REDTEAM-CVE-2016-1833/exploit
2025-02-02 13:03:57.637 | INFO     | scenario:evaluate:659 - candidate #2 passes test #crash
2025-02-02 13:03:57.637 | INFO     | scenario:evaluate:674 - repair found! candidate #2 passes all tests
2025-02-02 13:03:57.677 | INFO     | scenario:validate:513 - saving successful patch #2...
2025-02-02 13:03:57.678 | INFO     | scenario:validate:520 - stopping search: patch was found

