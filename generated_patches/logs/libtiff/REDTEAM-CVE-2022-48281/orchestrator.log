2025-02-05 19:33:03.602 | INFO     | scenario:build:265 - loaded bug scenario: Scenario(subject='libtiff', name='REDTEAM-CVE-2022-48281', directory='/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281', build_directory='/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src', source_directory='/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src', tag_id='libtiff_REDTEAM-CVE-2022-48281', binary_path='/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop', clean_command='make clean', prebuild_command='./configure --enable-static --disable-shared --with-jbig-include-dir=/usr/bin/', build_command='make CFLAGS="${INJECT_CFLAGS}" CXXFLAGS="${INJECT_CXXFLAGS}" LDFLAGS="${INJECT_LDFLAGS}"', crashing_command='-Z 1:3,2:4 -e divided $POC /dev/null', crashing_input='/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/exploit', shell=Shell(cwd='/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281'), crash_test=Test(name='crash', command='/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop -Z 1:3,2:4 -e divided /data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/exploit /dev/null', expected_exit_code=0, expected_stdout=None, bad_output=None, asan_options=None, ubsan_options=None), sanitizer_flags='-fsanitize=address', additional_klee_flags='', expected_exit_code_for_crashing_input=0, should_terminate_early=True, fuzzer_tests=[], fuzzer=None, time_limit_minutes_validation=None, time_limit_seconds_single_test=30, time_limit_minutes_analysis=3600, halt_on_error=True, rebuild_for_validation=False, asan_options=None, ubsan_options=None, use_ghost_functions=True, acceptable_patch_limit=None)
2025-02-05 19:33:03.602 | INFO     | scenario:fuzz:426 - skipping fuzzing: fuzzer disabled
2025-02-05 19:33:03.603 | INFO     | analyzer:run:114 - running analysis with timeout: 60 minutes
2025-02-05 19:33:03.603 | DEBUG    | analyzer:write_config_to_file:88 - generated analyzer config:

dir_exp:/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281
tag_id:libtiff_REDTEAM-CVE-2022-48281
src_directory:/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src
binary_path:/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop
config_command:./configure --enable-static --disable-shared --with-jbig-include-dir=/usr/bin/
build_command:make CFLAGS="${INJECT_CFLAGS}" CXXFLAGS="${INJECT_CXXFLAGS}" LDFLAGS="${INJECT_LDFLAGS}"
test_input_list:-Z 1:3,2:4 -e divided $POC /dev/null
poc_list:/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/exploit
klee_flags:--link-llvm-lib=/CrashRepair/lib/libcrepair_proxy.bca 

2025-02-05 19:33:03.604 | DEBUG    | analyzer:run:124 - wrote analyzer config file to: /tmp/tmpu1621xg8
2025-02-05 19:33:03.604 | DEBUG    | shell:__call__:41 - executing: crepair --conf=/tmp/tmpu1621xg8
[K[1;36m
====================================================================================================

	Starting CRepair (C Crash Repair) 
====================================================================================================
[0m
[K[1;36m
	Loading Configurations
	__________________________________________________________________________________________
[0m
[K	[1;34mreading configuration values from arguments[0m
[K	[1;34mreading configuration values form configuration file[0m
[K	[1;37m	[file] /tmp/tmpu1621xg8[0m
[K	[1;34mupdating configuration values[0m
[K	[1;34mreading test configuration[0m
[K	[1;34mreading seed information[0m
[K	[1;37m	[config] stack size: 15000[0m
[K	[1;37m	[config] collecting stats: False[0m
[K	[1;37m	[config] number of tests: 1[0m
[K	[1;37m	[config] number of cores: 8[0m
[K	[1;37m	[config] klee concrete execution timeout: 600[0m
[K	[1;37m	[config] klee concolic execution timeout: 1200[0m
[K	[1;37m	[config] synthesize subset expressions: True[0m
[K	[1;37m	[config] window size for taint locations: 500[0m
[K	[1;37m	[config] window size for taint values: 500000[0m
[K[1;36m

	Analyzing Program
====================================================================================================
[0m
[K[1;36m
	Test Case #1
	__________________________________________________________________________________________
[0m
[K[1;36m
		Running Concrete Execution
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37mUsing Arguments: ['-Z', '1:3,2:4', '-e', 'divided', '$POC', '/dev/null'][0m
[K	[1;37m	[0m[K     [1;37mUsing Input File: /data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/exploit[0m
[K	[1;34m	building program[0m
[K	[1;34m		setting environment variables[0m
[K	[1;34m		cleaning files[0m
[K	[1;34m		configuring program[0m
[K	[1;34m		compiling program[0m
[K	[1;37m	[0m[K     [1;37mUsing Binary: /data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop[0m
[K	[1;34m	extracting bytecode[0m
[K	[1;34m	executing klee in concrete mode[0m
[K	[1;34m	extracting instruction trace[0m
[K	[1;37m		[note] program crashed[0m
[K	[1;34m	collecting tainted expressions[0m
[K	[1;34m	collecting tainted concrete values[0m
[K	[1;34m	collecting memory allocations/de-allocations[0m
[K	[1;34m	collecting pointer mapping[0m
[K	[1;34m	extracting crash information[0m
[K	[1;37m		[0m[K     [1;37m[info] crash type: memset error[0m
[K	[1;37m		[0m[K     [1;37m[info] crash location: /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/libtiff/tif_unix.c:362:2 [0m
[K	[1;37m		[0m[K     [1;37m[info] crash function: _TIFFmemset[0m
[K	[1;37m		[0m[K     [1;37m[info] crash address: -1[0m
[K	[1;37m		[0m[K     [1;37m[info] crash free constraint: ((@var(pointer, p) + @var(integer, c)) < ((base
                             @var(pointer, p)) + (size  @var(pointer, p))))[0m
[K	[1;37m		[0m[K     [1;37m[info] crash inducing variables: (base  @var(pointer, p)), (size  @var(pointer, p)), c,
                             p[0m
[K	[1;37m			[info] identified crash type: memset error[0m
[K[1;36m
		Running Concolic Execution
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37mUsing Arguments: ['-Z', '1:3,2:4', '-e', 'divided', '$POC', '/dev/null'][0m
[K	[1;37m	[0m[K     [1;37mUsing Input File: /data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/exploit[0m
[K	[1;34m	building program[0m
[K	[1;34m		setting environment variables[0m
[K	[1;34m		cleaning files[0m
[K	[1;34m		configuring program[0m
[K	[1;34m		compiling program[0m
[K	[1;34m	extracting bytecode[0m
[K	[1;34m	generating ktest file[0m
[K	[1;34m	executing klee in concolic mode[0m
[K	[1;34m	extracting largest symbolic path[0m
[K	[1;34m	extracting instruction trace[0m
[K	[1;37m		[note] program did not crash[0m
[K	[1;33m	[warning] Unknown Crash Reason: [0m
[K	[1;33m	[warning] taint analysis failed, using concrete values[0m
[K	[1;37m		[0m[K     [1;37m[info] Symbolic Mapping: p -> [bv874807296][0m
[K	[1;37m		[0m[K     [1;37m[info] Symbolic Mapping: (size  @var(pointer, p)) -> [][0m
[K	[1;37m		[0m[K     [1;37m[info] Symbolic Mapping: (base  @var(pointer, p)) -> [bv874807296][0m
[K	[1;37m		[0m[K     [1;37m[info] Symbolic Mapping: c -> [][0m
[K[1;36m

	Fix Localization
====================================================================================================
[0m
[K[1;36m
	Generating Fix Locations
	__________________________________________________________________________________________
[0m
[K	[1;34m	generating taint map[0m
[K	[1;37m		[0m[K     [1;37m[info] found 298 tainted locations[0m
[K	[1;34m		starting parallel computing[0m
[K	[1;34m		waiting for thread completion[0m
[K	[1;37m		[0m[K     [1;37m[info] found 2 source files[0m
[K	[1;37m		[0m[K     [1;37m[info] found 5 executed functions[0m
[K	[1;34m	generating possible fix locations[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] _TIFFmemset, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/libtiff/tif_unix.c:362:2[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] _TIFFmemset, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/libtiff/tif_unix.c:362:24[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] _TIFFmemset, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/libtiff/tif_unix.c:362:12[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] _TIFFmemset, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/libtiff/tif_unix.c:362:9[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] _TIFFmemset, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/libtiff/tif_unix.c:360:2[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] _TIFFmemset, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/libtiff/tif_unix.c:360:1[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] _TIFFmemset, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/libtiff/tif_unix.c:360:0[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7826:42[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7826:33[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7826:19[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7820:12[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7807:27[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7807:29[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7807:13[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7806:23[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7806:38[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7806:25[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7802:12[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7801:17[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7801:32[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7801:19[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7801:29[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7887:27[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7887:11[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7887:17[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7876:27[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7876:11[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7876:17[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7839:27[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7839:11[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7839:17[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7837:14[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7837:36[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7837:16[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7837:33[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7837:22[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7836:14[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7836:36[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7836:16[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7836:33[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7836:22[0m
[K	[1;37m		[0m[K     [1;37m[fix-loc] processCropSelections, /data/vulnloc/libtiff/REDTEAM-
                             CVE-2022-48281/src/tools/tiffcrop.c:7830:11[0m
[K[1;36m
	Localizing Constraints
	__________________________________________________________________________________________
[0m
[K	[1;33m	[warning] did not find top-level for ('/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff/tif_unix.c', 360, 0)[0m
[K	[1;33m	[warning] did not find top-level for ('/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff/tif_unix.c', 360, 2)[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff/tif_unix.c:362:2
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] ((@var(pointer, p) + @var(integer, c)) < (@var(pointer, crepair_base(p)) +
                        @var(integer, crepair_size(p))))[0m
[K	[1;33m	[warning] did not find top-level for ('/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff/tif_unix.c', 360, 0)[0m
[K	[1;33m	[warning] did not find top-level for ('/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff/tif_unix.c', 360, 2)[0m
[K	[1;33m	[warning] did not find top-level for ('/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff/tif_unix.c', 360, 0)[0m
[K	[1;33m	[warning] did not find top-level for ('/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff/tif_unix.c', 360, 2)[0m
[K	[1;33m	[warning] did not find top-level for ('/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff/tif_unix.c', 360, 0)[0m
[K	[1;33m	[warning] did not find top-level for ('/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff/tif_unix.c', 360, 2)[0m
[K	[1;33m	[warning] did not find top-level for ('/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff/tif_unix.c', 360, 0)[0m
[K	[1;33m	[warning] did not find top-level for ('/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff/tif_unix.c', 360, 2)[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7826:7
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] ((@var(pointer, crop_buff) + (3 + @var(integer, cropsize))) < (@var(pointer,
                        seg_buffs[i].buffer) + @var(integer, crepair_size(seg_buffs[i].buffer))))[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7887:7
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] ((@var(pointer, crop_buff) + (3 + @var(integer, cropsize))) < (@var(pointer,
                        seg_buffs[i].buffer) + @var(integer, crepair_size(seg_buffs[i].buffer))))[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7876:7
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] ((@var(pointer, crop_buff) + (3 + @var(integer, cropsize))) < (@var(pointer,
                        seg_buffs[i].buffer) + @var(integer, crepair_size(seg_buffs[i].buffer))))[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7839:7
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] ((@var(pointer, crop_buff) + (3 + @var(integer, cropsize))) < (@var(pointer,
                        seg_buffs[i].buffer) + @var(integer, crepair_size(seg_buffs[i].buffer))))[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7837:7
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] ((@var(pointer, crop_buff) + (3 + @var(integer, cropsize))) < (@var(pointer,
                        seg_buffs[i].buffer) + @var(integer, crepair_size(seg_buffs[i].buffer))))[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7836:7
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] ((@var(pointer, crop_buff) + (3 + @var(integer, cropsize))) < (@var(pointer,
                        seg_buffs[i].buffer) + @var(integer, crepair_size(seg_buffs[i].buffer))))[0m
[K[1;36m
		[fix-loc] /data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7830:11
		------------------------------------------------------------------------------------------
[0m
[K	[1;37m	[0m[K     [1;37m[constraint] ((@var(pointer, crop_buff) + (3 + @var(integer, cropsize))) < (@var(pointer,
                        seg_buffs[i].buffer) + @var(integer, crepair_size(seg_buffs[i].buffer))))[0m
[K[1;32m
	localization information saved at /CrashRepair/output/libtiff_REDTEAM-CVE-2022-48281/localization.json[0m
[K[1;32m
	state values saved at /CrashRepair/output/libtiff_REDTEAM-CVE-2022-48281/values/[0m
[K	[1;37m
Run time statistics:
-----------------------
[0m
[K	[1;37mStartup: 0.000 minutes[0m
[K	[1;37mBuild: 0 minutes[0m
[K	[1;37mConcrete Analysis: 5.791 minutes[0m
[K	[1;37mConcolic Analysis: 21.641 minutes[0m
[K	[1;37mTotal Analysis: 27.437 minutes[0m
[K	[1;37mLocalization: 0.619 minutes[0m
[K[1;32m
CRepair finished successfully after 28.057 minutes 
[0m
2025-02-05 20:01:07.901 | WARNING  | analyzer:run:143 - analysis output directory does not exist [/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/analysis]: creating...
2025-02-05 20:01:08.169 | INFO     | scenario:generate:454 - generating candidate repairs in implicated files: {'/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff/tif_unix.c', '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c'}
total_candidates:[{'diff': '@@ -356,12 +356,16 @@\n \treturn (realloc(p, (size_t) s));\n }\n \n+\n void\n _TIFFmemset(void* p, int v, tmsize_t c)\n {\n-\tmemset(p, v, (size_t) c);\n+    if (p != NULL && c > 0) {\n+        memset(p, v, (size_t) c);\n+    }\n }\n \n+\n void\n _TIFFmemcpy(void* d, const void* s, tmsize_t c)\n {\n', 'id': 0, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff/tif_unix.c:362:2'}, {'diff': '@@ -356,12 +356,18 @@\n \treturn (realloc(p, (size_t) s));\n }\n \n+\n void\n _TIFFmemset(void* p, int v, tmsize_t c)\n {\n-\tmemset(p, v, (size_t) c);\n+    if (p == NULL || c < 0) {\n+        // Handle error: invalid pointer or size\n+        return;\n+    }\n+    memset(p, v, (size_t) c);\n }\n \n+\n void\n _TIFFmemcpy(void* d, const void* s, tmsize_t c)\n {\n', 'id': 1, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff/tif_unix.c:362:2'}, {'diff': '@@ -356,12 +356,15 @@\n \treturn (realloc(p, (size_t) s));\n }\n \n+\n void\n _TIFFmemset(void* p, int v, tmsize_t c)\n {\n-\tmemset(p, v, (size_t) c);\n+    if (c <= 0 || p == NULL) return; // Check for valid parameters\n+    memset(p, v, (size_t) c);\n }\n \n+\n void\n _TIFFmemcpy(void* d, const void* s, tmsize_t c)\n {\n', 'id': 2, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff/tif_unix.c:362:2'}, {'diff': '@@ -356,12 +356,17 @@\n \treturn (realloc(p, (size_t) s));\n }\n \n+\n void\n _TIFFmemset(void* p, int v, tmsize_t c)\n {\n-\tmemset(p, v, (size_t) c);\n+    if (p == NULL || c <= 0) {\n+        return;\n+    }\n+    memset(p, v, (size_t) c);\n }\n \n+\n void\n _TIFFmemcpy(void* d, const void* s, tmsize_t c)\n {\n', 'id': 3, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff/tif_unix.c:362:2'}, {'diff': '@@ -356,12 +356,15 @@\n \treturn (realloc(p, (size_t) s));\n }\n \n+\n void\n _TIFFmemset(void* p, int v, tmsize_t c)\n {\n-\tmemset(p, v, (size_t) c);\n+    if (c < 0) return; // Add check for negative size\n+    memset(p, v, (size_t) c);\n }\n \n+\n void\n _TIFFmemcpy(void* d, const void* s, tmsize_t c)\n {\n', 'id': 4, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff/tif_unix.c:362:2'}, {'diff': '@@ -7678,236 +7678,232 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n-  {\n-  int       i;\n-  uint32_t    width, length, total_width, total_length;\n-  tsize_t   cropsize;\n-  unsigned  char *crop_buff = NULL;\n-  unsigned  char *read_buff = NULL;\n-  unsigned  char *next_buff = NULL;\n-  tsize_t   prev_cropsize = 0;\n+{\n+    int       i;\n+    uint32_t    width, length, total_width, total_length;\n+    tsize_t   cropsize;\n+    unsigned  char *crop_buff = NULL;\n+    unsigned  char *read_buff = NULL;\n+    unsigned  char *next_buff = NULL;\n+    tsize_t   prev_cropsize = 0;\n \n-  read_buff = *read_buff_ptr;\n+    read_buff = *read_buff_ptr;\n \n-  if (crop->img_mode == COMPOSITE_IMAGES)\n+    if (crop->img_mode == COMPOSITE_IMAGES)\n     {\n-    cropsize = crop->bufftotal;\n-    crop_buff = seg_buffs[0].buffer; \n-    if (!crop_buff)\n-      crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    else\n-      {\n-      prev_cropsize = seg_buffs[0].size;\n-      if (prev_cropsize < cropsize)\n-        {\n-        next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-        if (! next_buff)\n-          {\n-          _TIFFfree (crop_buff);\n-          crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          }\n+        cropsize = crop->bufftotal;\n+        crop_buff = seg_buffs[0].buffer; \n+        if (!crop_buff)\n+            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n         else\n-          crop_buff = next_buff;\n+        {\n+            prev_cropsize = seg_buffs[0].size;\n+            if (prev_cropsize < cropsize)\n+            {\n+                next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                if (!next_buff)\n+                {\n+                    _TIFFfree(crop_buff);\n+                    crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                }\n+                else\n+                    crop_buff = next_buff;\n+            }\n         }\n-      }\n \n-    if (!crop_buff)\n-      {\n-      TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-      return (-1);\n-      }\n- \n-    _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    seg_buffs[0].buffer = crop_buff;\n-    seg_buffs[0].size = cropsize;\n-\n-    /* Checks for matching width or length as required */\n-    if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n-      return (1);\n-\n-    if (crop->crop_mode & CROP_INVERT)\n-      {\n-      switch (crop->photometric)\n-        {\n-        /* Just change the interpretation */\n-        case PHOTOMETRIC_MINISWHITE:\n-        case PHOTOMETRIC_MINISBLACK:\n-\t     image->photometric = crop->photometric;\n-\t     break;\n-        case INVERT_DATA_ONLY:\n-        case INVERT_DATA_AND_TAG:\n-             if (invertImage(image->photometric, image->spp, image->bps, \n-                             crop->combined_width, crop->combined_length, crop_buff))\n-               {\n-               TIFFError("processCropSelections", \n-                         "Failed to invert colorspace for composite regions");\n-               return (-1);\n-               }\n-             if (crop->photometric == INVERT_DATA_AND_TAG)\n-               {\n-               switch (image->photometric)\n-                 {\n-                 case PHOTOMETRIC_MINISWHITE:\n- \t              image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t              break;\n-                 case PHOTOMETRIC_MINISBLACK:\n- \t              image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t              break;\n-                 default:\n-\t              break;\n-\t         }\n-\t       }\n-             break;\n-        default: break;\n+        if (!crop_buff)\n+        {\n+            TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+            return (-1);\n         }\n-      }\n \n-    /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n-    if (crop->crop_mode & CROP_MIRROR)\n-      {\n-      if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                      crop->combined_width, crop->combined_length, crop_buff))\n-        {\n-        TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n-\t         (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-        return (-1);\n-        }\n-      }\n+        _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+        seg_buffs[0].buffer = crop_buff;\n+        seg_buffs[0].size = cropsize;\n \n-    if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-      {\n-      if (rotateImage(crop->rotation, image, &crop->combined_width, \n-                      &crop->combined_length, &crop_buff))\n-        {\n-        TIFFError("processCropSelections", \n-                  "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n-        return (-1);\n-        }\n-      seg_buffs[0].buffer = crop_buff;\n-      seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n-                            * image->spp) * crop->combined_length; \n-      }\n-    }\n-  else  /* Separated Images */\n-    {\n-    total_width = total_length = 0;\n-    for (i = 0; i < crop->selections; i++)\n-      {\n+        /* Checks for matching width or length as required */\n+        if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n+            return (1);\n \n-        cropsize = crop->bufftotal;\n-      crop_buff = seg_buffs[i].buffer; \n-      if (!crop_buff)\n-        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      else\n-        {\n-        prev_cropsize = seg_buffs[0].size;\n-        if (prev_cropsize < cropsize)\n-          {\n-          next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          if (! next_buff)\n+        if (crop->crop_mode & CROP_INVERT)\n+        {\n+            switch (crop->photometric)\n             {\n-            _TIFFfree (crop_buff);\n-            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            case PHOTOMETRIC_MINISWHITE:\n+            case PHOTOMETRIC_MINISBLACK:\n+                image->photometric = crop->photometric;\n+                break;\n+            case INVERT_DATA_ONLY:\n+            case INVERT_DATA_AND_TAG:\n+                if (invertImage(image->photometric, image->spp, image->bps, \n+                                crop->combined_width, crop->combined_length, crop_buff))\n+                {\n+                    TIFFError("processCropSelections", \n+                              "Failed to invert colorspace for composite regions");\n+                    return (-1);\n+                }\n+                if (crop->photometric == INVERT_DATA_AND_TAG)\n+                {\n+                    switch (image->photometric)\n+                    {\n+                    case PHOTOMETRIC_MINISWHITE:\n+                        image->photometric = PHOTOMETRIC_MINISBLACK;\n+                        break;\n+                    case PHOTOMETRIC_MINISBLACK:\n+                        image->photometric = PHOTOMETRIC_MINISWHITE;\n+                        break;\n+                    default:\n+                        break;\n+                    }\n+                }\n+                break;\n+            default: break;\n             }\n-          else\n-            crop_buff = next_buff;\n-          }\n         }\n \n-      if (!crop_buff)\n+        /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n+        if (crop->crop_mode & CROP_MIRROR)\n         {\n-        TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-        return (-1);\n+            if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                            crop->combined_width, crop->combined_length, crop_buff))\n+            {\n+                TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n+                           (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                return (-1);\n+            }\n         }\n- \n-      _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      seg_buffs[i].buffer = crop_buff;\n-      seg_buffs[i].size = cropsize;\n \n-      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+        if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n         {\n-\tTIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n-        return (-1);\n-        }\n-    \n-      width  = crop->regionlist[i].width;\n-      length = crop->regionlist[i].length;\n-\n-      if (crop->crop_mode & CROP_INVERT)\n-        {\n-        switch (crop->photometric)\n-          {\n-          /* Just change the interpretation */\n-          case PHOTOMETRIC_MINISWHITE:\n-          case PHOTOMETRIC_MINISBLACK:\n-\t       image->photometric = crop->photometric;\n-\t       break;\n-          case INVERT_DATA_ONLY:\n-          case INVERT_DATA_AND_TAG:\n-               if (invertImage(image->photometric, image->spp, image->bps, \n-                               width, length, crop_buff))\n-                 {\n-                 TIFFError("processCropSelections", \n-                           "Failed to invert colorspace for region");\n-                 return (-1);\n-                 }\n-               if (crop->photometric == INVERT_DATA_AND_TAG)\n-                 {\n-                 switch (image->photometric)\n-                   {\n-                   case PHOTOMETRIC_MINISWHITE:\n- \t                image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t                break;\n-                   case PHOTOMETRIC_MINISBLACK:\n- \t                image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t                break;\n-                   default:\n-\t                break;\n-\t           }\n-\t         }\n-               break;\n-          default: break;\n-          }\n+            if (rotateImage(crop->rotation, image, &crop->combined_width, \n+                            &crop->combined_length, &crop_buff))\n+            {\n+                TIFFError("processCropSelections", \n+                          "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n+                return (-1);\n+            }\n+            seg_buffs[0].buffer = crop_buff;\n+            seg_buffs[0].size = (((crop->combined_width * image->bps + 7) / 8)\n+                                  * image->spp) * crop->combined_length; \n         }\n-\n-      if (crop->crop_mode & CROP_MIRROR)\n+    }\n+    else  /* Separated Images */\n+    {\n+        total_width = total_length = 0;\n+        for (i = 0; i < crop->selections; i++)\n         {\n-        if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                        width, length, crop_buff))\n-          {\n-          TIFFError("processCropSelections", "Failed to mirror crop region %s", \n-\t           (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-          return (-1);\n-          }\n-        }\n+            cropsize = crop->bufftotal;\n+            crop_buff = seg_buffs[i].buffer; \n+            if (!crop_buff)\n+                crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            else\n+            {\n+                prev_cropsize = seg_buffs[i].size;\n+                if (prev_cropsize < cropsize)\n+                {\n+                    next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    if (!next_buff)\n+                    {\n+                        _TIFFfree(crop_buff);\n+                        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    }\n+                    else\n+                        crop_buff = next_buff;\n+                }\n+            }\n \n-      if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-        {\n-          /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it schouldn\'t do here, when more than one section is processed. \n-           * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n-           */\n-\tif (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n-\t\t\t&crop->regionlist[i].length, &crop_buff))\n-          {\n-          TIFFError("processCropSelections", \n-                    "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n-          return (-1);\n-          }\n-        total_width  += crop->regionlist[i].width;\n-        total_length += crop->regionlist[i].length;\n-        crop->combined_width = total_width;\n-        crop->combined_length = total_length;\n-        seg_buffs[i].buffer = crop_buff;\n-        seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n-                               * image->spp) * crop->regionlist[i].length; \n-        }\n-      }  /* for crop->selections loop */\n+            if (!crop_buff)\n+            {\n+                TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+                return (-1);\n+            }\n+\n+            _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            seg_buffs[i].buffer = crop_buff;\n+            seg_buffs[i].size = cropsize;\n+\n+            if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+            {\n+                TIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n+                return (-1);\n+            }\n+\n+            width  = crop->regionlist[i].width;\n+            length = crop->regionlist[i].length;\n+\n+            if (crop->crop_mode & CROP_INVERT)\n+            {\n+                switch (crop->photometric)\n+                {\n+                case PHOTOMETRIC_MINISWHITE:\n+                case PHOTOMETRIC_MINISBLACK:\n+                    image->photometric = crop->photometric;\n+                    break;\n+                case INVERT_DATA_ONLY:\n+                case INVERT_DATA_AND_TAG:\n+                    if (invertImage(image->photometric, image->spp, image->bps, \n+                                    width, length, crop_buff))\n+                    {\n+                        TIFFError("processCropSelections", \n+                                  "Failed to invert colorspace for region");\n+                        return (-1);\n+                    }\n+                    if (crop->photometric == INVERT_DATA_AND_TAG)\n+                    {\n+                        switch (image->photometric)\n+                        {\n+                        case PHOTOMETRIC_MINISWHITE:\n+                            image->photometric = PHOTOMETRIC_MINISBLACK;\n+                            break;\n+                        case PHOTOMETRIC_MINISBLACK:\n+                            image->photometric = PHOTOMETRIC_MINISWHITE;\n+                            break;\n+                        default:\n+                            break;\n+                        }\n+                    }\n+                    break;\n+                default: break;\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_MIRROR)\n+            {\n+                if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                                width, length, crop_buff))\n+                {\n+                    TIFFError("processCropSelections", "Failed to mirror crop region %s", \n+                               (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                    return (-1);\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n+            {\n+                if (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n+                                &crop->regionlist[i].length, &crop_buff))\n+                {\n+                    TIFFError("processCropSelections", \n+                              "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n+                    return (-1);\n+                }\n+                total_width  += crop->regionlist[i].width;\n+                total_length += crop->regionlist[i].length;\n+                crop->combined_width = total_width;\n+                crop->combined_length = total_length;\n+                seg_buffs[i].buffer = crop_buff;\n+                seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7) / 8)\n+                                      * image->spp) * crop->regionlist[i].length; \n+            }\n+        }  /* for crop->selections loop */\n     }  /* Separated Images (else case) */\n-  return (0);\n-  } /* end processCropSelections */\n+    return (0);\n+} /* end processCropSelections */\n+\n \n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n', 'id': 5, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7826:7'}, {'diff': '@@ -7678,10 +7678,11 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n-  {\n+{\n   int       i;\n   uint32_t    width, length, total_width, total_length;\n   tsize_t   cropsize;\n@@ -7719,8 +7720,11 @@\n       TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n       return (-1);\n       }\n- \n-    _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+\n+    // Check if cropsize is valid before memset\n+    if (cropsize + NUM_BUFF_OVERSIZE_BYTES > 0) {\n+        _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+    }\n     seg_buffs[0].buffer = crop_buff;\n     seg_buffs[0].size = cropsize;\n \n@@ -7822,8 +7826,11 @@\n         TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n         return (-1);\n         }\n- \n-      _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+\n+      // Check if cropsize is valid before memset\n+      if (cropsize + NUM_BUFF_OVERSIZE_BYTES > 0) {\n+          _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+      }\n       seg_buffs[i].buffer = crop_buff;\n       seg_buffs[i].size = cropsize;\n \n@@ -7907,7 +7914,8 @@\n       }  /* for crop->selections loop */\n     }  /* Separated Images (else case) */\n   return (0);\n-  } /* end processCropSelections */\n+} /* end processCropSelections */\n+\n \n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n', 'id': 6, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7826:7'}, {'diff': '@@ -7678,236 +7678,253 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n-  {\n-  int       i;\n-  uint32_t    width, length, total_width, total_length;\n-  tsize_t   cropsize;\n-  unsigned  char *crop_buff = NULL;\n-  unsigned  char *read_buff = NULL;\n-  unsigned  char *next_buff = NULL;\n-  tsize_t   prev_cropsize = 0;\n+{\n+    int       i;\n+    uint32_t    width, length, total_width, total_length;\n+    tsize_t   cropsize;\n+    unsigned  char *crop_buff = NULL;\n+    unsigned  char *read_buff = NULL;\n+    unsigned  char *next_buff = NULL;\n+    tsize_t   prev_cropsize = 0;\n \n-  read_buff = *read_buff_ptr;\n+    read_buff = *read_buff_ptr;\n \n-  if (crop->img_mode == COMPOSITE_IMAGES)\n+    if (crop->img_mode == COMPOSITE_IMAGES)\n     {\n-    cropsize = crop->bufftotal;\n-    crop_buff = seg_buffs[0].buffer; \n-    if (!crop_buff)\n-      crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    else\n-      {\n-      prev_cropsize = seg_buffs[0].size;\n-      if (prev_cropsize < cropsize)\n-        {\n-        next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-        if (! next_buff)\n-          {\n-          _TIFFfree (crop_buff);\n-          crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          }\n+        cropsize = crop->bufftotal;\n+        crop_buff = seg_buffs[0].buffer; \n+        if (!crop_buff)\n+            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n         else\n-          crop_buff = next_buff;\n+        {\n+            prev_cropsize = seg_buffs[0].size;\n+            if (prev_cropsize < cropsize)\n+            {\n+                next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                if (!next_buff)\n+                {\n+                    _TIFFfree(crop_buff);\n+                    crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                }\n+                else\n+                    crop_buff = next_buff;\n+            }\n+        }\n+\n+        if (!crop_buff)\n+        {\n+            TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+            return (-1);\n+        }\n+\n+        /* Check for buffer size before memory setting */\n+        if (cropsize + NUM_BUFF_OVERSIZE_BYTES > MAX_BUFFER_SIZE) // Assuming MAX_BUFFER_SIZE is defined \n+        {\n+            TIFFError("processCropSelections", "Cropsize exceeds the allowable limits");\n+            _TIFFfree(crop_buff);\n+            return (-1);\n+        }\n+\n+        _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+        seg_buffs[0].buffer = crop_buff;\n+        seg_buffs[0].size = cropsize;\n+\n+        /* Checks for matching width or length as required */\n+        if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n+            return (1);\n+\n+        if (crop->crop_mode & CROP_INVERT)\n+        {\n+            switch (crop->photometric)\n+            {\n+                /* Just change the interpretation */\n+                case PHOTOMETRIC_MINISWHITE:\n+                case PHOTOMETRIC_MINISBLACK:\n+                    image->photometric = crop->photometric;\n+                    break;\n+                case INVERT_DATA_ONLY:\n+                case INVERT_DATA_AND_TAG:\n+                    if (invertImage(image->photometric, image->spp, image->bps, \n+                                    crop->combined_width, crop->combined_length, crop_buff))\n+                    {\n+                        TIFFError("processCropSelections", \n+                                  "Failed to invert colorspace for composite regions");\n+                        return (-1);\n+                    }\n+                    if (crop->photometric == INVERT_DATA_AND_TAG)\n+                    {\n+                        switch (image->photometric)\n+                        {\n+                            case PHOTOMETRIC_MINISWHITE:\n+                                image->photometric = PHOTOMETRIC_MINISBLACK;\n+                                break;\n+                            case PHOTOMETRIC_MINISBLACK:\n+                                image->photometric = PHOTOMETRIC_MINISWHITE;\n+                                break;\n+                            default:\n+                                break;\n+                        }\n+                    }\n+                    break;\n+                default: break;\n+            }\n         }\n-      }\n \n-    if (!crop_buff)\n-      {\n-      TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-      return (-1);\n-      }\n- \n-    _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    seg_buffs[0].buffer = crop_buff;\n-    seg_buffs[0].size = cropsize;\n-\n-    /* Checks for matching width or length as required */\n-    if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n-      return (1);\n-\n-    if (crop->crop_mode & CROP_INVERT)\n-      {\n-      switch (crop->photometric)\n-        {\n-        /* Just change the interpretation */\n-        case PHOTOMETRIC_MINISWHITE:\n-        case PHOTOMETRIC_MINISBLACK:\n-\t     image->photometric = crop->photometric;\n-\t     break;\n-        case INVERT_DATA_ONLY:\n-        case INVERT_DATA_AND_TAG:\n-             if (invertImage(image->photometric, image->spp, image->bps, \n-                             crop->combined_width, crop->combined_length, crop_buff))\n-               {\n-               TIFFError("processCropSelections", \n-                         "Failed to invert colorspace for composite regions");\n-               return (-1);\n-               }\n-             if (crop->photometric == INVERT_DATA_AND_TAG)\n-               {\n-               switch (image->photometric)\n-                 {\n-                 case PHOTOMETRIC_MINISWHITE:\n- \t              image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t              break;\n-                 case PHOTOMETRIC_MINISBLACK:\n- \t              image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t              break;\n-                 default:\n-\t              break;\n-\t         }\n-\t       }\n-             break;\n-        default: break;\n-        }\n-      }\n-\n-    /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n-    if (crop->crop_mode & CROP_MIRROR)\n-      {\n-      if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                      crop->combined_width, crop->combined_length, crop_buff))\n-        {\n-        TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n-\t         (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-        return (-1);\n-        }\n-      }\n-\n-    if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-      {\n-      if (rotateImage(crop->rotation, image, &crop->combined_width, \n-                      &crop->combined_length, &crop_buff))\n-        {\n-        TIFFError("processCropSelections", \n-                  "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n-        return (-1);\n-        }\n-      seg_buffs[0].buffer = crop_buff;\n-      seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n-                            * image->spp) * crop->combined_length; \n-      }\n+        /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n+        if (crop->crop_mode & CROP_MIRROR)\n+        {\n+            if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                            crop->combined_width, crop->combined_length, crop_buff))\n+            {\n+                TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n+                         (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                return (-1);\n+            }\n+        }\n+\n+        if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n+        {\n+            if (rotateImage(crop->rotation, image, &crop->combined_width, \n+                            &crop->combined_length, &crop_buff))\n+            {\n+                TIFFError("processCropSelections", \n+                          "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n+                return (-1);\n+            }\n+            seg_buffs[0].buffer = crop_buff;\n+            seg_buffs[0].size = (((crop->combined_width * image->bps + 7) / 8)\n+                                  * image->spp) * crop->combined_length; \n+        }\n     }\n-  else  /* Separated Images */\n+    else  /* Separated Images */\n     {\n-    total_width = total_length = 0;\n-    for (i = 0; i < crop->selections; i++)\n-      {\n+        total_width = total_length = 0;\n+        for (i = 0; i < crop->selections; i++)\n+        {\n+            cropsize = crop->bufftotal;\n+            crop_buff = seg_buffs[i].buffer; \n+            if (!crop_buff)\n+                crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            else\n+            {\n+                prev_cropsize = seg_buffs[0].size;\n+                if (prev_cropsize < cropsize)\n+                {\n+                    next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    if (!next_buff)\n+                    {\n+                        _TIFFfree(crop_buff);\n+                        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    }\n+                    else\n+                        crop_buff = next_buff;\n+                }\n+            }\n \n-        cropsize = crop->bufftotal;\n-      crop_buff = seg_buffs[i].buffer; \n-      if (!crop_buff)\n-        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      else\n-        {\n-        prev_cropsize = seg_buffs[0].size;\n-        if (prev_cropsize < cropsize)\n-          {\n-          next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          if (! next_buff)\n+            if (!crop_buff)\n             {\n-            _TIFFfree (crop_buff);\n-            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+                return (-1);\n             }\n-          else\n-            crop_buff = next_buff;\n-          }\n-        }\n-\n-      if (!crop_buff)\n-        {\n-        TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-        return (-1);\n-        }\n- \n-      _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      seg_buffs[i].buffer = crop_buff;\n-      seg_buffs[i].size = cropsize;\n-\n-      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n-        {\n-\tTIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n-        return (-1);\n-        }\n-    \n-      width  = crop->regionlist[i].width;\n-      length = crop->regionlist[i].length;\n-\n-      if (crop->crop_mode & CROP_INVERT)\n-        {\n-        switch (crop->photometric)\n-          {\n-          /* Just change the interpretation */\n-          case PHOTOMETRIC_MINISWHITE:\n-          case PHOTOMETRIC_MINISBLACK:\n-\t       image->photometric = crop->photometric;\n-\t       break;\n-          case INVERT_DATA_ONLY:\n-          case INVERT_DATA_AND_TAG:\n-               if (invertImage(image->photometric, image->spp, image->bps, \n-                               width, length, crop_buff))\n-                 {\n-                 TIFFError("processCropSelections", \n-                           "Failed to invert colorspace for region");\n-                 return (-1);\n-                 }\n-               if (crop->photometric == INVERT_DATA_AND_TAG)\n-                 {\n-                 switch (image->photometric)\n-                   {\n-                   case PHOTOMETRIC_MINISWHITE:\n- \t                image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t                break;\n-                   case PHOTOMETRIC_MINISBLACK:\n- \t                image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t                break;\n-                   default:\n-\t                break;\n-\t           }\n-\t         }\n-               break;\n-          default: break;\n-          }\n-        }\n-\n-      if (crop->crop_mode & CROP_MIRROR)\n-        {\n-        if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                        width, length, crop_buff))\n-          {\n-          TIFFError("processCropSelections", "Failed to mirror crop region %s", \n-\t           (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-          return (-1);\n-          }\n-        }\n-\n-      if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-        {\n-          /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it schouldn\'t do here, when more than one section is processed. \n-           * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n-           */\n-\tif (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n-\t\t\t&crop->regionlist[i].length, &crop_buff))\n-          {\n-          TIFFError("processCropSelections", \n-                    "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n-          return (-1);\n-          }\n-        total_width  += crop->regionlist[i].width;\n-        total_length += crop->regionlist[i].length;\n-        crop->combined_width = total_width;\n-        crop->combined_length = total_length;\n-        seg_buffs[i].buffer = crop_buff;\n-        seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n-                               * image->spp) * crop->regionlist[i].length; \n-        }\n-      }  /* for crop->selections loop */\n+\n+            /* Check for buffer size before memory setting */\n+            if (cropsize + NUM_BUFF_OVERSIZE_BYTES > MAX_BUFFER_SIZE) // Assuming MAX_BUFFER_SIZE is defined \n+            {\n+                TIFFError("processCropSelections", "Cropsize exceeds the allowable limits");\n+                _TIFFfree(crop_buff);\n+                return (-1);\n+            }\n+\n+            _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            seg_buffs[i].buffer = crop_buff;\n+            seg_buffs[i].size = cropsize;\n+\n+            if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+            {\n+                TIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n+                return (-1);\n+            }\n+\n+            width  = crop->regionlist[i].width;\n+            length = crop->regionlist[i].length;\n+\n+            if (crop->crop_mode & CROP_INVERT)\n+            {\n+                switch (crop->photometric)\n+                {\n+                    /* Just change the interpretation */\n+                    case PHOTOMETRIC_MINISWHITE:\n+                    case PHOTOMETRIC_MINISBLACK:\n+                        image->photometric = crop->photometric;\n+                        break;\n+                    case INVERT_DATA_ONLY:\n+                    case INVERT_DATA_AND_TAG:\n+                        if (invertImage(image->photometric, image->spp, image->bps, \n+                                        width, length, crop_buff))\n+                        {\n+                            TIFFError("processCropSelections", \n+                                      "Failed to invert colorspace for region");\n+                            return (-1);\n+                        }\n+                        if (crop->photometric == INVERT_DATA_AND_TAG)\n+                        {\n+                            switch (image->photometric)\n+                            {\n+                                case PHOTOMETRIC_MINISWHITE:\n+                                    image->photometric = PHOTOMETRIC_MINISBLACK;\n+                                    break;\n+                                case PHOTOMETRIC_MINISBLACK:\n+                                    image->photometric = PHOTOMETRIC_MINISWHITE;\n+                                    break;\n+                                default:\n+                                    break;\n+                            }\n+                        }\n+                        break;\n+                    default: break;\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_MIRROR)\n+            {\n+                if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                                width, length, crop_buff))\n+                {\n+                    TIFFError("processCropSelections", "Failed to mirror crop region %s", \n+                             (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                    return (-1);\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n+            {\n+                /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it shouldn\'t do here, when more than one section is processed. \n+                 * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n+                 */\n+                if (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n+                                &crop->regionlist[i].length, &crop_buff))\n+                {\n+                    TIFFError("processCropSelections", \n+                              "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n+                    return (-1);\n+                }\n+                total_width  += crop->regionlist[i].width;\n+                total_length += crop->regionlist[i].length;\n+                crop->combined_width = total_width;\n+                crop->combined_length = total_length;\n+                seg_buffs[i].buffer = crop_buff;\n+                seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7) / 8)\n+                                      * image->spp) * crop->regionlist[i].length; \n+            }\n+        }  /* for crop->selections loop */\n     }  /* Separated Images (else case) */\n-  return (0);\n-  } /* end processCropSelections */\n+    return (0);\n+} /* end processCropSelections */\n+\n \n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n', 'id': 7, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7826:7'}, {'diff': '@@ -7678,236 +7678,234 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n-  {\n-  int       i;\n-  uint32_t    width, length, total_width, total_length;\n-  tsize_t   cropsize;\n-  unsigned  char *crop_buff = NULL;\n-  unsigned  char *read_buff = NULL;\n-  unsigned  char *next_buff = NULL;\n-  tsize_t   prev_cropsize = 0;\n+{\n+    int       i;\n+    uint32_t    width, length, total_width, total_length;\n+    tsize_t   cropsize;\n+    unsigned  char *crop_buff = NULL;\n+    unsigned  char *read_buff = NULL;\n+    unsigned  char *next_buff = NULL;\n+    tsize_t   prev_cropsize = 0;\n \n-  read_buff = *read_buff_ptr;\n+    read_buff = *read_buff_ptr;\n \n-  if (crop->img_mode == COMPOSITE_IMAGES)\n+    if (crop->img_mode == COMPOSITE_IMAGES)\n     {\n-    cropsize = crop->bufftotal;\n-    crop_buff = seg_buffs[0].buffer; \n-    if (!crop_buff)\n-      crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    else\n-      {\n-      prev_cropsize = seg_buffs[0].size;\n-      if (prev_cropsize < cropsize)\n-        {\n-        next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-        if (! next_buff)\n-          {\n-          _TIFFfree (crop_buff);\n-          crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          }\n+        cropsize = crop->bufftotal;\n+        crop_buff = seg_buffs[0].buffer; \n+        if (!crop_buff)\n+            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n         else\n-          crop_buff = next_buff;\n+        {\n+            prev_cropsize = seg_buffs[0].size;\n+            if (prev_cropsize < cropsize)\n+            {\n+                next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                if (!next_buff)\n+                {\n+                    _TIFFfree(crop_buff);\n+                    crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                }\n+                else\n+                    crop_buff = next_buff;\n+            }\n         }\n-      }\n \n-    if (!crop_buff)\n-      {\n-      TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-      return (-1);\n-      }\n- \n-    _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    seg_buffs[0].buffer = crop_buff;\n-    seg_buffs[0].size = cropsize;\n-\n-    /* Checks for matching width or length as required */\n-    if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n-      return (1);\n-\n-    if (crop->crop_mode & CROP_INVERT)\n-      {\n-      switch (crop->photometric)\n-        {\n-        /* Just change the interpretation */\n-        case PHOTOMETRIC_MINISWHITE:\n-        case PHOTOMETRIC_MINISBLACK:\n-\t     image->photometric = crop->photometric;\n-\t     break;\n-        case INVERT_DATA_ONLY:\n-        case INVERT_DATA_AND_TAG:\n-             if (invertImage(image->photometric, image->spp, image->bps, \n-                             crop->combined_width, crop->combined_length, crop_buff))\n-               {\n-               TIFFError("processCropSelections", \n-                         "Failed to invert colorspace for composite regions");\n-               return (-1);\n-               }\n-             if (crop->photometric == INVERT_DATA_AND_TAG)\n-               {\n-               switch (image->photometric)\n-                 {\n-                 case PHOTOMETRIC_MINISWHITE:\n- \t              image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t              break;\n-                 case PHOTOMETRIC_MINISBLACK:\n- \t              image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t              break;\n-                 default:\n-\t              break;\n-\t         }\n-\t       }\n-             break;\n-        default: break;\n+        if (!crop_buff)\n+        {\n+            TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+            return (-1);\n         }\n-      }\n \n-    /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n-    if (crop->crop_mode & CROP_MIRROR)\n-      {\n-      if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                      crop->combined_width, crop->combined_length, crop_buff))\n-        {\n-        TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n-\t         (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-        return (-1);\n-        }\n-      }\n+        _TIFFmemset(crop_buff, 0, cropsize);  // Adjusted the size of memset\n+        seg_buffs[0].buffer = crop_buff;\n+        seg_buffs[0].size = cropsize;\n \n-    if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-      {\n-      if (rotateImage(crop->rotation, image, &crop->combined_width, \n-                      &crop->combined_length, &crop_buff))\n-        {\n-        TIFFError("processCropSelections", \n-                  "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n-        return (-1);\n-        }\n-      seg_buffs[0].buffer = crop_buff;\n-      seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n-                            * image->spp) * crop->combined_length; \n-      }\n-    }\n-  else  /* Separated Images */\n-    {\n-    total_width = total_length = 0;\n-    for (i = 0; i < crop->selections; i++)\n-      {\n+        /* Checks for matching width or length as required */\n+        if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n+            return (1);\n \n-        cropsize = crop->bufftotal;\n-      crop_buff = seg_buffs[i].buffer; \n-      if (!crop_buff)\n-        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      else\n-        {\n-        prev_cropsize = seg_buffs[0].size;\n-        if (prev_cropsize < cropsize)\n-          {\n-          next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          if (! next_buff)\n+        if (crop->crop_mode & CROP_INVERT)\n+        {\n+            switch (crop->photometric)\n             {\n-            _TIFFfree (crop_buff);\n-            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            /* Just change the interpretation */\n+            case PHOTOMETRIC_MINISWHITE:\n+            case PHOTOMETRIC_MINISBLACK:\n+                image->photometric = crop->photometric;\n+                break;\n+            case INVERT_DATA_ONLY:\n+            case INVERT_DATA_AND_TAG:\n+                if (invertImage(image->photometric, image->spp, image->bps, \n+                                crop->combined_width, crop->combined_length, crop_buff))\n+                {\n+                    TIFFError("processCropSelections", \n+                              "Failed to invert colorspace for composite regions");\n+                    return (-1);\n+                }\n+                if (crop->photometric == INVERT_DATA_AND_TAG)\n+                {\n+                    switch (image->photometric)\n+                    {\n+                    case PHOTOMETRIC_MINISWHITE:\n+                        image->photometric = PHOTOMETRIC_MINISBLACK;\n+                        break;\n+                    case PHOTOMETRIC_MINISBLACK:\n+                        image->photometric = PHOTOMETRIC_MINISWHITE;\n+                        break;\n+                    default:\n+                        break;\n+                    }\n+                }\n+                break;\n+            default: break;\n             }\n-          else\n-            crop_buff = next_buff;\n-          }\n         }\n \n-      if (!crop_buff)\n+        /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n+        if (crop->crop_mode & CROP_MIRROR)\n         {\n-        TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-        return (-1);\n+            if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                            crop->combined_width, crop->combined_length, crop_buff))\n+            {\n+                TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n+                          (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                return (-1);\n+            }\n         }\n- \n-      _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      seg_buffs[i].buffer = crop_buff;\n-      seg_buffs[i].size = cropsize;\n \n-      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+        if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n         {\n-\tTIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n-        return (-1);\n-        }\n-    \n-      width  = crop->regionlist[i].width;\n-      length = crop->regionlist[i].length;\n-\n-      if (crop->crop_mode & CROP_INVERT)\n-        {\n-        switch (crop->photometric)\n-          {\n-          /* Just change the interpretation */\n-          case PHOTOMETRIC_MINISWHITE:\n-          case PHOTOMETRIC_MINISBLACK:\n-\t       image->photometric = crop->photometric;\n-\t       break;\n-          case INVERT_DATA_ONLY:\n-          case INVERT_DATA_AND_TAG:\n-               if (invertImage(image->photometric, image->spp, image->bps, \n-                               width, length, crop_buff))\n-                 {\n-                 TIFFError("processCropSelections", \n-                           "Failed to invert colorspace for region");\n-                 return (-1);\n-                 }\n-               if (crop->photometric == INVERT_DATA_AND_TAG)\n-                 {\n-                 switch (image->photometric)\n-                   {\n-                   case PHOTOMETRIC_MINISWHITE:\n- \t                image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t                break;\n-                   case PHOTOMETRIC_MINISBLACK:\n- \t                image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t                break;\n-                   default:\n-\t                break;\n-\t           }\n-\t         }\n-               break;\n-          default: break;\n-          }\n+            if (rotateImage(crop->rotation, image, &crop->combined_width, \n+                            &crop->combined_length, &crop_buff))\n+            {\n+                TIFFError("processCropSelections", \n+                          "Failed to rotate composite regions by %" PRIu32 " degrees", crop->rotation);\n+                return (-1);\n+            }\n+            seg_buffs[0].buffer = crop_buff;\n+            seg_buffs[0].size = (((crop->combined_width * image->bps + 7) / 8)\n+                                  * image->spp) * crop->combined_length; \n         }\n-\n-      if (crop->crop_mode & CROP_MIRROR)\n+    }\n+    else  /* Separated Images */\n+    {\n+        total_width = total_length = 0;\n+        for (i = 0; i < crop->selections; i++)\n         {\n-        if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                        width, length, crop_buff))\n-          {\n-          TIFFError("processCropSelections", "Failed to mirror crop region %s", \n-\t           (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-          return (-1);\n-          }\n-        }\n+            cropsize = crop->bufftotal;\n+            crop_buff = seg_buffs[i].buffer; \n+            if (!crop_buff)\n+                crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            else\n+            {\n+                prev_cropsize = seg_buffs[0].size;\n+                if (prev_cropsize < cropsize)\n+                {\n+                    next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    if (!next_buff)\n+                    {\n+                        _TIFFfree(crop_buff);\n+                        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    }\n+                    else\n+                        crop_buff = next_buff;\n+                }\n+            }\n \n-      if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-        {\n-          /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it schouldn\'t do here, when more than one section is processed. \n-           * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n-           */\n-\tif (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n-\t\t\t&crop->regionlist[i].length, &crop_buff))\n-          {\n-          TIFFError("processCropSelections", \n-                    "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n-          return (-1);\n-          }\n-        total_width  += crop->regionlist[i].width;\n-        total_length += crop->regionlist[i].length;\n-        crop->combined_width = total_width;\n-        crop->combined_length = total_length;\n-        seg_buffs[i].buffer = crop_buff;\n-        seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n-                               * image->spp) * crop->regionlist[i].length; \n-        }\n-      }  /* for crop->selections loop */\n+            if (!crop_buff)\n+            {\n+                TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+                return (-1);\n+            }\n+\n+            _TIFFmemset(crop_buff, 0, cropsize);  // Adjusted the size of memset\n+            seg_buffs[i].buffer = crop_buff;\n+            seg_buffs[i].size = cropsize;\n+\n+            if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+            {\n+                TIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n+                return (-1);\n+            }\n+\n+            width  = crop->regionlist[i].width;\n+            length = crop->regionlist[i].length;\n+\n+            if (crop->crop_mode & CROP_INVERT)\n+            {\n+                switch (crop->photometric)\n+                {\n+                /* Just change the interpretation */\n+                case PHOTOMETRIC_MINISWHITE:\n+                case PHOTOMETRIC_MINISBLACK:\n+                    image->photometric = crop->photometric;\n+                    break;\n+                case INVERT_DATA_ONLY:\n+                case INVERT_DATA_AND_TAG:\n+                    if (invertImage(image->photometric, image->spp, image->bps, \n+                                    width, length, crop_buff))\n+                    {\n+                        TIFFError("processCropSelections", \n+                                  "Failed to invert colorspace for region");\n+                        return (-1);\n+                    }\n+                    if (crop->photometric == INVERT_DATA_AND_TAG)\n+                    {\n+                        switch (image->photometric)\n+                        {\n+                        case PHOTOMETRIC_MINISWHITE:\n+                            image->photometric = PHOTOMETRIC_MINISBLACK;\n+                            break;\n+                        case PHOTOMETRIC_MINISBLACK:\n+                            image->photometric = PHOTOMETRIC_MINISWHITE;\n+                            break;\n+                        default:\n+                            break;\n+                        }\n+                    }\n+                    break;\n+                default: break;\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_MIRROR)\n+            {\n+                if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                                width, length, crop_buff))\n+                {\n+                    TIFFError("processCropSelections", "Failed to mirror crop region %s", \n+                               (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                    return (-1);\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n+            {\n+                if (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n+                                &crop->regionlist[i].length, &crop_buff))\n+                {\n+                    TIFFError("processCropSelections", \n+                              "Failed to rotate crop region by %" PRIu16 " degrees", crop->rotation);\n+                    return (-1);\n+                }\n+            total_width  += crop->regionlist[i].width;\n+            total_length += crop->regionlist[i].length;\n+            crop->combined_width = total_width;\n+            crop->combined_length = total_length;\n+            seg_buffs[i].buffer = crop_buff;\n+            seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7) / 8)\n+                                  * image->spp) * crop->regionlist[i].length; \n+            }\n+        }  /* for crop->selections loop */\n     }  /* Separated Images (else case) */\n-  return (0);\n-  } /* end processCropSelections */\n+    return (0);\n+} /* end processCropSelections */\n+\n \n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n', 'id': 8, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7826:7'}, {'diff': '@@ -7678,236 +7678,235 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n-  {\n-  int       i;\n-  uint32_t    width, length, total_width, total_length;\n-  tsize_t   cropsize;\n-  unsigned  char *crop_buff = NULL;\n-  unsigned  char *read_buff = NULL;\n-  unsigned  char *next_buff = NULL;\n-  tsize_t   prev_cropsize = 0;\n+{\n+    int       i;\n+    uint32_t    width, length, total_width, total_length;\n+    tsize_t   cropsize;\n+    unsigned  char *crop_buff = NULL;\n+    unsigned  char *read_buff = NULL;\n+    unsigned  char *next_buff = NULL;\n+    tsize_t   prev_cropsize = 0;\n \n-  read_buff = *read_buff_ptr;\n+    read_buff = *read_buff_ptr;\n \n-  if (crop->img_mode == COMPOSITE_IMAGES)\n+    if (crop->img_mode == COMPOSITE_IMAGES)\n     {\n-    cropsize = crop->bufftotal;\n-    crop_buff = seg_buffs[0].buffer; \n-    if (!crop_buff)\n-      crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    else\n-      {\n-      prev_cropsize = seg_buffs[0].size;\n-      if (prev_cropsize < cropsize)\n-        {\n-        next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-        if (! next_buff)\n-          {\n-          _TIFFfree (crop_buff);\n-          crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          }\n+        cropsize = crop->bufftotal;\n+        crop_buff = seg_buffs[0].buffer; \n+        if (!crop_buff)\n+            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n         else\n-          crop_buff = next_buff;\n+        {\n+            prev_cropsize = seg_buffs[0].size;\n+            if (prev_cropsize < cropsize)\n+            {\n+                next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                if (!next_buff)\n+                {\n+                    _TIFFfree(crop_buff);\n+                    crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                }\n+                else\n+                    crop_buff = next_buff;\n+            }\n         }\n-      }\n \n-    if (!crop_buff)\n-      {\n-      TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-      return (-1);\n-      }\n- \n-    _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    seg_buffs[0].buffer = crop_buff;\n-    seg_buffs[0].size = cropsize;\n-\n-    /* Checks for matching width or length as required */\n-    if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n-      return (1);\n-\n-    if (crop->crop_mode & CROP_INVERT)\n-      {\n-      switch (crop->photometric)\n-        {\n-        /* Just change the interpretation */\n-        case PHOTOMETRIC_MINISWHITE:\n-        case PHOTOMETRIC_MINISBLACK:\n-\t     image->photometric = crop->photometric;\n-\t     break;\n-        case INVERT_DATA_ONLY:\n-        case INVERT_DATA_AND_TAG:\n-             if (invertImage(image->photometric, image->spp, image->bps, \n-                             crop->combined_width, crop->combined_length, crop_buff))\n-               {\n-               TIFFError("processCropSelections", \n-                         "Failed to invert colorspace for composite regions");\n-               return (-1);\n-               }\n-             if (crop->photometric == INVERT_DATA_AND_TAG)\n-               {\n-               switch (image->photometric)\n-                 {\n-                 case PHOTOMETRIC_MINISWHITE:\n- \t              image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t              break;\n-                 case PHOTOMETRIC_MINISBLACK:\n- \t              image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t              break;\n-                 default:\n-\t              break;\n-\t         }\n-\t       }\n-             break;\n-        default: break;\n+        if (!crop_buff)\n+        {\n+            TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+            return (-1);\n         }\n-      }\n \n-    /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n-    if (crop->crop_mode & CROP_MIRROR)\n-      {\n-      if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                      crop->combined_width, crop->combined_length, crop_buff))\n-        {\n-        TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n-\t         (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-        return (-1);\n-        }\n-      }\n+        _TIFFmemset(crop_buff, 0, cropsize); // Adjusted memset to remove potential oversize\n+        seg_buffs[0].buffer = crop_buff;\n+        seg_buffs[0].size = cropsize;\n \n-    if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-      {\n-      if (rotateImage(crop->rotation, image, &crop->combined_width, \n-                      &crop->combined_length, &crop_buff))\n-        {\n-        TIFFError("processCropSelections", \n-                  "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n-        return (-1);\n-        }\n-      seg_buffs[0].buffer = crop_buff;\n-      seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n-                            * image->spp) * crop->combined_length; \n-      }\n-    }\n-  else  /* Separated Images */\n-    {\n-    total_width = total_length = 0;\n-    for (i = 0; i < crop->selections; i++)\n-      {\n+        if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n+            return (1);\n \n-        cropsize = crop->bufftotal;\n-      crop_buff = seg_buffs[i].buffer; \n-      if (!crop_buff)\n-        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      else\n-        {\n-        prev_cropsize = seg_buffs[0].size;\n-        if (prev_cropsize < cropsize)\n-          {\n-          next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          if (! next_buff)\n+        if (crop->crop_mode & CROP_INVERT)\n+        {\n+            switch (crop->photometric)\n             {\n-            _TIFFfree (crop_buff);\n-            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                /* Just change the interpretation */\n+                case PHOTOMETRIC_MINISWHITE:\n+                case PHOTOMETRIC_MINISBLACK:\n+                    image->photometric = crop->photometric;\n+                    break;\n+                case INVERT_DATA_ONLY:\n+                case INVERT_DATA_AND_TAG:\n+                    if (invertImage(image->photometric, image->spp, image->bps, \n+                                    crop->combined_width, crop->combined_length, crop_buff))\n+                    {\n+                        TIFFError("processCropSelections", \n+                                  "Failed to invert colorspace for composite regions");\n+                        return (-1);\n+                    }\n+                    if (crop->photometric == INVERT_DATA_AND_TAG)\n+                    {\n+                        switch (image->photometric)\n+                        {\n+                            case PHOTOMETRIC_MINISWHITE:\n+                                image->photometric = PHOTOMETRIC_MINISBLACK;\n+                                break;\n+                            case PHOTOMETRIC_MINISBLACK:\n+                                image->photometric = PHOTOMETRIC_MINISWHITE;\n+                                break;\n+                            default:\n+                                break;\n+                        }\n+                    }\n+                    break;\n+                default: \n+                    break;\n             }\n-          else\n-            crop_buff = next_buff;\n-          }\n         }\n \n-      if (!crop_buff)\n+        /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n+        if (crop->crop_mode & CROP_MIRROR)\n         {\n-        TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-        return (-1);\n+            if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                            crop->combined_width, crop->combined_length, crop_buff))\n+            {\n+                TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n+                         (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                return (-1);\n+            }\n         }\n- \n-      _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      seg_buffs[i].buffer = crop_buff;\n-      seg_buffs[i].size = cropsize;\n \n-      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+        if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n         {\n-\tTIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n-        return (-1);\n-        }\n-    \n-      width  = crop->regionlist[i].width;\n-      length = crop->regionlist[i].length;\n-\n-      if (crop->crop_mode & CROP_INVERT)\n-        {\n-        switch (crop->photometric)\n-          {\n-          /* Just change the interpretation */\n-          case PHOTOMETRIC_MINISWHITE:\n-          case PHOTOMETRIC_MINISBLACK:\n-\t       image->photometric = crop->photometric;\n-\t       break;\n-          case INVERT_DATA_ONLY:\n-          case INVERT_DATA_AND_TAG:\n-               if (invertImage(image->photometric, image->spp, image->bps, \n-                               width, length, crop_buff))\n-                 {\n-                 TIFFError("processCropSelections", \n-                           "Failed to invert colorspace for region");\n-                 return (-1);\n-                 }\n-               if (crop->photometric == INVERT_DATA_AND_TAG)\n-                 {\n-                 switch (image->photometric)\n-                   {\n-                   case PHOTOMETRIC_MINISWHITE:\n- \t                image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t                break;\n-                   case PHOTOMETRIC_MINISBLACK:\n- \t                image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t                break;\n-                   default:\n-\t                break;\n-\t           }\n-\t         }\n-               break;\n-          default: break;\n-          }\n+            if (rotateImage(crop->rotation, image, &crop->combined_width, \n+                            &crop->combined_length, &crop_buff))\n+            {\n+                TIFFError("processCropSelections", \n+                          "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n+                return (-1);\n+            }\n+            seg_buffs[0].buffer = crop_buff;\n+            seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n+                                  * image->spp) * crop->combined_length; \n         }\n-\n-      if (crop->crop_mode & CROP_MIRROR)\n+    }\n+    else  /* Separated Images */\n+    {\n+        total_width = total_length = 0;\n+        for (i = 0; i < crop->selections; i++)\n         {\n-        if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                        width, length, crop_buff))\n-          {\n-          TIFFError("processCropSelections", "Failed to mirror crop region %s", \n-\t           (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-          return (-1);\n-          }\n-        }\n+            cropsize = crop->bufftotal;\n+            crop_buff = seg_buffs[i].buffer; \n+            if (!crop_buff)\n+                crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            else\n+            {\n+                prev_cropsize = seg_buffs[0].size;\n+                if (prev_cropsize < cropsize)\n+                {\n+                    next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    if (!next_buff)\n+                    {\n+                        _TIFFfree(crop_buff);\n+                        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    }\n+                    else\n+                        crop_buff = next_buff;\n+                }\n+            }\n \n-      if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-        {\n-          /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it schouldn\'t do here, when more than one section is processed. \n-           * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n-           */\n-\tif (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n-\t\t\t&crop->regionlist[i].length, &crop_buff))\n-          {\n-          TIFFError("processCropSelections", \n-                    "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n-          return (-1);\n-          }\n-        total_width  += crop->regionlist[i].width;\n-        total_length += crop->regionlist[i].length;\n-        crop->combined_width = total_width;\n-        crop->combined_length = total_length;\n-        seg_buffs[i].buffer = crop_buff;\n-        seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n-                               * image->spp) * crop->regionlist[i].length; \n-        }\n-      }  /* for crop->selections loop */\n+            if (!crop_buff)\n+            {\n+                TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+                return (-1);\n+            }\n+\n+            _TIFFmemset(crop_buff, 0, cropsize); // Adjusted memset to remove potential oversize\n+            seg_buffs[i].buffer = crop_buff;\n+            seg_buffs[i].size = cropsize;\n+\n+            if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+            {\n+                TIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n+                return (-1);\n+            }\n+            \n+            width  = crop->regionlist[i].width;\n+            length = crop->regionlist[i].length;\n+\n+            if (crop->crop_mode & CROP_INVERT)\n+            {\n+                switch (crop->photometric)\n+                {\n+                    /* Just change the interpretation */\n+                    case PHOTOMETRIC_MINISWHITE:\n+                    case PHOTOMETRIC_MINISBLACK:\n+                        image->photometric = crop->photometric;\n+                        break;\n+                    case INVERT_DATA_ONLY:\n+                    case INVERT_DATA_AND_TAG:\n+                        if (invertImage(image->photometric, image->spp, image->bps, \n+                                        width, length, crop_buff))\n+                        {\n+                            TIFFError("processCropSelections", \n+                                      "Failed to invert colorspace for region");\n+                            return (-1);\n+                        }\n+                        if (crop->photometric == INVERT_DATA_AND_TAG)\n+                        {\n+                            switch (image->photometric)\n+                            {\n+                                case PHOTOMETRIC_MINISWHITE:\n+                                    image->photometric = PHOTOMETRIC_MINISBLACK;\n+                                    break;\n+                                case PHOTOMETRIC_MINISBLACK:\n+                                    image->photometric = PHOTOMETRIC_MINISWHITE;\n+                                    break;\n+                                default:\n+                                    break;\n+                            }\n+                        }\n+                        break;\n+                    default: \n+                        break;\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_MIRROR)\n+            {\n+                if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                                width, length, crop_buff))\n+                {\n+                    TIFFError("processCropSelections", "Failed to mirror crop region %s", \n+                             (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                    return (-1);\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n+            {\n+                if (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n+                                &crop->regionlist[i].length, &crop_buff))\n+                {\n+                    TIFFError("processCropSelections", \n+                              "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n+                    return (-1);\n+                }\n+            total_width  += crop->regionlist[i].width;\n+            total_length += crop->regionlist[i].length;\n+            crop->combined_width = total_width;\n+            crop->combined_length = total_length;\n+            seg_buffs[i].buffer = crop_buff;\n+            seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n+                                  * image->spp) * crop->regionlist[i].length; \n+            }\n+        }  /* for crop->selections loop */\n     }  /* Separated Images (else case) */\n-  return (0);\n-  } /* end processCropSelections */\n+    return (0);\n+} /* end processCropSelections */\n+\n \n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n', 'id': 9, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7826:7'}, {'diff': '@@ -7678,236 +7678,242 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n-  {\n-  int       i;\n-  uint32_t    width, length, total_width, total_length;\n-  tsize_t   cropsize;\n-  unsigned  char *crop_buff = NULL;\n-  unsigned  char *read_buff = NULL;\n-  unsigned  char *next_buff = NULL;\n-  tsize_t   prev_cropsize = 0;\n+{\n+    int       i;\n+    uint32_t    width, length, total_width, total_length;\n+    tsize_t   cropsize;\n+    unsigned  char *crop_buff = NULL;\n+    unsigned  char *read_buff = NULL;\n+    unsigned  char *next_buff = NULL;\n+    tsize_t   prev_cropsize = 0;\n \n-  read_buff = *read_buff_ptr;\n+    read_buff = *read_buff_ptr;\n \n-  if (crop->img_mode == COMPOSITE_IMAGES)\n+    if (crop->img_mode == COMPOSITE_IMAGES)\n     {\n-    cropsize = crop->bufftotal;\n-    crop_buff = seg_buffs[0].buffer; \n-    if (!crop_buff)\n-      crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    else\n-      {\n-      prev_cropsize = seg_buffs[0].size;\n-      if (prev_cropsize < cropsize)\n-        {\n-        next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-        if (! next_buff)\n-          {\n-          _TIFFfree (crop_buff);\n-          crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          }\n+        cropsize = crop->bufftotal;\n+        crop_buff = seg_buffs[0].buffer; \n+        if (!crop_buff)\n+            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n         else\n-          crop_buff = next_buff;\n+        {\n+            prev_cropsize = seg_buffs[0].size;\n+            if (prev_cropsize < cropsize)\n+            {\n+                next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                if (!next_buff)\n+                {\n+                    _TIFFfree(crop_buff);\n+                    crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                }\n+                else\n+                    crop_buff = next_buff;\n+            }\n+        }\n+\n+        if (!crop_buff)\n+        {\n+            TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+            return (-1);\n+        }\n+\n+        _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+        seg_buffs[0].buffer = crop_buff;\n+        seg_buffs[0].size = cropsize;\n+\n+        /* Checks for matching width or length as required */\n+        if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n+            return (1);\n+\n+        if (crop->crop_mode & CROP_INVERT)\n+        {\n+            switch (crop->photometric)\n+            {\n+                /* Just change the interpretation */\n+                case PHOTOMETRIC_MINISWHITE:\n+                case PHOTOMETRIC_MINISBLACK:\n+                    image->photometric = crop->photometric;\n+                    break;\n+                case INVERT_DATA_ONLY:\n+                case INVERT_DATA_AND_TAG:\n+                    if (invertImage(image->photometric, image->spp, image->bps, \n+                                    crop->combined_width, crop->combined_length, crop_buff))\n+                    {\n+                        TIFFError("processCropSelections", \n+                                   "Failed to invert colorspace for composite regions");\n+                        return (-1);\n+                    }\n+                    if (crop->photometric == INVERT_DATA_AND_TAG)\n+                    {\n+                        switch (image->photometric)\n+                        {\n+                            case PHOTOMETRIC_MINISWHITE:\n+                                image->photometric = PHOTOMETRIC_MINISBLACK;\n+                                break;\n+                            case PHOTOMETRIC_MINISBLACK:\n+                                image->photometric = PHOTOMETRIC_MINISWHITE;\n+                                break;\n+                            default:\n+                                break;\n+                        }\n+                    }\n+                    break;\n+                default: break;\n+            }\n+        }\n+\n+        /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n+        if (crop->crop_mode & CROP_MIRROR)\n+        {\n+            if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                            crop->combined_width, crop->combined_length, crop_buff))\n+            {\n+                TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n+                          (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                return (-1);\n+            }\n         }\n-      }\n \n-    if (!crop_buff)\n-      {\n-      TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-      return (-1);\n-      }\n- \n-    _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    seg_buffs[0].buffer = crop_buff;\n-    seg_buffs[0].size = cropsize;\n-\n-    /* Checks for matching width or length as required */\n-    if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n-      return (1);\n-\n-    if (crop->crop_mode & CROP_INVERT)\n-      {\n-      switch (crop->photometric)\n-        {\n-        /* Just change the interpretation */\n-        case PHOTOMETRIC_MINISWHITE:\n-        case PHOTOMETRIC_MINISBLACK:\n-\t     image->photometric = crop->photometric;\n-\t     break;\n-        case INVERT_DATA_ONLY:\n-        case INVERT_DATA_AND_TAG:\n-             if (invertImage(image->photometric, image->spp, image->bps, \n-                             crop->combined_width, crop->combined_length, crop_buff))\n-               {\n-               TIFFError("processCropSelections", \n-                         "Failed to invert colorspace for composite regions");\n-               return (-1);\n-               }\n-             if (crop->photometric == INVERT_DATA_AND_TAG)\n-               {\n-               switch (image->photometric)\n-                 {\n-                 case PHOTOMETRIC_MINISWHITE:\n- \t              image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t              break;\n-                 case PHOTOMETRIC_MINISBLACK:\n- \t              image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t              break;\n-                 default:\n-\t              break;\n-\t         }\n-\t       }\n-             break;\n-        default: break;\n-        }\n-      }\n-\n-    /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n-    if (crop->crop_mode & CROP_MIRROR)\n-      {\n-      if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                      crop->combined_width, crop->combined_length, crop_buff))\n-        {\n-        TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n-\t         (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-        return (-1);\n-        }\n-      }\n-\n-    if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-      {\n-      if (rotateImage(crop->rotation, image, &crop->combined_width, \n-                      &crop->combined_length, &crop_buff))\n-        {\n-        TIFFError("processCropSelections", \n-                  "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n-        return (-1);\n-        }\n-      seg_buffs[0].buffer = crop_buff;\n-      seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n-                            * image->spp) * crop->combined_length; \n-      }\n+        if (crop->crop_mode & CROP_ROTATE) /* rotate should be validated and may need to be skipped if multiple regions present */\n+        {\n+            if (crop->selections > 1)\n+            {\n+                TIFFError("processCropSelections", "Rotation is not supported for multiple regions");\n+                return (-1);\n+            }\n+            if (rotateImage(crop->rotation, image, &crop->combined_width, \n+                            &crop->combined_length, &crop_buff))\n+            {\n+                TIFFError("processCropSelections", \n+                          "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n+                return (-1);\n+            }\n+            seg_buffs[0].buffer = crop_buff;\n+            seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n+                                  * image->spp) * crop->combined_length; \n+        }\n     }\n-  else  /* Separated Images */\n+    else  /* Separated Images */\n     {\n-    total_width = total_length = 0;\n-    for (i = 0; i < crop->selections; i++)\n-      {\n+        total_width = total_length = 0;\n+        for (i = 0; i < crop->selections; i++)\n+        {\n+            cropsize = crop->bufftotal;\n+            crop_buff = seg_buffs[i].buffer; \n+            if (!crop_buff)\n+                crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            else\n+            {\n+                prev_cropsize = seg_buffs[0].size;\n+                if (prev_cropsize < cropsize)\n+                {\n+                    next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    if (!next_buff)\n+                    {\n+                        _TIFFfree(crop_buff);\n+                        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    }\n+                    else\n+                        crop_buff = next_buff;\n+                }\n+            }\n \n-        cropsize = crop->bufftotal;\n-      crop_buff = seg_buffs[i].buffer; \n-      if (!crop_buff)\n-        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      else\n-        {\n-        prev_cropsize = seg_buffs[0].size;\n-        if (prev_cropsize < cropsize)\n-          {\n-          next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          if (! next_buff)\n+            if (!crop_buff)\n             {\n-            _TIFFfree (crop_buff);\n-            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+                return (-1);\n+            }\n+\n+            _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            seg_buffs[i].buffer = crop_buff;\n+            seg_buffs[i].size = cropsize;\n+\n+            if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+            {\n+                TIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n+                return (-1);\n             }\n-          else\n-            crop_buff = next_buff;\n-          }\n-        }\n-\n-      if (!crop_buff)\n-        {\n-        TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-        return (-1);\n-        }\n- \n-      _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      seg_buffs[i].buffer = crop_buff;\n-      seg_buffs[i].size = cropsize;\n-\n-      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n-        {\n-\tTIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n-        return (-1);\n-        }\n-    \n-      width  = crop->regionlist[i].width;\n-      length = crop->regionlist[i].length;\n-\n-      if (crop->crop_mode & CROP_INVERT)\n-        {\n-        switch (crop->photometric)\n-          {\n-          /* Just change the interpretation */\n-          case PHOTOMETRIC_MINISWHITE:\n-          case PHOTOMETRIC_MINISBLACK:\n-\t       image->photometric = crop->photometric;\n-\t       break;\n-          case INVERT_DATA_ONLY:\n-          case INVERT_DATA_AND_TAG:\n-               if (invertImage(image->photometric, image->spp, image->bps, \n-                               width, length, crop_buff))\n-                 {\n-                 TIFFError("processCropSelections", \n-                           "Failed to invert colorspace for region");\n-                 return (-1);\n-                 }\n-               if (crop->photometric == INVERT_DATA_AND_TAG)\n-                 {\n-                 switch (image->photometric)\n-                   {\n-                   case PHOTOMETRIC_MINISWHITE:\n- \t                image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t                break;\n-                   case PHOTOMETRIC_MINISBLACK:\n- \t                image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t                break;\n-                   default:\n-\t                break;\n-\t           }\n-\t         }\n-               break;\n-          default: break;\n-          }\n-        }\n-\n-      if (crop->crop_mode & CROP_MIRROR)\n-        {\n-        if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                        width, length, crop_buff))\n-          {\n-          TIFFError("processCropSelections", "Failed to mirror crop region %s", \n-\t           (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-          return (-1);\n-          }\n-        }\n-\n-      if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-        {\n-          /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it schouldn\'t do here, when more than one section is processed. \n-           * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n-           */\n-\tif (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n-\t\t\t&crop->regionlist[i].length, &crop_buff))\n-          {\n-          TIFFError("processCropSelections", \n-                    "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n-          return (-1);\n-          }\n-        total_width  += crop->regionlist[i].width;\n-        total_length += crop->regionlist[i].length;\n-        crop->combined_width = total_width;\n-        crop->combined_length = total_length;\n-        seg_buffs[i].buffer = crop_buff;\n-        seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n-                               * image->spp) * crop->regionlist[i].length; \n+\n+            width  = crop->regionlist[i].width;\n+            length = crop->regionlist[i].length;\n+\n+            if (crop->crop_mode & CROP_INVERT)\n+            {\n+                switch (crop->photometric)\n+                {\n+                    /* Just change the interpretation */\n+                    case PHOTOMETRIC_MINISWHITE:\n+                    case PHOTOMETRIC_MINISBLACK:\n+                        image->photometric = crop->photometric;\n+                        break;\n+                    case INVERT_DATA_ONLY:\n+                    case INVERT_DATA_AND_TAG:\n+                        if (invertImage(image->photometric, image->spp, image->bps, \n+                                        width, length, crop_buff))\n+                        {\n+                            TIFFError("processCropSelections", \n+                                       "Failed to invert colorspace for region");\n+                            return (-1);\n+                        }\n+                        if (crop->photometric == INVERT_DATA_AND_TAG)\n+                        {\n+                            switch (image->photometric)\n+                            {\n+                                case PHOTOMETRIC_MINISWHITE:\n+                                    image->photometric = PHOTOMETRIC_MINISBLACK;\n+                                    break;\n+                                case PHOTOMETRIC_MINISBLACK:\n+                                    image->photometric = PHOTOMETRIC_MINISWHITE;\n+                                    break;\n+                                default:\n+                                    break;\n+                            }\n+                        }\n+                        break;\n+                    default: break;\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_MIRROR)\n+            {\n+                if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                                width, length, crop_buff))\n+                {\n+                    TIFFError("processCropSelections", "Failed to mirror crop region %s", \n+                               (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                    return (-1);\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n+            {\n+                /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it schouldn\'t do here, when more than one section is processed. \n+                 * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n+                 */\n+                if (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n+                                &crop->regionlist[i].length, &crop_buff))\n+                {\n+                    TIFFError("processCropSelections", \n+                              "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n+                    return (-1);\n+                }\n+            }\n+            total_width  += crop->regionlist[i].width;\n+            total_length += crop->regionlist[i].length;\n+            crop->combined_width = total_width;\n+            crop->combined_length = total_length;\n+            seg_buffs[i].buffer = crop_buff;\n+            seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n+                                  * image->spp) * crop->regionlist[i].length; \n         }\n-      }  /* for crop->selections loop */\n     }  /* Separated Images (else case) */\n-  return (0);\n-  } /* end processCropSelections */\n+    return (0);\n+} /* end processCropSelections */\n+\n \n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n', 'id': 10, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7887:7'}, {'diff': '@@ -7678,236 +7678,236 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n-  {\n-  int       i;\n-  uint32_t    width, length, total_width, total_length;\n-  tsize_t   cropsize;\n-  unsigned  char *crop_buff = NULL;\n-  unsigned  char *read_buff = NULL;\n-  unsigned  char *next_buff = NULL;\n-  tsize_t   prev_cropsize = 0;\n+{\n+    int       i;\n+    uint32_t    width, length, total_width, total_length;\n+    tsize_t   cropsize;\n+    unsigned  char *crop_buff = NULL;\n+    unsigned  char *read_buff = NULL;\n+    unsigned  char *next_buff = NULL;\n+    tsize_t   prev_cropsize = 0;\n \n-  read_buff = *read_buff_ptr;\n+    read_buff = *read_buff_ptr;\n \n-  if (crop->img_mode == COMPOSITE_IMAGES)\n+    if (crop->img_mode == COMPOSITE_IMAGES)\n     {\n-    cropsize = crop->bufftotal;\n-    crop_buff = seg_buffs[0].buffer; \n-    if (!crop_buff)\n-      crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    else\n-      {\n-      prev_cropsize = seg_buffs[0].size;\n-      if (prev_cropsize < cropsize)\n-        {\n-        next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-        if (! next_buff)\n-          {\n-          _TIFFfree (crop_buff);\n-          crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          }\n+        cropsize = crop->bufftotal;\n+        crop_buff = seg_buffs[0].buffer; \n+        if (!crop_buff)\n+            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n         else\n-          crop_buff = next_buff;\n+        {\n+            prev_cropsize = seg_buffs[0].size;\n+            if (prev_cropsize < cropsize)\n+            {\n+                next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                if (! next_buff)\n+                {\n+                    _TIFFfree (crop_buff);\n+                    crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                }\n+                else\n+                    crop_buff = next_buff;\n+            }\n         }\n-      }\n \n-    if (!crop_buff)\n-      {\n-      TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-      return (-1);\n-      }\n- \n-    _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    seg_buffs[0].buffer = crop_buff;\n-    seg_buffs[0].size = cropsize;\n-\n-    /* Checks for matching width or length as required */\n-    if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n-      return (1);\n-\n-    if (crop->crop_mode & CROP_INVERT)\n-      {\n-      switch (crop->photometric)\n-        {\n-        /* Just change the interpretation */\n-        case PHOTOMETRIC_MINISWHITE:\n-        case PHOTOMETRIC_MINISBLACK:\n-\t     image->photometric = crop->photometric;\n-\t     break;\n-        case INVERT_DATA_ONLY:\n-        case INVERT_DATA_AND_TAG:\n-             if (invertImage(image->photometric, image->spp, image->bps, \n-                             crop->combined_width, crop->combined_length, crop_buff))\n-               {\n-               TIFFError("processCropSelections", \n-                         "Failed to invert colorspace for composite regions");\n-               return (-1);\n-               }\n-             if (crop->photometric == INVERT_DATA_AND_TAG)\n-               {\n-               switch (image->photometric)\n-                 {\n-                 case PHOTOMETRIC_MINISWHITE:\n- \t              image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t              break;\n-                 case PHOTOMETRIC_MINISBLACK:\n- \t              image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t              break;\n-                 default:\n-\t              break;\n-\t         }\n-\t       }\n-             break;\n-        default: break;\n+        if (!crop_buff)\n+        {\n+            TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+            return (-1);\n         }\n-      }\n \n-    /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n-    if (crop->crop_mode & CROP_MIRROR)\n-      {\n-      if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                      crop->combined_width, crop->combined_length, crop_buff))\n-        {\n-        TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n-\t         (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-        return (-1);\n-        }\n-      }\n+        _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+        seg_buffs[0].buffer = crop_buff;\n+        seg_buffs[0].size = cropsize;\n \n-    if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-      {\n-      if (rotateImage(crop->rotation, image, &crop->combined_width, \n-                      &crop->combined_length, &crop_buff))\n-        {\n-        TIFFError("processCropSelections", \n-                  "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n-        return (-1);\n-        }\n-      seg_buffs[0].buffer = crop_buff;\n-      seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n-                            * image->spp) * crop->combined_length; \n-      }\n-    }\n-  else  /* Separated Images */\n-    {\n-    total_width = total_length = 0;\n-    for (i = 0; i < crop->selections; i++)\n-      {\n+        /* Checks for matching width or length as required */\n+        if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n+            return (1);\n \n-        cropsize = crop->bufftotal;\n-      crop_buff = seg_buffs[i].buffer; \n-      if (!crop_buff)\n-        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      else\n-        {\n-        prev_cropsize = seg_buffs[0].size;\n-        if (prev_cropsize < cropsize)\n-          {\n-          next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          if (! next_buff)\n+        if (crop->crop_mode & CROP_INVERT)\n+        {\n+            switch (crop->photometric)\n             {\n-            _TIFFfree (crop_buff);\n-            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            /* Just change the interpretation */\n+            case PHOTOMETRIC_MINISWHITE:\n+            case PHOTOMETRIC_MINISBLACK:\n+                image->photometric = crop->photometric;\n+                break;\n+            case INVERT_DATA_ONLY:\n+            case INVERT_DATA_AND_TAG:\n+                if (invertImage(image->photometric, image->spp, image->bps, \n+                                crop->combined_width, crop->combined_length, crop_buff))\n+                {\n+                    TIFFError("processCropSelections", \n+                              "Failed to invert colorspace for composite regions");\n+                    return (-1);\n+                }\n+                if (crop->photometric == INVERT_DATA_AND_TAG)\n+                {\n+                    switch (image->photometric)\n+                    {\n+                    case PHOTOMETRIC_MINISWHITE:\n+                        image->photometric = PHOTOMETRIC_MINISBLACK;\n+                        break;\n+                    case PHOTOMETRIC_MINISBLACK:\n+                        image->photometric = PHOTOMETRIC_MINISWHITE;\n+                        break;\n+                    default:\n+                        break;\n+                    }\n+                }\n+                break;\n+            default: break;\n             }\n-          else\n-            crop_buff = next_buff;\n-          }\n         }\n \n-      if (!crop_buff)\n+        /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n+        if (crop->crop_mode & CROP_MIRROR)\n         {\n-        TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-        return (-1);\n+            if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                            crop->combined_width, crop->combined_length, crop_buff))\n+            {\n+                TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n+                         (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                return (-1);\n+            }\n         }\n- \n-      _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      seg_buffs[i].buffer = crop_buff;\n-      seg_buffs[i].size = cropsize;\n \n-      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+        if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n         {\n-\tTIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n-        return (-1);\n-        }\n-    \n-      width  = crop->regionlist[i].width;\n-      length = crop->regionlist[i].length;\n-\n-      if (crop->crop_mode & CROP_INVERT)\n-        {\n-        switch (crop->photometric)\n-          {\n-          /* Just change the interpretation */\n-          case PHOTOMETRIC_MINISWHITE:\n-          case PHOTOMETRIC_MINISBLACK:\n-\t       image->photometric = crop->photometric;\n-\t       break;\n-          case INVERT_DATA_ONLY:\n-          case INVERT_DATA_AND_TAG:\n-               if (invertImage(image->photometric, image->spp, image->bps, \n-                               width, length, crop_buff))\n-                 {\n-                 TIFFError("processCropSelections", \n-                           "Failed to invert colorspace for region");\n-                 return (-1);\n-                 }\n-               if (crop->photometric == INVERT_DATA_AND_TAG)\n-                 {\n-                 switch (image->photometric)\n-                   {\n-                   case PHOTOMETRIC_MINISWHITE:\n- \t                image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t                break;\n-                   case PHOTOMETRIC_MINISBLACK:\n- \t                image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t                break;\n-                   default:\n-\t                break;\n-\t           }\n-\t         }\n-               break;\n-          default: break;\n-          }\n+            array_t previous_dimensions = {image->width, image->length}; // Store previous dimensions\n+            if (rotateImage(crop->rotation, image, &crop->combined_width, \n+                            &crop->combined_length, &crop_buff))\n+            {\n+                TIFFError("processCropSelections", \n+                          "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n+                return (-1);\n+            }\n+            seg_buffs[0].buffer = crop_buff;\n+            seg_buffs[0].size = (((crop->combined_width * image->bps + 7) / 8)\n+                                  * image->spp) * crop->combined_length; \n         }\n-\n-      if (crop->crop_mode & CROP_MIRROR)\n+    }\n+    else  /* Separated Images */\n+    {\n+        total_width = total_length = 0;\n+        for (i = 0; i < crop->selections; i++)\n         {\n-        if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                        width, length, crop_buff))\n-          {\n-          TIFFError("processCropSelections", "Failed to mirror crop region %s", \n-\t           (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-          return (-1);\n-          }\n-        }\n+            cropsize = crop->bufftotal;\n+            crop_buff = seg_buffs[i].buffer; \n+            if (!crop_buff)\n+                crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            else\n+            {\n+                prev_cropsize = seg_buffs[0].size;\n+                if (prev_cropsize < cropsize)\n+                {\n+                    next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    if (! next_buff)\n+                    {\n+                        _TIFFfree (crop_buff);\n+                        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    }\n+                    else\n+                        crop_buff = next_buff;\n+                }\n+            }\n \n-      if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-        {\n-          /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it schouldn\'t do here, when more than one section is processed. \n-           * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n-           */\n-\tif (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n-\t\t\t&crop->regionlist[i].length, &crop_buff))\n-          {\n-          TIFFError("processCropSelections", \n-                    "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n-          return (-1);\n-          }\n-        total_width  += crop->regionlist[i].width;\n-        total_length += crop->regionlist[i].length;\n-        crop->combined_width = total_width;\n-        crop->combined_length = total_length;\n-        seg_buffs[i].buffer = crop_buff;\n-        seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n-                               * image->spp) * crop->regionlist[i].length; \n-        }\n-      }  /* for crop->selections loop */\n+            if (!crop_buff)\n+            {\n+                TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+                return (-1);\n+            }\n+\n+            _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            seg_buffs[i].buffer = crop_buff;\n+            seg_buffs[i].size = cropsize;\n+\n+            if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+            {\n+                TIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n+                return (-1);\n+            }\n+\n+            width  = crop->regionlist[i].width;\n+            length = crop->regionlist[i].length;\n+\n+            if (crop->crop_mode & CROP_INVERT)\n+            {\n+                switch (crop->photometric)\n+                {\n+                /* Just change the interpretation */\n+                case PHOTOMETRIC_MINISWHITE:\n+                case PHOTOMETRIC_MINISBLACK:\n+                    image->photometric = crop->photometric;\n+                    break;\n+                case INVERT_DATA_ONLY:\n+                case INVERT_DATA_AND_TAG:\n+                    if (invertImage(image->photometric, image->spp, image->bps, \n+                                    width, length, crop_buff))\n+                    {\n+                        TIFFError("processCropSelections", \n+                                  "Failed to invert colorspace for region");\n+                        return (-1);\n+                    }\n+                    if (crop->photometric == INVERT_DATA_AND_TAG)\n+                    {\n+                        switch (image->photometric)\n+                        {\n+                        case PHOTOMETRIC_MINISWHITE:\n+                            image->photometric = PHOTOMETRIC_MINISBLACK;\n+                            break;\n+                        case PHOTOMETRIC_MINISBLACK:\n+                            image->photometric = PHOTOMETRIC_MINISWHITE;\n+                            break;\n+                        default:\n+                            break;\n+                        }\n+                    }\n+                    break;\n+                default: break;\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_MIRROR)\n+            {\n+                if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                                width, length, crop_buff))\n+                {\n+                    TIFFError("processCropSelections", "Failed to mirror crop region %s", \n+                             (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                    return (-1);\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n+            {\n+                /* Maintain original state only for the specific region */\n+                if (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n+                                &crop->regionlist[i].length, &crop_buff))\n+                {\n+                    TIFFError("processCropSelections", \n+                              "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n+                    return (-1);\n+                }\n+            total_width  += crop->regionlist[i].width;\n+            total_length += crop->regionlist[i].length;\n+            crop->combined_width = total_width;\n+            crop->combined_length = total_length;\n+            seg_buffs[i].buffer = crop_buff;\n+            seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7) / 8)\n+                                   * image->spp) * crop->regionlist[i].length; \n+            }\n+        }  /* for crop->selections loop */\n     }  /* Separated Images (else case) */\n-  return (0);\n-  } /* end processCropSelections */\n+    return (0);\n+} /* end processCropSelections */\n+\n \n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n', 'id': 11, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7887:7'}, {'diff': '@@ -7678,236 +7678,237 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n-  {\n-  int       i;\n-  uint32_t    width, length, total_width, total_length;\n-  tsize_t   cropsize;\n-  unsigned  char *crop_buff = NULL;\n-  unsigned  char *read_buff = NULL;\n-  unsigned  char *next_buff = NULL;\n-  tsize_t   prev_cropsize = 0;\n+{\n+    int       i;\n+    uint32_t    width, length, total_width, total_length;\n+    tsize_t   cropsize;\n+    unsigned  char *crop_buff = NULL;\n+    unsigned  char *read_buff = NULL;\n+    unsigned  char *next_buff = NULL;\n+    tsize_t   prev_cropsize = 0;\n \n-  read_buff = *read_buff_ptr;\n+    read_buff = *read_buff_ptr;\n \n-  if (crop->img_mode == COMPOSITE_IMAGES)\n+    if (crop->img_mode == COMPOSITE_IMAGES)\n     {\n-    cropsize = crop->bufftotal;\n-    crop_buff = seg_buffs[0].buffer; \n-    if (!crop_buff)\n-      crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    else\n-      {\n-      prev_cropsize = seg_buffs[0].size;\n-      if (prev_cropsize < cropsize)\n-        {\n-        next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-        if (! next_buff)\n-          {\n-          _TIFFfree (crop_buff);\n-          crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          }\n+        cropsize = crop->bufftotal;\n+        crop_buff = seg_buffs[0].buffer; \n+        if (!crop_buff)\n+            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n         else\n-          crop_buff = next_buff;\n+        {\n+            prev_cropsize = seg_buffs[0].size;\n+            if (prev_cropsize < cropsize)\n+            {\n+                next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                if (!next_buff)\n+                {\n+                    _TIFFfree(crop_buff);\n+                    crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                }\n+                else\n+                    crop_buff = next_buff;\n+            }\n         }\n-      }\n \n-    if (!crop_buff)\n-      {\n-      TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-      return (-1);\n-      }\n- \n-    _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    seg_buffs[0].buffer = crop_buff;\n-    seg_buffs[0].size = cropsize;\n-\n-    /* Checks for matching width or length as required */\n-    if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n-      return (1);\n-\n-    if (crop->crop_mode & CROP_INVERT)\n-      {\n-      switch (crop->photometric)\n-        {\n-        /* Just change the interpretation */\n-        case PHOTOMETRIC_MINISWHITE:\n-        case PHOTOMETRIC_MINISBLACK:\n-\t     image->photometric = crop->photometric;\n-\t     break;\n-        case INVERT_DATA_ONLY:\n-        case INVERT_DATA_AND_TAG:\n-             if (invertImage(image->photometric, image->spp, image->bps, \n-                             crop->combined_width, crop->combined_length, crop_buff))\n-               {\n-               TIFFError("processCropSelections", \n-                         "Failed to invert colorspace for composite regions");\n-               return (-1);\n-               }\n-             if (crop->photometric == INVERT_DATA_AND_TAG)\n-               {\n-               switch (image->photometric)\n-                 {\n-                 case PHOTOMETRIC_MINISWHITE:\n- \t              image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t              break;\n-                 case PHOTOMETRIC_MINISBLACK:\n- \t              image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t              break;\n-                 default:\n-\t              break;\n-\t         }\n-\t       }\n-             break;\n-        default: break;\n+        if (!crop_buff)\n+        {\n+            TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+            return (-1);\n         }\n-      }\n \n-    /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n-    if (crop->crop_mode & CROP_MIRROR)\n-      {\n-      if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                      crop->combined_width, crop->combined_length, crop_buff))\n-        {\n-        TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n-\t         (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-        return (-1);\n-        }\n-      }\n+        _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+        seg_buffs[0].buffer = crop_buff;\n+        seg_buffs[0].size = cropsize;\n \n-    if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-      {\n-      if (rotateImage(crop->rotation, image, &crop->combined_width, \n-                      &crop->combined_length, &crop_buff))\n-        {\n-        TIFFError("processCropSelections", \n-                  "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n-        return (-1);\n-        }\n-      seg_buffs[0].buffer = crop_buff;\n-      seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n-                            * image->spp) * crop->combined_length; \n-      }\n-    }\n-  else  /* Separated Images */\n-    {\n-    total_width = total_length = 0;\n-    for (i = 0; i < crop->selections; i++)\n-      {\n+        /* Checks for matching width or length as required */\n+        if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n+            return (1);\n \n-        cropsize = crop->bufftotal;\n-      crop_buff = seg_buffs[i].buffer; \n-      if (!crop_buff)\n-        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      else\n-        {\n-        prev_cropsize = seg_buffs[0].size;\n-        if (prev_cropsize < cropsize)\n-          {\n-          next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          if (! next_buff)\n+        if (crop->crop_mode & CROP_INVERT)\n+        {\n+            switch (crop->photometric)\n             {\n-            _TIFFfree (crop_buff);\n-            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            /* Just change the interpretation */\n+            case PHOTOMETRIC_MINISWHITE:\n+            case PHOTOMETRIC_MINISBLACK:\n+                image->photometric = crop->photometric;\n+                break;\n+            case INVERT_DATA_ONLY:\n+            case INVERT_DATA_AND_TAG:\n+                if (invertImage(image->photometric, image->spp, image->bps, \n+                                crop->combined_width, crop->combined_length, crop_buff))\n+                {\n+                    TIFFError("processCropSelections", \n+                            "Failed to invert colorspace for composite regions");\n+                    return (-1);\n+                }\n+                if (crop->photometric == INVERT_DATA_AND_TAG)\n+                {\n+                    switch (image->photometric)\n+                    {\n+                    case PHOTOMETRIC_MINISWHITE:\n+                        image->photometric = PHOTOMETRIC_MINISBLACK;\n+                        break;\n+                    case PHOTOMETRIC_MINISBLACK:\n+                        image->photometric = PHOTOMETRIC_MINISWHITE;\n+                        break;\n+                    default:\n+                        break;\n+                    }\n+                }\n+                break;\n+            default: \n+                break;\n             }\n-          else\n-            crop_buff = next_buff;\n-          }\n         }\n \n-      if (!crop_buff)\n+        /* Mirror will not work with multiple regions unless they are the same width */\n+        if (crop->crop_mode & CROP_MIRROR)\n         {\n-        TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-        return (-1);\n+            if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                            crop->combined_width, crop->combined_length, crop_buff))\n+            {\n+                TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n+                        (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                return (-1);\n+            }\n         }\n- \n-      _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      seg_buffs[i].buffer = crop_buff;\n-      seg_buffs[i].size = cropsize;\n \n-      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+        if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n         {\n-\tTIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n-        return (-1);\n-        }\n-    \n-      width  = crop->regionlist[i].width;\n-      length = crop->regionlist[i].length;\n-\n-      if (crop->crop_mode & CROP_INVERT)\n-        {\n-        switch (crop->photometric)\n-          {\n-          /* Just change the interpretation */\n-          case PHOTOMETRIC_MINISWHITE:\n-          case PHOTOMETRIC_MINISBLACK:\n-\t       image->photometric = crop->photometric;\n-\t       break;\n-          case INVERT_DATA_ONLY:\n-          case INVERT_DATA_AND_TAG:\n-               if (invertImage(image->photometric, image->spp, image->bps, \n-                               width, length, crop_buff))\n-                 {\n-                 TIFFError("processCropSelections", \n-                           "Failed to invert colorspace for region");\n-                 return (-1);\n-                 }\n-               if (crop->photometric == INVERT_DATA_AND_TAG)\n-                 {\n-                 switch (image->photometric)\n-                   {\n-                   case PHOTOMETRIC_MINISWHITE:\n- \t                image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t                break;\n-                   case PHOTOMETRIC_MINISBLACK:\n- \t                image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t                break;\n-                   default:\n-\t                break;\n-\t           }\n-\t         }\n-               break;\n-          default: break;\n-          }\n-        }\n-\n-      if (crop->crop_mode & CROP_MIRROR)\n+            // Start of rotation handling\n+            if (rotateImage(crop->rotation, image, &crop->combined_width, \n+                            &crop->combined_length, &crop_buff))\n+            {\n+                TIFFError("processCropSelections", \n+                        "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n+                return (-1);\n+            }\n+            seg_buffs[0].buffer = crop_buff;\n+            seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n+                                    * image->spp) * crop->combined_length; \n+        } // End of rotation handling\n+    }\n+    else  /* Separated Images */\n+    {\n+        total_width = total_length = 0;\n+        for (i = 0; i < crop->selections; i++)\n         {\n-        if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                        width, length, crop_buff))\n-          {\n-          TIFFError("processCropSelections", "Failed to mirror crop region %s", \n-\t           (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-          return (-1);\n-          }\n-        }\n+            cropsize = crop->bufftotal;\n+            crop_buff = seg_buffs[i].buffer; \n+            if (!crop_buff)\n+                crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            else\n+            {\n+                prev_cropsize = seg_buffs[0].size;\n+                if (prev_cropsize < cropsize)\n+                {\n+                    next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    if (!next_buff)\n+                    {\n+                        _TIFFfree(crop_buff);\n+                        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    }\n+                    else\n+                        crop_buff = next_buff;\n+                }\n+            }\n \n-      if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-        {\n-          /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it schouldn\'t do here, when more than one section is processed. \n-           * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n-           */\n-\tif (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n-\t\t\t&crop->regionlist[i].length, &crop_buff))\n-          {\n-          TIFFError("processCropSelections", \n-                    "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n-          return (-1);\n-          }\n-        total_width  += crop->regionlist[i].width;\n-        total_length += crop->regionlist[i].length;\n-        crop->combined_width = total_width;\n-        crop->combined_length = total_length;\n-        seg_buffs[i].buffer = crop_buff;\n-        seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n-                               * image->spp) * crop->regionlist[i].length; \n-        }\n-      }  /* for crop->selections loop */\n+            if (!crop_buff)\n+            {\n+                TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+                return (-1);\n+            }\n+\n+            _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            seg_buffs[i].buffer = crop_buff;\n+            seg_buffs[i].size = cropsize;\n+\n+            if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+            {\n+                TIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n+                return (-1);\n+            }\n+\n+            width  = crop->regionlist[i].width;\n+            length = crop->regionlist[i].length;\n+\n+            if (crop->crop_mode & CROP_INVERT)\n+            {\n+                switch (crop->photometric)\n+                {\n+                /* Just change the interpretation */\n+                case PHOTOMETRIC_MINISWHITE:\n+                case PHOTOMETRIC_MINISBLACK:\n+                    image->photometric = crop->photometric;\n+                    break;\n+                case INVERT_DATA_ONLY:\n+                case INVERT_DATA_AND_TAG:\n+                    if (invertImage(image->photometric, image->spp, image->bps, \n+                                    width, length, crop_buff))\n+                    {\n+                        TIFFError("processCropSelections", \n+                                "Failed to invert colorspace for region");\n+                        return (-1);\n+                    }\n+                    if (crop->photometric == INVERT_DATA_AND_TAG)\n+                    {\n+                        switch (image->photometric)\n+                        {\n+                        case PHOTOMETRIC_MINISWHITE:\n+                            image->photometric = PHOTOMETRIC_MINISBLACK;\n+                            break;\n+                        case PHOTOMETRIC_MINISBLACK:\n+                            image->photometric = PHOTOMETRIC_MINISWHITE;\n+                            break;\n+                        default:\n+                            break;\n+                        }\n+                    }\n+                    break;\n+                default: \n+                    break;\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_MIRROR)\n+            {\n+                if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                                width, length, crop_buff))\n+                {\n+                    TIFFError("processCropSelections", "Failed to mirror crop region %s", \n+                            (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                    return (-1);\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n+            {\n+                if (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n+                                &crop->regionlist[i].length, &crop_buff))\n+                {\n+                    TIFFError("processCropSelections", \n+                            "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n+                    return (-1);\n+                }\n+                total_width  += crop->regionlist[i].width;\n+                total_length += crop->regionlist[i].length;\n+                crop->combined_width = total_width;\n+                crop->combined_length = total_length;\n+                seg_buffs[i].buffer = crop_buff;\n+                seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n+                                       * image->spp) * crop->regionlist[i].length; \n+            }\n+        }  /* for crop->selections loop */\n     }  /* Separated Images (else case) */\n-  return (0);\n-  } /* end processCropSelections */\n+    return (0);\n+} /* end processCropSelections */\n+\n \n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n', 'id': 12, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7887:7'}, {'diff': '@@ -7678,236 +7678,245 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n-  {\n-  int       i;\n-  uint32_t    width, length, total_width, total_length;\n-  tsize_t   cropsize;\n-  unsigned  char *crop_buff = NULL;\n-  unsigned  char *read_buff = NULL;\n-  unsigned  char *next_buff = NULL;\n-  tsize_t   prev_cropsize = 0;\n+{\n+    int       i;\n+    uint32_t    width, length, total_width, total_length;\n+    tsize_t   cropsize;\n+    unsigned  char *crop_buff = NULL;\n+    unsigned  char *read_buff = NULL;\n+    unsigned  char *next_buff = NULL;\n+    tsize_t   prev_cropsize = 0;\n \n-  read_buff = *read_buff_ptr;\n+    read_buff = *read_buff_ptr;\n \n-  if (crop->img_mode == COMPOSITE_IMAGES)\n+    if (crop->img_mode == COMPOSITE_IMAGES)\n     {\n-    cropsize = crop->bufftotal;\n-    crop_buff = seg_buffs[0].buffer; \n-    if (!crop_buff)\n-      crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    else\n-      {\n-      prev_cropsize = seg_buffs[0].size;\n-      if (prev_cropsize < cropsize)\n-        {\n-        next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-        if (! next_buff)\n-          {\n-          _TIFFfree (crop_buff);\n-          crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          }\n+        cropsize = crop->bufftotal;\n+        crop_buff = seg_buffs[0].buffer; \n+        if (!crop_buff)\n+            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n         else\n-          crop_buff = next_buff;\n+        {\n+            prev_cropsize = seg_buffs[0].size;\n+            if (prev_cropsize < cropsize)\n+            {\n+                next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                if (!next_buff)\n+                {\n+                    _TIFFfree(crop_buff);\n+                    crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                }\n+                else\n+                    crop_buff = next_buff;\n+            }\n         }\n-      }\n \n-    if (!crop_buff)\n-      {\n-      TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-      return (-1);\n-      }\n- \n-    _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    seg_buffs[0].buffer = crop_buff;\n-    seg_buffs[0].size = cropsize;\n-\n-    /* Checks for matching width or length as required */\n-    if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n-      return (1);\n-\n-    if (crop->crop_mode & CROP_INVERT)\n-      {\n-      switch (crop->photometric)\n-        {\n-        /* Just change the interpretation */\n-        case PHOTOMETRIC_MINISWHITE:\n-        case PHOTOMETRIC_MINISBLACK:\n-\t     image->photometric = crop->photometric;\n-\t     break;\n-        case INVERT_DATA_ONLY:\n-        case INVERT_DATA_AND_TAG:\n-             if (invertImage(image->photometric, image->spp, image->bps, \n-                             crop->combined_width, crop->combined_length, crop_buff))\n-               {\n-               TIFFError("processCropSelections", \n-                         "Failed to invert colorspace for composite regions");\n-               return (-1);\n-               }\n-             if (crop->photometric == INVERT_DATA_AND_TAG)\n-               {\n-               switch (image->photometric)\n-                 {\n-                 case PHOTOMETRIC_MINISWHITE:\n- \t              image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t              break;\n-                 case PHOTOMETRIC_MINISBLACK:\n- \t              image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t              break;\n-                 default:\n-\t              break;\n-\t         }\n-\t       }\n-             break;\n-        default: break;\n+        if (!crop_buff)\n+        {\n+            TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+            return (-1);\n         }\n-      }\n \n-    /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n-    if (crop->crop_mode & CROP_MIRROR)\n-      {\n-      if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                      crop->combined_width, crop->combined_length, crop_buff))\n-        {\n-        TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n-\t         (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-        return (-1);\n-        }\n-      }\n+        _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+        seg_buffs[0].buffer = crop_buff;\n+        seg_buffs[0].size = cropsize;\n \n-    if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-      {\n-      if (rotateImage(crop->rotation, image, &crop->combined_width, \n-                      &crop->combined_length, &crop_buff))\n-        {\n-        TIFFError("processCropSelections", \n-                  "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n-        return (-1);\n-        }\n-      seg_buffs[0].buffer = crop_buff;\n-      seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n-                            * image->spp) * crop->combined_length; \n-      }\n-    }\n-  else  /* Separated Images */\n-    {\n-    total_width = total_length = 0;\n-    for (i = 0; i < crop->selections; i++)\n-      {\n+        /* Checks for matching width or length as required */\n+        if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n+            return (1);\n \n-        cropsize = crop->bufftotal;\n-      crop_buff = seg_buffs[i].buffer; \n-      if (!crop_buff)\n-        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      else\n-        {\n-        prev_cropsize = seg_buffs[0].size;\n-        if (prev_cropsize < cropsize)\n-          {\n-          next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          if (! next_buff)\n+        if (crop->crop_mode & CROP_INVERT)\n+        {\n+            switch (crop->photometric)\n             {\n-            _TIFFfree (crop_buff);\n-            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            /* Just change the interpretation */\n+            case PHOTOMETRIC_MINISWHITE:\n+            case PHOTOMETRIC_MINISBLACK:\n+                image->photometric = crop->photometric;\n+                break;\n+            case INVERT_DATA_ONLY:\n+            case INVERT_DATA_AND_TAG:\n+                if (invertImage(image->photometric, image->spp, image->bps, \n+                                crop->combined_width, crop->combined_length, crop_buff))\n+                {\n+                    TIFFError("processCropSelections", \n+                              "Failed to invert colorspace for composite regions");\n+                    return (-1);\n+                }\n+                if (crop->photometric == INVERT_DATA_AND_TAG)\n+                {\n+                    switch (image->photometric)\n+                    {\n+                    case PHOTOMETRIC_MINISWHITE:\n+                        image->photometric = PHOTOMETRIC_MINISBLACK;\n+                        break;\n+                    case PHOTOMETRIC_MINISBLACK:\n+                        image->photometric = PHOTOMETRIC_MINISWHITE;\n+                        break;\n+                    default:\n+                        break;\n+                    }\n+                }\n+                break;\n+            default: \n+                break;\n             }\n-          else\n-            crop_buff = next_buff;\n-          }\n         }\n \n-      if (!crop_buff)\n+        /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n+        if (crop->crop_mode & CROP_MIRROR)\n         {\n-        TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-        return (-1);\n+            if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                            crop->combined_width, crop->combined_length, crop_buff))\n+            {\n+                TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n+                         (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                return (-1);\n+            }\n         }\n- \n-      _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      seg_buffs[i].buffer = crop_buff;\n-      seg_buffs[i].size = cropsize;\n \n-      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+        if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n         {\n-\tTIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n-        return (-1);\n-        }\n-    \n-      width  = crop->regionlist[i].width;\n-      length = crop->regionlist[i].length;\n-\n-      if (crop->crop_mode & CROP_INVERT)\n-        {\n-        switch (crop->photometric)\n-          {\n-          /* Just change the interpretation */\n-          case PHOTOMETRIC_MINISWHITE:\n-          case PHOTOMETRIC_MINISBLACK:\n-\t       image->photometric = crop->photometric;\n-\t       break;\n-          case INVERT_DATA_ONLY:\n-          case INVERT_DATA_AND_TAG:\n-               if (invertImage(image->photometric, image->spp, image->bps, \n-                               width, length, crop_buff))\n-                 {\n-                 TIFFError("processCropSelections", \n-                           "Failed to invert colorspace for region");\n-                 return (-1);\n-                 }\n-               if (crop->photometric == INVERT_DATA_AND_TAG)\n-                 {\n-                 switch (image->photometric)\n-                   {\n-                   case PHOTOMETRIC_MINISWHITE:\n- \t                image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t                break;\n-                   case PHOTOMETRIC_MINISBLACK:\n- \t                image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t                break;\n-                   default:\n-\t                break;\n-\t           }\n-\t         }\n-               break;\n-          default: break;\n-          }\n+            tsize_t tmp_width = crop->combined_width;\n+            tsize_t tmp_length = crop->combined_length;\n+            if (rotateImage(crop->rotation, image, &tmp_width, \n+                            &tmp_length, &crop_buff))\n+            {\n+                TIFFError("processCropSelections", \n+                          "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n+                return (-1);\n+            }\n+            crop->combined_width = tmp_width;\n+            crop->combined_length = tmp_length;\n+            seg_buffs[0].buffer = crop_buff;\n+            seg_buffs[0].size = (((crop->combined_width * image->bps + 7) / 8)\n+                                  * image->spp) * crop->combined_length; \n         }\n-\n-      if (crop->crop_mode & CROP_MIRROR)\n+    }\n+    else  /* Separated Images */\n+    {\n+        total_width = total_length = 0;\n+        for (i = 0; i < crop->selections; i++)\n         {\n-        if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                        width, length, crop_buff))\n-          {\n-          TIFFError("processCropSelections", "Failed to mirror crop region %s", \n-\t           (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-          return (-1);\n-          }\n-        }\n+            cropsize = crop->bufftotal;\n+            crop_buff = seg_buffs[i].buffer; \n+            if (!crop_buff)\n+                crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            else\n+            {\n+                prev_cropsize = seg_buffs[0].size;\n+                if (prev_cropsize < cropsize)\n+                {\n+                    next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    if (!next_buff)\n+                    {\n+                        _TIFFfree(crop_buff);\n+                        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    }\n+                    else\n+                        crop_buff = next_buff;\n+                }\n+            }\n \n-      if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-        {\n-          /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it schouldn\'t do here, when more than one section is processed. \n-           * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n-           */\n-\tif (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n-\t\t\t&crop->regionlist[i].length, &crop_buff))\n-          {\n-          TIFFError("processCropSelections", \n-                    "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n-          return (-1);\n-          }\n-        total_width  += crop->regionlist[i].width;\n-        total_length += crop->regionlist[i].length;\n-        crop->combined_width = total_width;\n-        crop->combined_length = total_length;\n-        seg_buffs[i].buffer = crop_buff;\n-        seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n-                               * image->spp) * crop->regionlist[i].length; \n-        }\n-      }  /* for crop->selections loop */\n+            if (!crop_buff)\n+            {\n+                TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+                return (-1);\n+            }\n+\n+            _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            seg_buffs[i].buffer = crop_buff;\n+            seg_buffs[i].size = cropsize;\n+\n+            if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+            {\n+                TIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n+                return (-1);\n+            }\n+\n+            width  = crop->regionlist[i].width;\n+            length = crop->regionlist[i].length;\n+\n+            if (crop->crop_mode & CROP_INVERT)\n+            {\n+                switch (crop->photometric)\n+                {\n+                /* Just change the interpretation */\n+                case PHOTOMETRIC_MINISWHITE:\n+                case PHOTOMETRIC_MINISBLACK:\n+                    image->photometric = crop->photometric;\n+                    break;\n+                case INVERT_DATA_ONLY:\n+                case INVERT_DATA_AND_TAG:\n+                    if (invertImage(image->photometric, image->spp, image->bps, \n+                                    width, length, crop_buff))\n+                    {\n+                        TIFFError("processCropSelections", \n+                                  "Failed to invert colorspace for region");\n+                        return (-1);\n+                    }\n+                    if (crop->photometric == INVERT_DATA_AND_TAG)\n+                    {\n+                        switch (image->photometric)\n+                        {\n+                        case PHOTOMETRIC_MINISWHITE:\n+                            image->photometric = PHOTOMETRIC_MINISBLACK;\n+                            break;\n+                        case PHOTOMETRIC_MINISBLACK:\n+                            image->photometric = PHOTOMETRIC_MINISWHITE;\n+                            break;\n+                        default:\n+                            break;\n+                        }\n+                    }\n+                    break;\n+                default: \n+                    break;\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_MIRROR)\n+            {\n+                if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                                width, length, crop_buff))\n+                {\n+                    TIFFError("processCropSelections", "Failed to mirror crop region %s", \n+                             (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                    return (-1);\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n+            {\n+                /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it shouldn\'t do here, when more than one section is processed. \n+                 * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n+                 */\n+                tsize_t tmp_width = crop->regionlist[i].width;\n+                tsize_t tmp_length = crop->regionlist[i].length;\n+                if (rotateImage(crop->rotation, image, &tmp_width, \n+                                &tmp_length, &crop_buff))\n+                {\n+                    TIFFError("processCropSelections", \n+                              "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n+                    return (-1);\n+                }\n+                total_width  += tmp_width;\n+                total_length += tmp_length;\n+                crop->combined_width = total_width;\n+                crop->combined_length = total_length;\n+                seg_buffs[i].buffer = crop_buff;\n+                seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7) / 8)\n+                                      * image->spp) * crop->regionlist[i].length; \n+            }\n+        }  /* for crop->selections loop */\n     }  /* Separated Images (else case) */\n-  return (0);\n-  } /* end processCropSelections */\n+    return (0);\n+} /* end processCropSelections */\n+\n \n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n', 'id': 13, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7887:7'}, {'diff': '@@ -7678,10 +7678,11 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n-  {\n+{\n   int       i;\n   uint32_t    width, length, total_width, total_length;\n   tsize_t   cropsize;\n@@ -7719,7 +7720,7 @@\n       TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n       return (-1);\n       }\n- \n+\n     _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n     seg_buffs[0].buffer = crop_buff;\n     seg_buffs[0].size = cropsize;\n@@ -7779,6 +7780,11 @@\n \n     if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n       {\n+      if (crop->combined_width != crop->combined_length) // Added check to prevent reallocation issues\n+      {\n+          TIFFError("processCropSelections", "Width and length must match for rotation.");\n+          return (-1);\n+      }\n       if (rotateImage(crop->rotation, image, &crop->combined_width, \n                       &crop->combined_length, &crop_buff))\n         {\n@@ -7822,7 +7828,7 @@\n         TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n         return (-1);\n         }\n- \n+\n       _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n       seg_buffs[i].buffer = crop_buff;\n       seg_buffs[i].size = cropsize;\n@@ -7907,7 +7913,8 @@\n       }  /* for crop->selections loop */\n     }  /* Separated Images (else case) */\n   return (0);\n-  } /* end processCropSelections */\n+} /* end processCropSelections */\n+\n \n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n', 'id': 14, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7887:7'}, {'diff': '@@ -7678,10 +7678,11 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n-  {\n+{\n   int       i;\n   uint32_t    width, length, total_width, total_length;\n   tsize_t   cropsize;\n@@ -7765,8 +7766,8 @@\n         }\n       }\n \n-    /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n-    if (crop->crop_mode & CROP_MIRROR)\n+    /* Only allow mirror if single region is being processed */\n+    if (crop->crop_mode & CROP_MIRROR && crop->selections == 1)\n       {\n       if (mirrorImage(image->spp, image->bps, crop->mirror, \n                       crop->combined_width, crop->combined_length, crop_buff))\n@@ -7873,7 +7874,7 @@\n           }\n         }\n \n-      if (crop->crop_mode & CROP_MIRROR)\n+      if (crop->crop_mode & CROP_MIRROR && crop->selections == 1)\n         {\n         if (mirrorImage(image->spp, image->bps, crop->mirror, \n                         width, length, crop_buff))\n@@ -7907,7 +7908,8 @@\n       }  /* for crop->selections loop */\n     }  /* Separated Images (else case) */\n   return (0);\n-  } /* end processCropSelections */\n+} /* end processCropSelections */\n+\n \n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n', 'id': 15, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7876:7'}, {'diff': '@@ -7678,236 +7678,235 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n-  {\n-  int       i;\n-  uint32_t    width, length, total_width, total_length;\n-  tsize_t   cropsize;\n-  unsigned  char *crop_buff = NULL;\n-  unsigned  char *read_buff = NULL;\n-  unsigned  char *next_buff = NULL;\n-  tsize_t   prev_cropsize = 0;\n+{\n+    int       i;\n+    uint32_t  width, length, total_width, total_length;\n+    tsize_t   cropsize;\n+    unsigned  char *crop_buff = NULL;\n+    unsigned  char *read_buff = NULL;\n+    unsigned  char *next_buff = NULL;\n+    tsize_t   prev_cropsize = 0;\n \n-  read_buff = *read_buff_ptr;\n+    read_buff = *read_buff_ptr;\n \n-  if (crop->img_mode == COMPOSITE_IMAGES)\n+    if (crop->img_mode == COMPOSITE_IMAGES)\n     {\n-    cropsize = crop->bufftotal;\n-    crop_buff = seg_buffs[0].buffer; \n-    if (!crop_buff)\n-      crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    else\n-      {\n-      prev_cropsize = seg_buffs[0].size;\n-      if (prev_cropsize < cropsize)\n-        {\n-        next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-        if (! next_buff)\n-          {\n-          _TIFFfree (crop_buff);\n-          crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          }\n+        cropsize = crop->bufftotal;\n+        crop_buff = seg_buffs[0].buffer; \n+        if (!crop_buff)\n+            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n         else\n-          crop_buff = next_buff;\n+        {\n+            prev_cropsize = seg_buffs[0].size;\n+            if (prev_cropsize < cropsize)\n+            {\n+                next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                if (!next_buff)\n+                {\n+                    _TIFFfree(crop_buff);\n+                    crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                }\n+                else\n+                    crop_buff = next_buff;\n+            }\n         }\n-      }\n \n-    if (!crop_buff)\n-      {\n-      TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-      return (-1);\n-      }\n- \n-    _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    seg_buffs[0].buffer = crop_buff;\n-    seg_buffs[0].size = cropsize;\n-\n-    /* Checks for matching width or length as required */\n-    if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n-      return (1);\n-\n-    if (crop->crop_mode & CROP_INVERT)\n-      {\n-      switch (crop->photometric)\n-        {\n-        /* Just change the interpretation */\n-        case PHOTOMETRIC_MINISWHITE:\n-        case PHOTOMETRIC_MINISBLACK:\n-\t     image->photometric = crop->photometric;\n-\t     break;\n-        case INVERT_DATA_ONLY:\n-        case INVERT_DATA_AND_TAG:\n-             if (invertImage(image->photometric, image->spp, image->bps, \n-                             crop->combined_width, crop->combined_length, crop_buff))\n-               {\n-               TIFFError("processCropSelections", \n-                         "Failed to invert colorspace for composite regions");\n-               return (-1);\n-               }\n-             if (crop->photometric == INVERT_DATA_AND_TAG)\n-               {\n-               switch (image->photometric)\n-                 {\n-                 case PHOTOMETRIC_MINISWHITE:\n- \t              image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t              break;\n-                 case PHOTOMETRIC_MINISBLACK:\n- \t              image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t              break;\n-                 default:\n-\t              break;\n-\t         }\n-\t       }\n-             break;\n-        default: break;\n+        if (!crop_buff)\n+        {\n+            TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+            return (-1);\n         }\n-      }\n \n-    /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n-    if (crop->crop_mode & CROP_MIRROR)\n-      {\n-      if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                      crop->combined_width, crop->combined_length, crop_buff))\n-        {\n-        TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n-\t         (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-        return (-1);\n-        }\n-      }\n+        _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+        seg_buffs[0].buffer = crop_buff;\n+        seg_buffs[0].size = cropsize;\n \n-    if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-      {\n-      if (rotateImage(crop->rotation, image, &crop->combined_width, \n-                      &crop->combined_length, &crop_buff))\n-        {\n-        TIFFError("processCropSelections", \n-                  "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n-        return (-1);\n-        }\n-      seg_buffs[0].buffer = crop_buff;\n-      seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n-                            * image->spp) * crop->combined_length; \n-      }\n-    }\n-  else  /* Separated Images */\n-    {\n-    total_width = total_length = 0;\n-    for (i = 0; i < crop->selections; i++)\n-      {\n+        /* Checks for matching width or length as required */\n+        if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n+            return (1);\n \n-        cropsize = crop->bufftotal;\n-      crop_buff = seg_buffs[i].buffer; \n-      if (!crop_buff)\n-        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      else\n-        {\n-        prev_cropsize = seg_buffs[0].size;\n-        if (prev_cropsize < cropsize)\n-          {\n-          next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          if (! next_buff)\n+        if (crop->crop_mode & CROP_INVERT)\n+        {\n+            switch (crop->photometric)\n             {\n-            _TIFFfree (crop_buff);\n-            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            case PHOTOMETRIC_MINISWHITE:\n+            case PHOTOMETRIC_MINISBLACK:\n+                image->photometric = crop->photometric;\n+                break;\n+            case INVERT_DATA_ONLY:\n+            case INVERT_DATA_AND_TAG:\n+                if (invertImage(image->photometric, image->spp, image->bps, \n+                                crop->combined_width, crop->combined_length, crop_buff))\n+                {\n+                    TIFFError("processCropSelections", \n+                              "Failed to invert colorspace for composite regions");\n+                    return (-1);\n+                }\n+                if (crop->photometric == INVERT_DATA_AND_TAG)\n+                {\n+                    switch (image->photometric)\n+                    {\n+                    case PHOTOMETRIC_MINISWHITE:\n+                        image->photometric = PHOTOMETRIC_MINISBLACK;\n+                        break;\n+                    case PHOTOMETRIC_MINISBLACK:\n+                        image->photometric = PHOTOMETRIC_MINISWHITE;\n+                        break;\n+                    default:\n+                        break;\n+                    }\n+                }\n+                break;\n+            default: \n+                break;\n             }\n-          else\n-            crop_buff = next_buff;\n-          }\n         }\n \n-      if (!crop_buff)\n+        /* Use a temporary variable to track if the crop should be mirrored */\n+        bool shouldMirror = (crop->crop_mode & CROP_MIRROR) ? true : false;\n+        if (shouldMirror)\n         {\n-        TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-        return (-1);\n+            if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                            crop->combined_width, crop->combined_length, crop_buff))\n+            {\n+                TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n+                          (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                return (-1);\n+            }\n         }\n- \n-      _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      seg_buffs[i].buffer = crop_buff;\n-      seg_buffs[i].size = cropsize;\n \n-      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+        if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n         {\n-\tTIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n-        return (-1);\n-        }\n-    \n-      width  = crop->regionlist[i].width;\n-      length = crop->regionlist[i].length;\n-\n-      if (crop->crop_mode & CROP_INVERT)\n-        {\n-        switch (crop->photometric)\n-          {\n-          /* Just change the interpretation */\n-          case PHOTOMETRIC_MINISWHITE:\n-          case PHOTOMETRIC_MINISBLACK:\n-\t       image->photometric = crop->photometric;\n-\t       break;\n-          case INVERT_DATA_ONLY:\n-          case INVERT_DATA_AND_TAG:\n-               if (invertImage(image->photometric, image->spp, image->bps, \n-                               width, length, crop_buff))\n-                 {\n-                 TIFFError("processCropSelections", \n-                           "Failed to invert colorspace for region");\n-                 return (-1);\n-                 }\n-               if (crop->photometric == INVERT_DATA_AND_TAG)\n-                 {\n-                 switch (image->photometric)\n-                   {\n-                   case PHOTOMETRIC_MINISWHITE:\n- \t                image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t                break;\n-                   case PHOTOMETRIC_MINISBLACK:\n- \t                image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t                break;\n-                   default:\n-\t                break;\n-\t           }\n-\t         }\n-               break;\n-          default: break;\n-          }\n+            if (rotateImage(crop->rotation, image, &crop->combined_width, \n+                            &crop->combined_length, &crop_buff))\n+            {\n+                TIFFError("processCropSelections", \n+                          "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n+                return (-1);\n+            }\n+            seg_buffs[0].buffer = crop_buff;\n+            seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n+                                  * image->spp) * crop->combined_length; \n         }\n-\n-      if (crop->crop_mode & CROP_MIRROR)\n+    }\n+    else  /* Separated Images */\n+    {\n+        total_width = total_length = 0;\n+        for (i = 0; i < crop->selections; i++)\n         {\n-        if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                        width, length, crop_buff))\n-          {\n-          TIFFError("processCropSelections", "Failed to mirror crop region %s", \n-\t           (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-          return (-1);\n-          }\n-        }\n+            cropsize = crop->bufftotal;\n+            crop_buff = seg_buffs[i].buffer; \n+            if (!crop_buff)\n+                crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            else\n+            {\n+                prev_cropsize = seg_buffs[0].size;\n+                if (prev_cropsize < cropsize)\n+                {\n+                    next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    if (!next_buff)\n+                    {\n+                        _TIFFfree(crop_buff);\n+                        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    }\n+                    else\n+                        crop_buff = next_buff;\n+                }\n+            }\n \n-      if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-        {\n-          /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it schouldn\'t do here, when more than one section is processed. \n-           * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n-           */\n-\tif (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n-\t\t\t&crop->regionlist[i].length, &crop_buff))\n-          {\n-          TIFFError("processCropSelections", \n-                    "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n-          return (-1);\n-          }\n-        total_width  += crop->regionlist[i].width;\n-        total_length += crop->regionlist[i].length;\n-        crop->combined_width = total_width;\n-        crop->combined_length = total_length;\n-        seg_buffs[i].buffer = crop_buff;\n-        seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n-                               * image->spp) * crop->regionlist[i].length; \n-        }\n-      }  /* for crop->selections loop */\n+            if (!crop_buff)\n+            {\n+                TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+                return (-1);\n+            }\n+\n+            _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            seg_buffs[i].buffer = crop_buff;\n+            seg_buffs[i].size = cropsize;\n+\n+            if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+            {\n+                TIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n+                return (-1);\n+            }\n+\n+            width  = crop->regionlist[i].width;\n+            length = crop->regionlist[i].length;\n+\n+            if (crop->crop_mode & CROP_INVERT)\n+            {\n+                switch (crop->photometric)\n+                {\n+                case PHOTOMETRIC_MINISWHITE:\n+                case PHOTOMETRIC_MINISBLACK:\n+                    image->photometric = crop->photometric;\n+                    break;\n+                case INVERT_DATA_ONLY:\n+                case INVERT_DATA_AND_TAG:\n+                    if (invertImage(image->photometric, image->spp, image->bps, \n+                                    width, length, crop_buff))\n+                    {\n+                        TIFFError("processCropSelections", \n+                                  "Failed to invert colorspace for region");\n+                        return (-1);\n+                    }\n+                    if (crop->photometric == INVERT_DATA_AND_TAG)\n+                    {\n+                        switch (image->photometric)\n+                        {\n+                        case PHOTOMETRIC_MINISWHITE:\n+                            image->photometric = PHOTOMETRIC_MINISBLACK;\n+                            break;\n+                        case PHOTOMETRIC_MINISBLACK:\n+                            image->photometric = PHOTOMETRIC_MINISWHITE;\n+                            break;\n+                        default:\n+                            break;\n+                        }\n+                    }\n+                    break;\n+                default: \n+                    break;\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_MIRROR)\n+            {\n+                if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                                width, length, crop_buff))\n+                {\n+                    TIFFError("processCropSelections", "Failed to mirror crop region %s", \n+                               (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                    return (-1);\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n+            {\n+                if (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n+                                &crop->regionlist[i].length, &crop_buff))\n+                {\n+                    TIFFError("processCropSelections", \n+                              "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n+                    return (-1);\n+                }\n+            total_width  += crop->regionlist[i].width;\n+            total_length += crop->regionlist[i].length;\n+            crop->combined_width = total_width;\n+            crop->combined_length = total_length;\n+            seg_buffs[i].buffer = crop_buff;\n+            seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n+                                  * image->spp) * crop->regionlist[i].length; \n+            }\n+        }  /* for crop->selections loop */\n     }  /* Separated Images (else case) */\n-  return (0);\n-  } /* end processCropSelections */\n+    return (0);\n+} /* end processCropSelections */\n+\n \n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n', 'id': 16, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7876:7'}, {'diff': '@@ -7678,236 +7678,226 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n-  {\n-  int       i;\n-  uint32_t    width, length, total_width, total_length;\n-  tsize_t   cropsize;\n-  unsigned  char *crop_buff = NULL;\n-  unsigned  char *read_buff = NULL;\n-  unsigned  char *next_buff = NULL;\n-  tsize_t   prev_cropsize = 0;\n+{\n+    int       i;\n+    uint32_t    width, length, total_width, total_length;\n+    tsize_t   cropsize;\n+    unsigned  char *crop_buff = NULL;\n+    unsigned  char *read_buff = NULL;\n+    unsigned  char *next_buff = NULL;\n+    tsize_t   prev_cropsize = 0;\n \n-  read_buff = *read_buff_ptr;\n+    read_buff = *read_buff_ptr;\n \n-  if (crop->img_mode == COMPOSITE_IMAGES)\n+    if (crop->img_mode == COMPOSITE_IMAGES)\n     {\n-    cropsize = crop->bufftotal;\n-    crop_buff = seg_buffs[0].buffer; \n-    if (!crop_buff)\n-      crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    else\n-      {\n-      prev_cropsize = seg_buffs[0].size;\n-      if (prev_cropsize < cropsize)\n-        {\n-        next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-        if (! next_buff)\n-          {\n-          _TIFFfree (crop_buff);\n-          crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          }\n+        cropsize = crop->bufftotal;\n+        crop_buff = seg_buffs[0].buffer; \n+        if (!crop_buff)\n+            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n         else\n-          crop_buff = next_buff;\n+        {\n+            prev_cropsize = seg_buffs[0].size;\n+            if (prev_cropsize < cropsize)\n+            {\n+                next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                if (! next_buff)\n+                {\n+                    _TIFFfree (crop_buff);\n+                    crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                }\n+                else\n+                    crop_buff = next_buff;\n+            }\n         }\n-      }\n \n-    if (!crop_buff)\n-      {\n-      TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-      return (-1);\n-      }\n- \n-    _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    seg_buffs[0].buffer = crop_buff;\n-    seg_buffs[0].size = cropsize;\n-\n-    /* Checks for matching width or length as required */\n-    if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n-      return (1);\n-\n-    if (crop->crop_mode & CROP_INVERT)\n-      {\n-      switch (crop->photometric)\n+        if (!crop_buff)\n         {\n-        /* Just change the interpretation */\n-        case PHOTOMETRIC_MINISWHITE:\n-        case PHOTOMETRIC_MINISBLACK:\n-\t     image->photometric = crop->photometric;\n-\t     break;\n-        case INVERT_DATA_ONLY:\n-        case INVERT_DATA_AND_TAG:\n-             if (invertImage(image->photometric, image->spp, image->bps, \n-                             crop->combined_width, crop->combined_length, crop_buff))\n-               {\n-               TIFFError("processCropSelections", \n-                         "Failed to invert colorspace for composite regions");\n-               return (-1);\n-               }\n-             if (crop->photometric == INVERT_DATA_AND_TAG)\n-               {\n-               switch (image->photometric)\n-                 {\n-                 case PHOTOMETRIC_MINISWHITE:\n- \t              image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t              break;\n-                 case PHOTOMETRIC_MINISBLACK:\n- \t              image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t              break;\n-                 default:\n-\t              break;\n-\t         }\n-\t       }\n-             break;\n-        default: break;\n+            TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+            return (-1);\n         }\n-      }\n \n-    /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n-    if (crop->crop_mode & CROP_MIRROR)\n-      {\n-      if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                      crop->combined_width, crop->combined_length, crop_buff))\n+        _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+        seg_buffs[0].buffer = crop_buff;\n+        seg_buffs[0].size = cropsize;\n+\n+        /* Checks for matching width or length as required */\n+        if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n+            return (1);\n+\n+        if (crop->crop_mode & CROP_INVERT)\n         {\n-        TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n-\t         (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-        return (-1);\n+            switch (crop->photometric)\n+            {\n+                /* Just change the interpretation */\n+                case PHOTOMETRIC_MINISWHITE:\n+                case PHOTOMETRIC_MINISBLACK:\n+                    image->photometric = crop->photometric;\n+                    break;\n+                case INVERT_DATA_ONLY:\n+                case INVERT_DATA_AND_TAG:\n+                    if (invertImage(image->photometric, image->spp, image->bps, \n+                                    crop->combined_width, crop->combined_length, crop_buff))\n+                    {\n+                        TIFFError("processCropSelections", \n+                                  "Failed to invert colorspace for composite regions");\n+                        return (-1);\n+                    }\n+                    if (crop->photometric == INVERT_DATA_AND_TAG)\n+                    {\n+                        switch (image->photometric)\n+                        {\n+                            case PHOTOMETRIC_MINISWHITE:\n+                                image->photometric = PHOTOMETRIC_MINISBLACK;\n+                                break;\n+                            case PHOTOMETRIC_MINISBLACK:\n+                                image->photometric = PHOTOMETRIC_MINISWHITE;\n+                                break;\n+                            default:\n+                                break;\n+                        }\n+                    }\n+                    break;\n+                default: break;\n+            }\n         }\n-      }\n \n-    if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-      {\n-      if (rotateImage(crop->rotation, image, &crop->combined_width, \n-                      &crop->combined_length, &crop_buff))\n+        /* Remove the condition that could lead to vulnerability */\n+        if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n         {\n-        TIFFError("processCropSelections", \n-                  "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n-        return (-1);\n+            if (rotateImage(crop->rotation, image, &crop->combined_width, \n+                            &crop->combined_length, &crop_buff))\n+            {\n+                TIFFError("processCropSelections", \n+                          "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n+                return (-1);\n+            }\n+            seg_buffs[0].buffer = crop_buff;\n+            seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n+                                  * image->spp) * crop->combined_length; \n         }\n-      seg_buffs[0].buffer = crop_buff;\n-      seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n-                            * image->spp) * crop->combined_length; \n-      }\n     }\n-  else  /* Separated Images */\n+    else  /* Separated Images */\n     {\n-    total_width = total_length = 0;\n-    for (i = 0; i < crop->selections; i++)\n-      {\n-\n-        cropsize = crop->bufftotal;\n-      crop_buff = seg_buffs[i].buffer; \n-      if (!crop_buff)\n-        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      else\n+        total_width = total_length = 0;\n+        for (i = 0; i < crop->selections; i++)\n         {\n-        prev_cropsize = seg_buffs[0].size;\n-        if (prev_cropsize < cropsize)\n-          {\n-          next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          if (! next_buff)\n+            cropsize = crop->bufftotal;\n+            crop_buff = seg_buffs[i].buffer; \n+            if (!crop_buff)\n+                crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            else\n             {\n-            _TIFFfree (crop_buff);\n-            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                prev_cropsize = seg_buffs[0].size;\n+                if (prev_cropsize < cropsize)\n+                {\n+                    next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    if (! next_buff)\n+                    {\n+                        _TIFFfree (crop_buff);\n+                        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    }\n+                    else\n+                        crop_buff = next_buff;\n+                }\n             }\n-          else\n-            crop_buff = next_buff;\n-          }\n-        }\n \n-      if (!crop_buff)\n-        {\n-        TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-        return (-1);\n-        }\n- \n-      _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      seg_buffs[i].buffer = crop_buff;\n-      seg_buffs[i].size = cropsize;\n+            if (!crop_buff)\n+            {\n+                TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+                return (-1);\n+            }\n \n-      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n-        {\n-\tTIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n-        return (-1);\n-        }\n-    \n-      width  = crop->regionlist[i].width;\n-      length = crop->regionlist[i].length;\n+            _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            seg_buffs[i].buffer = crop_buff;\n+            seg_buffs[i].size = cropsize;\n \n-      if (crop->crop_mode & CROP_INVERT)\n-        {\n-        switch (crop->photometric)\n-          {\n-          /* Just change the interpretation */\n-          case PHOTOMETRIC_MINISWHITE:\n-          case PHOTOMETRIC_MINISBLACK:\n-\t       image->photometric = crop->photometric;\n-\t       break;\n-          case INVERT_DATA_ONLY:\n-          case INVERT_DATA_AND_TAG:\n-               if (invertImage(image->photometric, image->spp, image->bps, \n-                               width, length, crop_buff))\n-                 {\n-                 TIFFError("processCropSelections", \n-                           "Failed to invert colorspace for region");\n-                 return (-1);\n-                 }\n-               if (crop->photometric == INVERT_DATA_AND_TAG)\n-                 {\n-                 switch (image->photometric)\n-                   {\n-                   case PHOTOMETRIC_MINISWHITE:\n- \t                image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t                break;\n-                   case PHOTOMETRIC_MINISBLACK:\n- \t                image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t                break;\n-                   default:\n-\t                break;\n-\t           }\n-\t         }\n-               break;\n-          default: break;\n-          }\n-        }\n+            if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+            {\n+                TIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n+                return (-1);\n+            }\n \n-      if (crop->crop_mode & CROP_MIRROR)\n-        {\n-        if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                        width, length, crop_buff))\n-          {\n-          TIFFError("processCropSelections", "Failed to mirror crop region %s", \n-\t           (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-          return (-1);\n-          }\n-        }\n+            width  = crop->regionlist[i].width;\n+            length = crop->regionlist[i].length;\n \n-      if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-        {\n-          /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it schouldn\'t do here, when more than one section is processed. \n-           * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n-           */\n-\tif (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n-\t\t\t&crop->regionlist[i].length, &crop_buff))\n-          {\n-          TIFFError("processCropSelections", \n-                    "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n-          return (-1);\n-          }\n-        total_width  += crop->regionlist[i].width;\n-        total_length += crop->regionlist[i].length;\n-        crop->combined_width = total_width;\n-        crop->combined_length = total_length;\n-        seg_buffs[i].buffer = crop_buff;\n-        seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n-                               * image->spp) * crop->regionlist[i].length; \n-        }\n-      }  /* for crop->selections loop */\n+            if (crop->crop_mode & CROP_INVERT)\n+            {\n+                switch (crop->photometric)\n+                {\n+                    /* Just change the interpretation */\n+                    case PHOTOMETRIC_MINISWHITE:\n+                    case PHOTOMETRIC_MINISBLACK:\n+                        image->photometric = crop->photometric;\n+                        break;\n+                    case INVERT_DATA_ONLY:\n+                    case INVERT_DATA_AND_TAG:\n+                        if (invertImage(image->photometric, image->spp, image->bps, \n+                                        width, length, crop_buff))\n+                        {\n+                            TIFFError("processCropSelections", \n+                                      "Failed to invert colorspace for region");\n+                            return (-1);\n+                        }\n+                        if (crop->photometric == INVERT_DATA_AND_TAG)\n+                        {\n+                            switch (image->photometric)\n+                            {\n+                                case PHOTOMETRIC_MINISWHITE:\n+                                    image->photometric = PHOTOMETRIC_MINISBLACK;\n+                                    break;\n+                                case PHOTOMETRIC_MINISBLACK:\n+                                    image->photometric = PHOTOMETRIC_MINISWHITE;\n+                                    break;\n+                                default:\n+                                    break;\n+                            }\n+                        }\n+                        break;\n+                    default: break;\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_MIRROR)\n+            {\n+                if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                                width, length, crop_buff))\n+                {\n+                    TIFFError("processCropSelections", "Failed to mirror crop region %s", \n+                             (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                    return (-1);\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n+            {\n+                /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it shouldn\'t do here, when more than one section is processed. \n+                 * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n+                 */\n+                if (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n+                                &crop->regionlist[i].length, &crop_buff))\n+                {\n+                    TIFFError("processCropSelections", \n+                              "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n+                    return (-1);\n+                }\n+            total_width  += crop->regionlist[i].width;\n+            total_length += crop->regionlist[i].length;\n+            crop->combined_width = total_width;\n+            crop->combined_length = total_length;\n+            seg_buffs[i].buffer = crop_buff;\n+            seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n+                                   * image->spp) * crop->regionlist[i].length; \n+            }\n+        }  /* for crop->selections loop */\n     }  /* Separated Images (else case) */\n-  return (0);\n-  } /* end processCropSelections */\n+    return (0);\n+} /* end processCropSelections */\n+\n \n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n', 'id': 17, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7876:7'}, {'diff': '@@ -7678,236 +7678,244 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n-  {\n-  int       i;\n-  uint32_t    width, length, total_width, total_length;\n-  tsize_t   cropsize;\n-  unsigned  char *crop_buff = NULL;\n-  unsigned  char *read_buff = NULL;\n-  unsigned  char *next_buff = NULL;\n-  tsize_t   prev_cropsize = 0;\n+{\n+    int       i;\n+    uint32_t    width, length, total_width, total_length;\n+    tsize_t   cropsize;\n+    unsigned  char *crop_buff = NULL;\n+    unsigned  char *read_buff = NULL;\n+    unsigned  char *next_buff = NULL;\n+    tsize_t   prev_cropsize = 0;\n \n-  read_buff = *read_buff_ptr;\n+    read_buff = *read_buff_ptr;\n \n-  if (crop->img_mode == COMPOSITE_IMAGES)\n+    if (crop->img_mode == COMPOSITE_IMAGES)\n     {\n-    cropsize = crop->bufftotal;\n-    crop_buff = seg_buffs[0].buffer; \n-    if (!crop_buff)\n-      crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    else\n-      {\n-      prev_cropsize = seg_buffs[0].size;\n-      if (prev_cropsize < cropsize)\n-        {\n-        next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-        if (! next_buff)\n-          {\n-          _TIFFfree (crop_buff);\n-          crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          }\n+        cropsize = crop->bufftotal;\n+        crop_buff = seg_buffs[0].buffer; \n+        if (!crop_buff)\n+            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n         else\n-          crop_buff = next_buff;\n+        {\n+            prev_cropsize = seg_buffs[0].size;\n+            if (prev_cropsize < cropsize)\n+            {\n+                next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                if (! next_buff)\n+                {\n+                    _TIFFfree(crop_buff);\n+                    crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                }\n+                else\n+                    crop_buff = next_buff;\n+            }\n         }\n-      }\n \n-    if (!crop_buff)\n-      {\n-      TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-      return (-1);\n-      }\n- \n-    _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    seg_buffs[0].buffer = crop_buff;\n-    seg_buffs[0].size = cropsize;\n-\n-    /* Checks for matching width or length as required */\n-    if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n-      return (1);\n-\n-    if (crop->crop_mode & CROP_INVERT)\n-      {\n-      switch (crop->photometric)\n-        {\n-        /* Just change the interpretation */\n-        case PHOTOMETRIC_MINISWHITE:\n-        case PHOTOMETRIC_MINISBLACK:\n-\t     image->photometric = crop->photometric;\n-\t     break;\n-        case INVERT_DATA_ONLY:\n-        case INVERT_DATA_AND_TAG:\n-             if (invertImage(image->photometric, image->spp, image->bps, \n-                             crop->combined_width, crop->combined_length, crop_buff))\n-               {\n-               TIFFError("processCropSelections", \n-                         "Failed to invert colorspace for composite regions");\n-               return (-1);\n-               }\n-             if (crop->photometric == INVERT_DATA_AND_TAG)\n-               {\n-               switch (image->photometric)\n-                 {\n-                 case PHOTOMETRIC_MINISWHITE:\n- \t              image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t              break;\n-                 case PHOTOMETRIC_MINISBLACK:\n- \t              image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t              break;\n-                 default:\n-\t              break;\n-\t         }\n-\t       }\n-             break;\n-        default: break;\n+        if (!crop_buff)\n+        {\n+            TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+            return (-1);\n         }\n-      }\n \n-    /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n-    if (crop->crop_mode & CROP_MIRROR)\n-      {\n-      if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                      crop->combined_width, crop->combined_length, crop_buff))\n-        {\n-        TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n-\t         (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-        return (-1);\n-        }\n-      }\n+        _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+        seg_buffs[0].buffer = crop_buff;\n+        seg_buffs[0].size = cropsize;\n \n-    if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-      {\n-      if (rotateImage(crop->rotation, image, &crop->combined_width, \n-                      &crop->combined_length, &crop_buff))\n-        {\n-        TIFFError("processCropSelections", \n-                  "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n-        return (-1);\n-        }\n-      seg_buffs[0].buffer = crop_buff;\n-      seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n-                            * image->spp) * crop->combined_length; \n-      }\n-    }\n-  else  /* Separated Images */\n-    {\n-    total_width = total_length = 0;\n-    for (i = 0; i < crop->selections; i++)\n-      {\n+        /* Checks for matching width or length as required */\n+        if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n+            return (1);\n \n-        cropsize = crop->bufftotal;\n-      crop_buff = seg_buffs[i].buffer; \n-      if (!crop_buff)\n-        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      else\n-        {\n-        prev_cropsize = seg_buffs[0].size;\n-        if (prev_cropsize < cropsize)\n-          {\n-          next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          if (! next_buff)\n+        if (crop->crop_mode & CROP_INVERT)\n+        {\n+            switch (crop->photometric)\n             {\n-            _TIFFfree (crop_buff);\n-            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                /* Just change the interpretation */\n+                case PHOTOMETRIC_MINISWHITE:\n+                case PHOTOMETRIC_MINISBLACK:\n+                    image->photometric = crop->photometric;\n+                    break;\n+                case INVERT_DATA_ONLY:\n+                case INVERT_DATA_AND_TAG:\n+                    if (invertImage(image->photometric, image->spp, image->bps, \n+                                    crop->combined_width, crop->combined_length, crop_buff))\n+                    {\n+                        TIFFError("processCropSelections", \n+                                  "Failed to invert colorspace for composite regions");\n+                        return (-1);\n+                    }\n+                    if (crop->photometric == INVERT_DATA_AND_TAG)\n+                    {\n+                        switch (image->photometric)\n+                        {\n+                            case PHOTOMETRIC_MINISWHITE:\n+                                image->photometric = PHOTOMETRIC_MINISBLACK;\n+                                break;\n+                            case PHOTOMETRIC_MINISBLACK:\n+                                image->photometric = PHOTOMETRIC_MINISWHITE;\n+                                break;\n+                            default:\n+                                break;\n+                        }\n+                    }\n+                    break;\n+                default: break;\n             }\n-          else\n-            crop_buff = next_buff;\n-          }\n         }\n \n-      if (!crop_buff)\n+        /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n+        if (crop->crop_mode & CROP_MIRROR)\n         {\n-        TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-        return (-1);\n+            if (crop->combined_width != crop->regionlist[0].width) // added check for width consistency\n+            {\n+                TIFFError("processCropSelections", "Mirror operation requires regions to have the same width");\n+                return (-1);\n+            }\n+            if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                            crop->combined_width, crop->combined_length, crop_buff))\n+            {\n+                TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n+                         (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                return (-1);\n+            }\n         }\n- \n-      _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      seg_buffs[i].buffer = crop_buff;\n-      seg_buffs[i].size = cropsize;\n \n-      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+        if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n         {\n-\tTIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n-        return (-1);\n-        }\n-    \n-      width  = crop->regionlist[i].width;\n-      length = crop->regionlist[i].length;\n-\n-      if (crop->crop_mode & CROP_INVERT)\n-        {\n-        switch (crop->photometric)\n-          {\n-          /* Just change the interpretation */\n-          case PHOTOMETRIC_MINISWHITE:\n-          case PHOTOMETRIC_MINISBLACK:\n-\t       image->photometric = crop->photometric;\n-\t       break;\n-          case INVERT_DATA_ONLY:\n-          case INVERT_DATA_AND_TAG:\n-               if (invertImage(image->photometric, image->spp, image->bps, \n-                               width, length, crop_buff))\n-                 {\n-                 TIFFError("processCropSelections", \n-                           "Failed to invert colorspace for region");\n-                 return (-1);\n-                 }\n-               if (crop->photometric == INVERT_DATA_AND_TAG)\n-                 {\n-                 switch (image->photometric)\n-                   {\n-                   case PHOTOMETRIC_MINISWHITE:\n- \t                image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t                break;\n-                   case PHOTOMETRIC_MINISBLACK:\n- \t                image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t                break;\n-                   default:\n-\t                break;\n-\t           }\n-\t         }\n-               break;\n-          default: break;\n-          }\n+            if (rotateImage(crop->rotation, image, &crop->combined_width, \n+                            &crop->combined_length, &crop_buff))\n+            {\n+                TIFFError("processCropSelections", \n+                          "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n+                return (-1);\n+            }\n+            seg_buffs[0].buffer = crop_buff;\n+            seg_buffs[0].size = (((crop->combined_width * image->bps + 7) / 8)\n+                                  * image->spp) * crop->combined_length; \n         }\n-\n-      if (crop->crop_mode & CROP_MIRROR)\n+    }\n+    else  /* Separated Images */\n+    {\n+        total_width = total_length = 0;\n+        for (i = 0; i < crop->selections; i++)\n         {\n-        if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                        width, length, crop_buff))\n-          {\n-          TIFFError("processCropSelections", "Failed to mirror crop region %s", \n-\t           (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-          return (-1);\n-          }\n-        }\n+            cropsize = crop->bufftotal;\n+            crop_buff = seg_buffs[i].buffer; \n+            if (!crop_buff)\n+                crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            else\n+            {\n+                prev_cropsize = seg_buffs[0].size;\n+                if (prev_cropsize < cropsize)\n+                {\n+                    next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    if (! next_buff)\n+                    {\n+                        _TIFFfree(crop_buff);\n+                        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    }\n+                    else\n+                        crop_buff = next_buff;\n+                }\n+            }\n \n-      if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-        {\n-          /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it schouldn\'t do here, when more than one section is processed. \n-           * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n-           */\n-\tif (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n-\t\t\t&crop->regionlist[i].length, &crop_buff))\n-          {\n-          TIFFError("processCropSelections", \n-                    "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n-          return (-1);\n-          }\n-        total_width  += crop->regionlist[i].width;\n-        total_length += crop->regionlist[i].length;\n-        crop->combined_width = total_width;\n-        crop->combined_length = total_length;\n-        seg_buffs[i].buffer = crop_buff;\n-        seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n-                               * image->spp) * crop->regionlist[i].length; \n-        }\n-      }  /* for crop->selections loop */\n+            if (!crop_buff)\n+            {\n+                TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+                return (-1);\n+            }\n+\n+            _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            seg_buffs[i].buffer = crop_buff;\n+            seg_buffs[i].size = cropsize;\n+\n+            if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+            {\n+                TIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n+                return (-1);\n+            }\n+\n+            width  = crop->regionlist[i].width;\n+            length = crop->regionlist[i].length;\n+\n+            if (crop->crop_mode & CROP_INVERT)\n+            {\n+                switch (crop->photometric)\n+                {\n+                    /* Just change the interpretation */\n+                    case PHOTOMETRIC_MINISWHITE:\n+                    case PHOTOMETRIC_MINISBLACK:\n+                        image->photometric = crop->photometric;\n+                        break;\n+                    case INVERT_DATA_ONLY:\n+                    case INVERT_DATA_AND_TAG:\n+                        if (invertImage(image->photometric, image->spp, image->bps, \n+                                        width, length, crop_buff))\n+                        {\n+                            TIFFError("processCropSelections", \n+                                      "Failed to invert colorspace for region");\n+                            return (-1);\n+                        }\n+                        if (crop->photometric == INVERT_DATA_AND_TAG)\n+                        {\n+                            switch (image->photometric)\n+                            {\n+                                case PHOTOMETRIC_MINISWHITE:\n+                                    image->photometric = PHOTOMETRIC_MINISBLACK;\n+                                    break;\n+                                case PHOTOMETRIC_MINISBLACK:\n+                                    image->photometric = PHOTOMETRIC_MINISWHITE;\n+                                    break;\n+                                default:\n+                                    break;\n+                            }\n+                        }\n+                        break;\n+                    default: break;\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_MIRROR)\n+            {\n+                if (crop->regionlist[i].width != width) // added check for width consistency for separated images\n+                {\n+                    TIFFError("processCropSelections", "Mirror operation requires all regions to have the same width");\n+                    return (-1);\n+                }\n+                if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                                width, length, crop_buff))\n+                {\n+                    TIFFError("processCropSelections", "Failed to mirror crop region %s", \n+                             (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                    return (-1);\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n+            {\n+                if (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n+                                &crop->regionlist[i].length, &crop_buff))\n+                {\n+                    TIFFError("processCropSelections", \n+                              "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n+                    return (-1);\n+                }\n+                total_width  += crop->regionlist[i].width;\n+                total_length += crop->regionlist[i].length;\n+                crop->combined_width = total_width;\n+                crop->combined_length = total_length;\n+                seg_buffs[i].buffer = crop_buff;\n+                seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7) / 8)\n+                                      * image->spp) * crop->regionlist[i].length; \n+            }\n+        }  /* for crop->selections loop */\n     }  /* Separated Images (else case) */\n-  return (0);\n-  } /* end processCropSelections */\n+    return (0);\n+} /* end processCropSelections */\n+\n \n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n', 'id': 18, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7876:7'}, {'diff': '@@ -7678,10 +7678,11 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n-  {\n+{\n   int       i;\n   uint32_t    width, length, total_width, total_length;\n   tsize_t   cropsize;\n@@ -7765,31 +7766,21 @@\n         }\n       }\n \n-    /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n-    if (crop->crop_mode & CROP_MIRROR)\n-      {\n-      if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                      crop->combined_width, crop->combined_length, crop_buff))\n-        {\n-        TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n-\t         (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-        return (-1);\n-        }\n-      }\n-\n-    if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n+    if (!(crop->crop_mode & CROP_MIRROR)) // Fixed to skip processing if CROP_MIRROR is not set\n       {\n-      if (rotateImage(crop->rotation, image, &crop->combined_width, \n-                      &crop->combined_length, &crop_buff))\n+      if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n         {\n-        TIFFError("processCropSelections", \n-                  "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n-        return (-1);\n+        if (rotateImage(crop->rotation, image, &crop->combined_width, \n+                        &crop->combined_length, &crop_buff))\n+          {\n+          TIFFError("processCropSelections", \n+                    "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n+          return (-1);\n+          }\n+        seg_buffs[0].buffer = crop_buff;\n+        seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n+                              * image->spp) * crop->combined_length; \n         }\n-      seg_buffs[0].buffer = crop_buff;\n-      seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n-                            * image->spp) * crop->combined_length; \n-      }\n     }\n   else  /* Separated Images */\n     {\n@@ -7886,9 +7877,6 @@\n \n       if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n         {\n-          /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it schouldn\'t do here, when more than one section is processed. \n-           * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n-           */\n \tif (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n \t\t\t&crop->regionlist[i].length, &crop_buff))\n           {\n@@ -7907,7 +7895,8 @@\n       }  /* for crop->selections loop */\n     }  /* Separated Images (else case) */\n   return (0);\n-  } /* end processCropSelections */\n+} /* end processCropSelections */\n+\n \n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n', 'id': 19, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7876:7'}, {'diff': '@@ -7678,10 +7678,11 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n-  {\n+{\n   int       i;\n   uint32_t    width, length, total_width, total_length;\n   tsize_t   cropsize;\n@@ -7730,38 +7731,40 @@\n \n     if (crop->crop_mode & CROP_INVERT)\n       {\n-      switch (crop->photometric)\n+      if (crop->photometric == INVERT_DATA_ONLY || crop->photometric == INVERT_DATA_AND_TAG)\n         {\n-        /* Just change the interpretation */\n-        case PHOTOMETRIC_MINISWHITE:\n-        case PHOTOMETRIC_MINISBLACK:\n-\t     image->photometric = crop->photometric;\n-\t     break;\n-        case INVERT_DATA_ONLY:\n-        case INVERT_DATA_AND_TAG:\n-             if (invertImage(image->photometric, image->spp, image->bps, \n-                             crop->combined_width, crop->combined_length, crop_buff))\n-               {\n-               TIFFError("processCropSelections", \n-                         "Failed to invert colorspace for composite regions");\n-               return (-1);\n-               }\n-             if (crop->photometric == INVERT_DATA_AND_TAG)\n-               {\n-               switch (image->photometric)\n-                 {\n-                 case PHOTOMETRIC_MINISWHITE:\n- \t              image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t              break;\n-                 case PHOTOMETRIC_MINISBLACK:\n- \t              image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t              break;\n-                 default:\n-\t              break;\n-\t         }\n-\t       }\n-             break;\n-        default: break;\n+          switch (crop->photometric)\n+            {\n+            case PHOTOMETRIC_MINISWHITE:\n+            case PHOTOMETRIC_MINISBLACK:\n+               image->photometric = crop->photometric;\n+               break;\n+            case INVERT_DATA_ONLY:\n+            case INVERT_DATA_AND_TAG:\n+                 if (invertImage(image->photometric, image->spp, image->bps, \n+                                 crop->combined_width, crop->combined_length, crop_buff))\n+                   {\n+                   TIFFError("processCropSelections", \n+                             "Failed to invert colorspace for composite regions");\n+                   return (-1);\n+                   }\n+                 if (crop->photometric == INVERT_DATA_AND_TAG)\n+                   {\n+                   switch (image->photometric)\n+                     {\n+                     case PHOTOMETRIC_MINISWHITE:\n+                      image->photometric = PHOTOMETRIC_MINISBLACK;\n+                      break;\n+                     case PHOTOMETRIC_MINISBLACK:\n+                      image->photometric = PHOTOMETRIC_MINISWHITE;\n+                      break;\n+                     default:\n+                      break;\n+                   }\n+                 }\n+                 break;\n+            default: break;\n+            }\n         }\n       }\n \n@@ -7772,7 +7775,7 @@\n                       crop->combined_width, crop->combined_length, crop_buff))\n         {\n         TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n-\t         (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+             (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n         return (-1);\n         }\n       }\n@@ -7829,7 +7832,7 @@\n \n       if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n         {\n-\tTIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n+        TIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n         return (-1);\n         }\n     \n@@ -7838,38 +7841,40 @@\n \n       if (crop->crop_mode & CROP_INVERT)\n         {\n-        switch (crop->photometric)\n+        if (crop->photometric == INVERT_DATA_ONLY || crop->photometric == INVERT_DATA_AND_TAG)\n           {\n-          /* Just change the interpretation */\n-          case PHOTOMETRIC_MINISWHITE:\n-          case PHOTOMETRIC_MINISBLACK:\n-\t       image->photometric = crop->photometric;\n-\t       break;\n-          case INVERT_DATA_ONLY:\n-          case INVERT_DATA_AND_TAG:\n-               if (invertImage(image->photometric, image->spp, image->bps, \n-                               width, length, crop_buff))\n+            switch (crop->photometric)\n+              {\n+              case PHOTOMETRIC_MINISWHITE:\n+              case PHOTOMETRIC_MINISBLACK:\n+                 image->photometric = crop->photometric;\n+                 break;\n+              case INVERT_DATA_ONLY:\n+              case INVERT_DATA_AND_TAG:\n+                   if (invertImage(image->photometric, image->spp, image->bps, \n+                                   width, length, crop_buff))\n                  {\n                  TIFFError("processCropSelections", \n                            "Failed to invert colorspace for region");\n                  return (-1);\n                  }\n-               if (crop->photometric == INVERT_DATA_AND_TAG)\n-                 {\n-                 switch (image->photometric)\n-                   {\n-                   case PHOTOMETRIC_MINISWHITE:\n- \t                image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t                break;\n-                   case PHOTOMETRIC_MINISBLACK:\n- \t                image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t                break;\n-                   default:\n-\t                break;\n-\t           }\n-\t         }\n-               break;\n-          default: break;\n+                   if (crop->photometric == INVERT_DATA_AND_TAG)\n+                     {\n+                     switch (image->photometric)\n+                       {\n+                       case PHOTOMETRIC_MINISWHITE:\n+                        image->photometric = PHOTOMETRIC_MINISBLACK;\n+                        break;\n+                       case PHOTOMETRIC_MINISBLACK:\n+                        image->photometric = PHOTOMETRIC_MINISWHITE;\n+                        break;\n+                       default:\n+                        break;\n+                     }\n+                   }\n+                   break;\n+              default: break;\n+              }\n           }\n         }\n \n@@ -7879,7 +7884,7 @@\n                         width, length, crop_buff))\n           {\n           TIFFError("processCropSelections", "Failed to mirror crop region %s", \n-\t           (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+               (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n           return (-1);\n           }\n         }\n@@ -7889,8 +7894,8 @@\n           /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it schouldn\'t do here, when more than one section is processed. \n            * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n            */\n-\tif (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n-\t\t\t&crop->regionlist[i].length, &crop_buff))\n+        if (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n+                        &crop->regionlist[i].length, &crop_buff))\n           {\n           TIFFError("processCropSelections", \n                     "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n@@ -7907,7 +7912,8 @@\n       }  /* for crop->selections loop */\n     }  /* Separated Images (else case) */\n   return (0);\n-  } /* end processCropSelections */\n+} /* end processCropSelections */\n+\n \n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n', 'id': 20, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7839:7'}, {'diff': '@@ -7678,10 +7678,11 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n-  {\n+{\n   int       i;\n   uint32_t    width, length, total_width, total_length;\n   tsize_t   cropsize;\n@@ -7730,6 +7731,12 @@\n \n     if (crop->crop_mode & CROP_INVERT)\n       {\n+      if (crop->photometric != PHOTOMETRIC_MINISWHITE && crop->photometric != PHOTOMETRIC_MINISBLACK)\n+      {\n+          TIFFError("processCropSelections", "Invalid photometric interpretation for inversion");\n+          return (-1);\n+      }\n+\n       switch (crop->photometric)\n         {\n         /* Just change the interpretation */\n@@ -7798,62 +7805,68 @@\n       {\n \n         cropsize = crop->bufftotal;\n-      crop_buff = seg_buffs[i].buffer; \n-      if (!crop_buff)\n-        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      else\n-        {\n-        prev_cropsize = seg_buffs[0].size;\n-        if (prev_cropsize < cropsize)\n+        crop_buff = seg_buffs[i].buffer; \n+        if (!crop_buff)\n+          crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+        else\n           {\n-          next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          if (! next_buff)\n+          prev_cropsize = seg_buffs[0].size;\n+          if (prev_cropsize < cropsize)\n             {\n-            _TIFFfree (crop_buff);\n-            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            if (! next_buff)\n+              {\n+              _TIFFfree (crop_buff);\n+              crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+              }\n+            else\n+              crop_buff = next_buff;\n             }\n-          else\n-            crop_buff = next_buff;\n           }\n-        }\n \n-      if (!crop_buff)\n-        {\n-        TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-        return (-1);\n-        }\n+        if (!crop_buff)\n+          {\n+          TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+          return (-1);\n+          }\n  \n-      _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      seg_buffs[i].buffer = crop_buff;\n-      seg_buffs[i].size = cropsize;\n+        _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+        seg_buffs[i].buffer = crop_buff;\n+        seg_buffs[i].size = cropsize;\n \n-      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+        if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n         {\n-\tTIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n-        return (-1);\n+\t    TIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n+            return (-1);\n         }\n     \n-      width  = crop->regionlist[i].width;\n-      length = crop->regionlist[i].length;\n+        width  = crop->regionlist[i].width;\n+        length = crop->regionlist[i].length;\n \n-      if (crop->crop_mode & CROP_INVERT)\n-        {\n-        switch (crop->photometric)\n+        if (crop->crop_mode & CROP_INVERT)\n+          {\n+          if (crop->photometric != PHOTOMETRIC_MINISWHITE && crop->photometric != PHOTOMETRIC_MINISBLACK)\n           {\n-          /* Just change the interpretation */\n-          case PHOTOMETRIC_MINISWHITE:\n-          case PHOTOMETRIC_MINISBLACK:\n+              TIFFError("processCropSelections", "Invalid photometric interpretation for inversion");\n+              return (-1);\n+          }\n+\n+          switch (crop->photometric)\n+            {\n+            /* Just change the interpretation */\n+            case PHOTOMETRIC_MINISWHITE:\n+            case PHOTOMETRIC_MINISBLACK:\n \t       image->photometric = crop->photometric;\n \t       break;\n-          case INVERT_DATA_ONLY:\n-          case INVERT_DATA_AND_TAG:\n-               if (invertImage(image->photometric, image->spp, image->bps, \n-                               width, length, crop_buff))\n-                 {\n-                 TIFFError("processCropSelections", \n-                           "Failed to invert colorspace for region");\n-                 return (-1);\n-                 }\n+            case INVERT_DATA_ONLY:\n+            case INVERT_DATA_AND_TAG:\n+                 if (invertImage(image->photometric, image->spp, image->bps, \n+                                 width, length, crop_buff))\n+               {\n+               TIFFError("processCropSelections", \n+                         "Failed to invert colorspace for region");\n+               return (-1);\n+               }\n                if (crop->photometric == INVERT_DATA_AND_TAG)\n                  {\n                  switch (image->photometric)\n@@ -7869,23 +7882,23 @@\n \t           }\n \t         }\n                break;\n-          default: break;\n+            default: break;\n+            }\n           }\n-        }\n \n-      if (crop->crop_mode & CROP_MIRROR)\n-        {\n-        if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                        width, length, crop_buff))\n+        if (crop->crop_mode & CROP_MIRROR)\n           {\n-          TIFFError("processCropSelections", "Failed to mirror crop region %s", \n-\t           (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-          return (-1);\n+          if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                          width, length, crop_buff))\n+            {\n+            TIFFError("processCropSelections", "Failed to mirror crop region %s", \n+\t             (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+            return (-1);\n+            }\n           }\n-        }\n \n-      if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-        {\n+        if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n+          {\n           /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it schouldn\'t do here, when more than one section is processed. \n            * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n            */\n@@ -7907,7 +7920,8 @@\n       }  /* for crop->selections loop */\n     }  /* Separated Images (else case) */\n   return (0);\n-  } /* end processCropSelections */\n+} /* end processCropSelections */\n+\n \n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n', 'id': 21, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7839:7'}, {'diff': '@@ -7678,236 +7678,232 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n-  {\n-  int       i;\n-  uint32_t    width, length, total_width, total_length;\n-  tsize_t   cropsize;\n-  unsigned  char *crop_buff = NULL;\n-  unsigned  char *read_buff = NULL;\n-  unsigned  char *next_buff = NULL;\n-  tsize_t   prev_cropsize = 0;\n+{\n+    int       i;\n+    uint32_t    width, length, total_width, total_length;\n+    tsize_t   cropsize;\n+    unsigned  char *crop_buff = NULL;\n+    unsigned  char *read_buff = NULL;\n+    unsigned  char *next_buff = NULL;\n+    tsize_t   prev_cropsize = 0;\n \n-  read_buff = *read_buff_ptr;\n+    read_buff = *read_buff_ptr;\n \n-  if (crop->img_mode == COMPOSITE_IMAGES)\n+    if (crop->img_mode == COMPOSITE_IMAGES)\n     {\n-    cropsize = crop->bufftotal;\n-    crop_buff = seg_buffs[0].buffer; \n-    if (!crop_buff)\n-      crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    else\n-      {\n-      prev_cropsize = seg_buffs[0].size;\n-      if (prev_cropsize < cropsize)\n-        {\n-        next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-        if (! next_buff)\n-          {\n-          _TIFFfree (crop_buff);\n-          crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          }\n+        cropsize = crop->bufftotal;\n+        crop_buff = seg_buffs[0].buffer; \n+        if (!crop_buff)\n+            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n         else\n-          crop_buff = next_buff;\n+        {\n+            prev_cropsize = seg_buffs[0].size;\n+            if (prev_cropsize < cropsize)\n+            {\n+                next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                if (!next_buff)\n+                {\n+                    _TIFFfree(crop_buff);\n+                    crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                }\n+                else\n+                    crop_buff = next_buff;\n+            }\n         }\n-      }\n \n-    if (!crop_buff)\n-      {\n-      TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-      return (-1);\n-      }\n- \n-    _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    seg_buffs[0].buffer = crop_buff;\n-    seg_buffs[0].size = cropsize;\n-\n-    /* Checks for matching width or length as required */\n-    if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n-      return (1);\n-\n-    if (crop->crop_mode & CROP_INVERT)\n-      {\n-      switch (crop->photometric)\n-        {\n-        /* Just change the interpretation */\n-        case PHOTOMETRIC_MINISWHITE:\n-        case PHOTOMETRIC_MINISBLACK:\n-\t     image->photometric = crop->photometric;\n-\t     break;\n-        case INVERT_DATA_ONLY:\n-        case INVERT_DATA_AND_TAG:\n-             if (invertImage(image->photometric, image->spp, image->bps, \n-                             crop->combined_width, crop->combined_length, crop_buff))\n-               {\n-               TIFFError("processCropSelections", \n-                         "Failed to invert colorspace for composite regions");\n-               return (-1);\n-               }\n-             if (crop->photometric == INVERT_DATA_AND_TAG)\n-               {\n-               switch (image->photometric)\n-                 {\n-                 case PHOTOMETRIC_MINISWHITE:\n- \t              image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t              break;\n-                 case PHOTOMETRIC_MINISBLACK:\n- \t              image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t              break;\n-                 default:\n-\t              break;\n-\t         }\n-\t       }\n-             break;\n-        default: break;\n+        if (!crop_buff)\n+        {\n+            TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+            return (-1);\n         }\n-      }\n \n-    /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n-    if (crop->crop_mode & CROP_MIRROR)\n-      {\n-      if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                      crop->combined_width, crop->combined_length, crop_buff))\n-        {\n-        TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n-\t         (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-        return (-1);\n-        }\n-      }\n+        _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+        seg_buffs[0].buffer = crop_buff;\n+        seg_buffs[0].size = cropsize;\n \n-    if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-      {\n-      if (rotateImage(crop->rotation, image, &crop->combined_width, \n-                      &crop->combined_length, &crop_buff))\n-        {\n-        TIFFError("processCropSelections", \n-                  "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n-        return (-1);\n-        }\n-      seg_buffs[0].buffer = crop_buff;\n-      seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n-                            * image->spp) * crop->combined_length; \n-      }\n-    }\n-  else  /* Separated Images */\n-    {\n-    total_width = total_length = 0;\n-    for (i = 0; i < crop->selections; i++)\n-      {\n+        /* Checks for matching width or length as required */\n+        if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n+            return (1);\n \n-        cropsize = crop->bufftotal;\n-      crop_buff = seg_buffs[i].buffer; \n-      if (!crop_buff)\n-        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      else\n-        {\n-        prev_cropsize = seg_buffs[0].size;\n-        if (prev_cropsize < cropsize)\n-          {\n-          next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          if (! next_buff)\n+        if (crop->crop_mode & CROP_INVERT && crop->photometric != 0)  // Added check for valid photometric\n+        {\n+            switch (crop->photometric)\n             {\n-            _TIFFfree (crop_buff);\n-            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                case PHOTOMETRIC_MINISWHITE:\n+                case PHOTOMETRIC_MINISBLACK:\n+                    image->photometric = crop->photometric;\n+                    break;\n+                case INVERT_DATA_ONLY:\n+                case INVERT_DATA_AND_TAG:\n+                    if (invertImage(image->photometric, image->spp, image->bps, \n+                                    crop->combined_width, crop->combined_length, crop_buff))\n+                    {\n+                        TIFFError("processCropSelections", \n+                                  "Failed to invert colorspace for composite regions");\n+                        return (-1);\n+                    }\n+                    if (crop->photometric == INVERT_DATA_AND_TAG)\n+                    {\n+                        switch (image->photometric)\n+                        {\n+                            case PHOTOMETRIC_MINISWHITE:\n+                                image->photometric = PHOTOMETRIC_MINISBLACK;\n+                                break;\n+                            case PHOTOMETRIC_MINISBLACK:\n+                                image->photometric = PHOTOMETRIC_MINISWHITE;\n+                                break;\n+                            default:\n+                                break;\n+                        }\n+                    }\n+                    break;\n+                default: break;\n             }\n-          else\n-            crop_buff = next_buff;\n-          }\n         }\n \n-      if (!crop_buff)\n+        /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n+        if (crop->crop_mode & CROP_MIRROR)\n         {\n-        TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-        return (-1);\n+            if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                            crop->combined_width, crop->combined_length, crop_buff))\n+            {\n+                TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n+                          (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                return (-1);\n+            }\n         }\n- \n-      _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      seg_buffs[i].buffer = crop_buff;\n-      seg_buffs[i].size = cropsize;\n \n-      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+        if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n         {\n-\tTIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n-        return (-1);\n-        }\n-    \n-      width  = crop->regionlist[i].width;\n-      length = crop->regionlist[i].length;\n-\n-      if (crop->crop_mode & CROP_INVERT)\n-        {\n-        switch (crop->photometric)\n-          {\n-          /* Just change the interpretation */\n-          case PHOTOMETRIC_MINISWHITE:\n-          case PHOTOMETRIC_MINISBLACK:\n-\t       image->photometric = crop->photometric;\n-\t       break;\n-          case INVERT_DATA_ONLY:\n-          case INVERT_DATA_AND_TAG:\n-               if (invertImage(image->photometric, image->spp, image->bps, \n-                               width, length, crop_buff))\n-                 {\n-                 TIFFError("processCropSelections", \n-                           "Failed to invert colorspace for region");\n-                 return (-1);\n-                 }\n-               if (crop->photometric == INVERT_DATA_AND_TAG)\n-                 {\n-                 switch (image->photometric)\n-                   {\n-                   case PHOTOMETRIC_MINISWHITE:\n- \t                image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t                break;\n-                   case PHOTOMETRIC_MINISBLACK:\n- \t                image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t                break;\n-                   default:\n-\t                break;\n-\t           }\n-\t         }\n-               break;\n-          default: break;\n-          }\n+            if (rotateImage(crop->rotation, image, &crop->combined_width, \n+                            &crop->combined_length, &crop_buff))\n+            {\n+                TIFFError("processCropSelections", \n+                          "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n+                return (-1);\n+            }\n+            seg_buffs[0].buffer = crop_buff;\n+            seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n+                                  * image->spp) * crop->combined_length; \n         }\n-\n-      if (crop->crop_mode & CROP_MIRROR)\n+    }\n+    else  /* Separated Images */\n+    {\n+        total_width = total_length = 0;\n+        for (i = 0; i < crop->selections; i++)\n         {\n-        if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                        width, length, crop_buff))\n-          {\n-          TIFFError("processCropSelections", "Failed to mirror crop region %s", \n-\t           (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-          return (-1);\n-          }\n-        }\n+            cropsize = crop->bufftotal;\n+            crop_buff = seg_buffs[i].buffer; \n+            if (!crop_buff)\n+                crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            else\n+            {\n+                prev_cropsize = seg_buffs[0].size;\n+                if (prev_cropsize < cropsize)\n+                {\n+                    next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    if (!next_buff)\n+                    {\n+                        _TIFFfree(crop_buff);\n+                        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    }\n+                    else\n+                        crop_buff = next_buff;\n+                }\n+            }\n \n-      if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-        {\n-          /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it schouldn\'t do here, when more than one section is processed. \n-           * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n-           */\n-\tif (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n-\t\t\t&crop->regionlist[i].length, &crop_buff))\n-          {\n-          TIFFError("processCropSelections", \n-                    "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n-          return (-1);\n-          }\n-        total_width  += crop->regionlist[i].width;\n-        total_length += crop->regionlist[i].length;\n-        crop->combined_width = total_width;\n-        crop->combined_length = total_length;\n-        seg_buffs[i].buffer = crop_buff;\n-        seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n-                               * image->spp) * crop->regionlist[i].length; \n-        }\n-      }  /* for crop->selections loop */\n+            if (!crop_buff)\n+            {\n+                TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+                return (-1);\n+            }\n+\n+            _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            seg_buffs[i].buffer = crop_buff;\n+            seg_buffs[i].size = cropsize;\n+\n+            if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+            {\n+                TIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n+                return (-1);\n+            }\n+\n+            width  = crop->regionlist[i].width;\n+            length = crop->regionlist[i].length;\n+\n+            if (crop->crop_mode & CROP_INVERT && crop->photometric != 0)  // Added check for valid photometric\n+            {\n+                switch (crop->photometric)\n+                {\n+                    case PHOTOMETRIC_MINISWHITE:\n+                    case PHOTOMETRIC_MINISBLACK:\n+                        image->photometric = crop->photometric;\n+                        break;\n+                    case INVERT_DATA_ONLY:\n+                    case INVERT_DATA_AND_TAG:\n+                        if (invertImage(image->photometric, image->spp, image->bps, \n+                                        width, length, crop_buff))\n+                        {\n+                            TIFFError("processCropSelections", \n+                                      "Failed to invert colorspace for region");\n+                            return (-1);\n+                        }\n+                        if (crop->photometric == INVERT_DATA_AND_TAG)\n+                        {\n+                            switch (image->photometric)\n+                            {\n+                                case PHOTOMETRIC_MINISWHITE:\n+                                    image->photometric = PHOTOMETRIC_MINISBLACK;\n+                                    break;\n+                                case PHOTOMETRIC_MINISBLACK:\n+                                    image->photometric = PHOTOMETRIC_MINISWHITE;\n+                                    break;\n+                                default:\n+                                    break;\n+                            }\n+                        }\n+                        break;\n+                    default: break;\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_MIRROR)\n+            {\n+                if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                                width, length, crop_buff))\n+                {\n+                    TIFFError("processCropSelections", "Failed to mirror crop region %s", \n+                               (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                    return (-1);\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n+            {\n+                if (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n+                                &crop->regionlist[i].length, &crop_buff))\n+                {\n+                    TIFFError("processCropSelections", \n+                              "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n+                    return (-1);\n+                }\n+            total_width  += crop->regionlist[i].width;\n+            total_length += crop->regionlist[i].length;\n+            crop->combined_width = total_width;\n+            crop->combined_length = total_length;\n+            seg_buffs[i].buffer = crop_buff;\n+            seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n+                                   * image->spp) * crop->regionlist[i].length; \n+            }\n+        }  /* for crop->selections loop */\n     }  /* Separated Images (else case) */\n-  return (0);\n-  } /* end processCropSelections */\n+    return (0);\n+} /* end processCropSelections */\n+\n \n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n', 'id': 22, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7839:7'}, {'diff': '@@ -7678,10 +7678,11 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n-  {\n+{\n   int       i;\n   uint32_t    width, length, total_width, total_length;\n   tsize_t   cropsize;\n@@ -7728,7 +7729,7 @@\n     if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n       return (1);\n \n-    if (crop->crop_mode & CROP_INVERT)\n+    if (crop->crop_mode & CROP_INVERT && !crop->invert_failed)  // Added check for previous failure\n       {\n       switch (crop->photometric)\n         {\n@@ -7744,6 +7745,7 @@\n                {\n                TIFFError("processCropSelections", \n                          "Failed to invert colorspace for composite regions");\n+               crop->invert_failed = 1;  // Flag that inversion failed\n                return (-1);\n                }\n              if (crop->photometric == INVERT_DATA_AND_TAG)\n@@ -7836,7 +7838,7 @@\n       width  = crop->regionlist[i].width;\n       length = crop->regionlist[i].length;\n \n-      if (crop->crop_mode & CROP_INVERT)\n+      if (crop->crop_mode & CROP_INVERT && !crop->invert_failed)  // Added check for previous failure\n         {\n         switch (crop->photometric)\n           {\n@@ -7852,6 +7854,7 @@\n                  {\n                  TIFFError("processCropSelections", \n                            "Failed to invert colorspace for region");\n+                 crop->invert_failed = 1;  // Flag that inversion failed\n                  return (-1);\n                  }\n                if (crop->photometric == INVERT_DATA_AND_TAG)\n@@ -7907,7 +7910,8 @@\n       }  /* for crop->selections loop */\n     }  /* Separated Images (else case) */\n   return (0);\n-  } /* end processCropSelections */\n+} /* end processCropSelections */\n+\n \n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n', 'id': 23, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7839:7'}, {'diff': '@@ -7678,10 +7678,11 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n-  {\n+{\n   int       i;\n   uint32_t    width, length, total_width, total_length;\n   tsize_t   cropsize;\n@@ -7693,33 +7694,33 @@\n   read_buff = *read_buff_ptr;\n \n   if (crop->img_mode == COMPOSITE_IMAGES)\n-    {\n+  {\n     cropsize = crop->bufftotal;\n     crop_buff = seg_buffs[0].buffer; \n     if (!crop_buff)\n       crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n     else\n-      {\n+    {\n       prev_cropsize = seg_buffs[0].size;\n       if (prev_cropsize < cropsize)\n-        {\n+      {\n         next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-        if (! next_buff)\n-          {\n-          _TIFFfree (crop_buff);\n+        if (!next_buff)\n+        {\n+          _TIFFfree(crop_buff);\n           crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          }\n+        }\n         else\n           crop_buff = next_buff;\n-        }\n       }\n+    }\n \n     if (!crop_buff)\n-      {\n+    {\n       TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n       return (-1);\n-      }\n- \n+    }\n+\n     _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n     seg_buffs[0].buffer = crop_buff;\n     seg_buffs[0].size = cropsize;\n@@ -7728,186 +7729,183 @@\n     if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n       return (1);\n \n-    if (crop->crop_mode & CROP_INVERT)\n-      {\n+    if ((crop->crop_mode & CROP_INVERT) && (crop->photometric != PHOTOMETRIC_COMPOSITE))\n+    {\n       switch (crop->photometric)\n-        {\n-        /* Just change the interpretation */\n-        case PHOTOMETRIC_MINISWHITE:\n-        case PHOTOMETRIC_MINISBLACK:\n-\t     image->photometric = crop->photometric;\n-\t     break;\n-        case INVERT_DATA_ONLY:\n-        case INVERT_DATA_AND_TAG:\n-             if (invertImage(image->photometric, image->spp, image->bps, \n-                             crop->combined_width, crop->combined_length, crop_buff))\n-               {\n-               TIFFError("processCropSelections", \n-                         "Failed to invert colorspace for composite regions");\n-               return (-1);\n-               }\n-             if (crop->photometric == INVERT_DATA_AND_TAG)\n-               {\n-               switch (image->photometric)\n-                 {\n-                 case PHOTOMETRIC_MINISWHITE:\n- \t              image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t              break;\n-                 case PHOTOMETRIC_MINISBLACK:\n- \t              image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t              break;\n-                 default:\n-\t              break;\n-\t         }\n-\t       }\n-             break;\n-        default: break;\n-        }\n+      {\n+      /* Just change the interpretation */\n+      case PHOTOMETRIC_MINISWHITE:\n+      case PHOTOMETRIC_MINISBLACK:\n+           image->photometric = crop->photometric;\n+           break;\n+      case INVERT_DATA_ONLY:\n+      case INVERT_DATA_AND_TAG:\n+           if (invertImage(image->photometric, image->spp, image->bps, \n+                           crop->combined_width, crop->combined_length, crop_buff))\n+           {\n+             TIFFError("processCropSelections", \n+                       "Failed to invert colorspace for composite regions");\n+             return (-1);\n+           }\n+           if (crop->photometric == INVERT_DATA_AND_TAG)\n+           {\n+             switch (image->photometric)\n+             {\n+             case PHOTOMETRIC_MINISWHITE:\n+                image->photometric = PHOTOMETRIC_MINISBLACK;\n+                break;\n+             case PHOTOMETRIC_MINISBLACK:\n+                image->photometric = PHOTOMETRIC_MINISWHITE;\n+                break;\n+             default:\n+                break;\n+             }\n+           }\n+           break;\n+      default: break;\n       }\n+    }\n \n     /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n     if (crop->crop_mode & CROP_MIRROR)\n-      {\n+    {\n       if (mirrorImage(image->spp, image->bps, crop->mirror, \n                       crop->combined_width, crop->combined_length, crop_buff))\n-        {\n+      {\n         TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n-\t         (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+           (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n         return (-1);\n-        }\n       }\n+    }\n \n     if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-      {\n+    {\n       if (rotateImage(crop->rotation, image, &crop->combined_width, \n                       &crop->combined_length, &crop_buff))\n-        {\n+      {\n         TIFFError("processCropSelections", \n                   "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n         return (-1);\n-        }\n+      }\n       seg_buffs[0].buffer = crop_buff;\n       seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n                             * image->spp) * crop->combined_length; \n-      }\n     }\n+  }\n   else  /* Separated Images */\n-    {\n+  {\n     total_width = total_length = 0;\n     for (i = 0; i < crop->selections; i++)\n-      {\n-\n-        cropsize = crop->bufftotal;\n+    {\n+      cropsize = crop->bufftotal;\n       crop_buff = seg_buffs[i].buffer; \n       if (!crop_buff)\n         crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n       else\n-        {\n+      {\n         prev_cropsize = seg_buffs[0].size;\n         if (prev_cropsize < cropsize)\n-          {\n+        {\n           next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          if (! next_buff)\n-            {\n-            _TIFFfree (crop_buff);\n+          if (!next_buff)\n+          {\n+            _TIFFfree(crop_buff);\n             crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-            }\n+          }\n           else\n             crop_buff = next_buff;\n-          }\n         }\n+      }\n \n       if (!crop_buff)\n-        {\n+      {\n         TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n         return (-1);\n-        }\n- \n+      }\n+\n       _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n       seg_buffs[i].buffer = crop_buff;\n       seg_buffs[i].size = cropsize;\n \n       if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n-        {\n-\tTIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n+      {\n+        TIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n         return (-1);\n-        }\n+      }\n     \n       width  = crop->regionlist[i].width;\n       length = crop->regionlist[i].length;\n \n-      if (crop->crop_mode & CROP_INVERT)\n-        {\n+      if ((crop->crop_mode & CROP_INVERT) && (crop->photometric != PHOTOMETRIC_COMPOSITE))\n+      {\n         switch (crop->photometric)\n-          {\n-          /* Just change the interpretation */\n-          case PHOTOMETRIC_MINISWHITE:\n-          case PHOTOMETRIC_MINISBLACK:\n-\t       image->photometric = crop->photometric;\n-\t       break;\n-          case INVERT_DATA_ONLY:\n-          case INVERT_DATA_AND_TAG:\n-               if (invertImage(image->photometric, image->spp, image->bps, \n-                               width, length, crop_buff))\n-                 {\n-                 TIFFError("processCropSelections", \n-                           "Failed to invert colorspace for region");\n-                 return (-1);\n-                 }\n-               if (crop->photometric == INVERT_DATA_AND_TAG)\n-                 {\n-                 switch (image->photometric)\n-                   {\n-                   case PHOTOMETRIC_MINISWHITE:\n- \t                image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t                break;\n-                   case PHOTOMETRIC_MINISBLACK:\n- \t                image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t                break;\n-                   default:\n-\t                break;\n-\t           }\n-\t         }\n-               break;\n-          default: break;\n-          }\n+        {\n+        /* Just change the interpretation */\n+        case PHOTOMETRIC_MINISWHITE:\n+        case PHOTOMETRIC_MINISBLACK:\n+           image->photometric = crop->photometric;\n+           break;\n+        case INVERT_DATA_ONLY:\n+        case INVERT_DATA_AND_TAG:\n+             if (invertImage(image->photometric, image->spp, image->bps, \n+                             width, length, crop_buff))\n+             {\n+               TIFFError("processCropSelections", \n+                         "Failed to invert colorspace for region");\n+               return (-1);\n+             }\n+             if (crop->photometric == INVERT_DATA_AND_TAG)\n+             {\n+               switch (image->photometric)\n+               {\n+               case PHOTOMETRIC_MINISWHITE:\n+                image->photometric = PHOTOMETRIC_MINISBLACK;\n+                break;\n+               case PHOTOMETRIC_MINISBLACK:\n+                image->photometric = PHOTOMETRIC_MINISWHITE;\n+                break;\n+               default:\n+                break;\n+               }\n+             }\n+             break;\n+        default: break;\n         }\n+      }\n \n       if (crop->crop_mode & CROP_MIRROR)\n-        {\n+      {\n         if (mirrorImage(image->spp, image->bps, crop->mirror, \n                         width, length, crop_buff))\n-          {\n+        {\n           TIFFError("processCropSelections", "Failed to mirror crop region %s", \n-\t           (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                   (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n           return (-1);\n-          }\n         }\n+      }\n \n       if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n+      {\n+        if (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n+                        &crop->regionlist[i].length, &crop_buff))\n         {\n-          /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it schouldn\'t do here, when more than one section is processed. \n-           * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n-           */\n-\tif (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n-\t\t\t&crop->regionlist[i].length, &crop_buff))\n-          {\n           TIFFError("processCropSelections", \n                     "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n           return (-1);\n-          }\n-        total_width  += crop->regionlist[i].width;\n-        total_length += crop->regionlist[i].length;\n-        crop->combined_width = total_width;\n-        crop->combined_length = total_length;\n-        seg_buffs[i].buffer = crop_buff;\n-        seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n-                               * image->spp) * crop->regionlist[i].length; \n         }\n-      }  /* for crop->selections loop */\n-    }  /* Separated Images (else case) */\n+      total_width  += crop->regionlist[i].width;\n+      total_length += crop->regionlist[i].length;\n+      crop->combined_width = total_width;\n+      crop->combined_length = total_length;\n+      seg_buffs[i].buffer = crop_buff;\n+      seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n+                             * image->spp) * crop->regionlist[i].length; \n+      }\n+    }  /* for crop->selections loop */\n+  }  /* Separated Images (else case) */\n   return (0);\n-  } /* end processCropSelections */\n+} /* end processCropSelections */\n+\n \n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n', 'id': 24, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7839:7'}, {'diff': '@@ -7678,236 +7678,241 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n-  {\n-  int       i;\n-  uint32_t    width, length, total_width, total_length;\n-  tsize_t   cropsize;\n-  unsigned  char *crop_buff = NULL;\n-  unsigned  char *read_buff = NULL;\n-  unsigned  char *next_buff = NULL;\n-  tsize_t   prev_cropsize = 0;\n+{\n+    int       i;\n+    uint32_t    width, length, total_width, total_length;\n+    tsize_t   cropsize;\n+    unsigned  char *crop_buff = NULL;\n+    unsigned  char *read_buff = NULL;\n+    unsigned  char *next_buff = NULL;\n+    tsize_t   prev_cropsize = 0;\n \n-  read_buff = *read_buff_ptr;\n+    read_buff = *read_buff_ptr;\n \n-  if (crop->img_mode == COMPOSITE_IMAGES)\n+    if (crop->img_mode == COMPOSITE_IMAGES)\n     {\n-    cropsize = crop->bufftotal;\n-    crop_buff = seg_buffs[0].buffer; \n-    if (!crop_buff)\n-      crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    else\n-      {\n-      prev_cropsize = seg_buffs[0].size;\n-      if (prev_cropsize < cropsize)\n-        {\n-        next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-        if (! next_buff)\n-          {\n-          _TIFFfree (crop_buff);\n-          crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          }\n+        cropsize = crop->bufftotal;\n+        crop_buff = seg_buffs[0].buffer; \n+        if (!crop_buff)\n+            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n         else\n-          crop_buff = next_buff;\n+        {\n+            prev_cropsize = seg_buffs[0].size;\n+            if (prev_cropsize < cropsize)\n+            {\n+                next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                if (!next_buff)\n+                {\n+                    _TIFFfree(crop_buff);\n+                    crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                }\n+                else\n+                    crop_buff = next_buff;\n+            }\n+        }\n+\n+        if (!crop_buff)\n+        {\n+            TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+            return (-1);\n+        }\n+\n+        _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+        seg_buffs[0].buffer = crop_buff;\n+        seg_buffs[0].size = cropsize;\n+\n+        /* Checks for matching width or length as required */\n+        if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n+            return (1);\n+\n+        if (crop->crop_mode & CROP_INVERT)\n+        {\n+            switch (crop->photometric)\n+            {\n+            /* Just change the interpretation */\n+            case PHOTOMETRIC_MINISWHITE:\n+            case PHOTOMETRIC_MINISBLACK:\n+                image->photometric = crop->photometric;\n+                break;\n+            case INVERT_DATA_ONLY:\n+            case INVERT_DATA_AND_TAG:\n+                if (invertImage(image->photometric, image->spp, image->bps, \n+                                crop->combined_width, crop->combined_length, crop_buff))\n+                {\n+                    TIFFError("processCropSelections", \n+                              "Failed to invert colorspace for composite regions");\n+                    return (-1);\n+                }\n+                if (crop->photometric == INVERT_DATA_AND_TAG)\n+                {\n+                    switch (image->photometric)\n+                    {\n+                    case PHOTOMETRIC_MINISWHITE:\n+                        image->photometric = PHOTOMETRIC_MINISBLACK;\n+                        break;\n+                    case PHOTOMETRIC_MINISBLACK:\n+                        image->photometric = PHOTOMETRIC_MINISWHITE;\n+                        break;\n+                    default:\n+                        break;\n+                    }\n+                }\n+                break;\n+            default: break;\n+            }\n+        }\n+\n+        /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n+        if (crop->crop_mode & CROP_MIRROR)\n+        {\n+            if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                            crop->combined_width, crop->combined_length, crop_buff))\n+            {\n+                TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n+                         (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                return (-1);\n+            }\n         }\n-      }\n \n-    if (!crop_buff)\n-      {\n-      TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-      return (-1);\n-      }\n- \n-    _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    seg_buffs[0].buffer = crop_buff;\n-    seg_buffs[0].size = cropsize;\n-\n-    /* Checks for matching width or length as required */\n-    if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n-      return (1);\n-\n-    if (crop->crop_mode & CROP_INVERT)\n-      {\n-      switch (crop->photometric)\n-        {\n-        /* Just change the interpretation */\n-        case PHOTOMETRIC_MINISWHITE:\n-        case PHOTOMETRIC_MINISBLACK:\n-\t     image->photometric = crop->photometric;\n-\t     break;\n-        case INVERT_DATA_ONLY:\n-        case INVERT_DATA_AND_TAG:\n-             if (invertImage(image->photometric, image->spp, image->bps, \n-                             crop->combined_width, crop->combined_length, crop_buff))\n-               {\n-               TIFFError("processCropSelections", \n-                         "Failed to invert colorspace for composite regions");\n-               return (-1);\n-               }\n-             if (crop->photometric == INVERT_DATA_AND_TAG)\n-               {\n-               switch (image->photometric)\n-                 {\n-                 case PHOTOMETRIC_MINISWHITE:\n- \t              image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t              break;\n-                 case PHOTOMETRIC_MINISBLACK:\n- \t              image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t              break;\n-                 default:\n-\t              break;\n-\t         }\n-\t       }\n-             break;\n-        default: break;\n-        }\n-      }\n-\n-    /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n-    if (crop->crop_mode & CROP_MIRROR)\n-      {\n-      if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                      crop->combined_width, crop->combined_length, crop_buff))\n-        {\n-        TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n-\t         (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-        return (-1);\n-        }\n-      }\n-\n-    if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-      {\n-      if (rotateImage(crop->rotation, image, &crop->combined_width, \n-                      &crop->combined_length, &crop_buff))\n-        {\n-        TIFFError("processCropSelections", \n-                  "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n-        return (-1);\n-        }\n-      seg_buffs[0].buffer = crop_buff;\n-      seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n-                            * image->spp) * crop->combined_length; \n-      }\n+        if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n+        {\n+            if (rotateImage(crop->rotation, image, &crop->combined_width, \n+                            &crop->combined_length, &crop_buff))\n+            {\n+                TIFFError("processCropSelections", \n+                          "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n+                return (-1);\n+            }\n+            seg_buffs[0].buffer = crop_buff;\n+            seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n+                                  * image->spp) * crop->combined_length; \n+        }\n     }\n-  else  /* Separated Images */\n+    else  /* Separated Images */\n     {\n-    total_width = total_length = 0;\n-    for (i = 0; i < crop->selections; i++)\n-      {\n+        total_width = total_length = 0;\n+        for (i = 0; i < crop->selections; i++)\n+        {\n+            cropsize = crop->bufftotal;\n+            crop_buff = seg_buffs[i].buffer; \n+            if (!crop_buff)\n+                crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            else\n+            {\n+                prev_cropsize = seg_buffs[i].size;\n+                if (prev_cropsize < cropsize)\n+                {\n+                    next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    if (!next_buff)\n+                    {\n+                        _TIFFfree(crop_buff);\n+                        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    }\n+                    else\n+                        crop_buff = next_buff;\n+                }\n+            }\n \n-        cropsize = crop->bufftotal;\n-      crop_buff = seg_buffs[i].buffer; \n-      if (!crop_buff)\n-        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      else\n-        {\n-        prev_cropsize = seg_buffs[0].size;\n-        if (prev_cropsize < cropsize)\n-          {\n-          next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          if (! next_buff)\n+            if (!crop_buff)\n             {\n-            _TIFFfree (crop_buff);\n-            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+                return (-1);\n+            }\n+\n+            _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            seg_buffs[i].buffer = crop_buff;\n+            seg_buffs[i].size = cropsize;\n+\n+            if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+            {\n+                TIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n+                return (-1);\n+            }\n+\n+            width  = crop->regionlist[i].width;\n+            length = crop->regionlist[i].length;\n+\n+            // Ensure length is not out-of-bounds\n+            if (i >= crop->selections || length <= 0)\n+            {\n+                TIFFError("processCropSelections", "Invalid region list index or length");\n+                return (-1);\n+            }\n+\n+            if (crop->crop_mode & CROP_INVERT)\n+            {\n+                switch (crop->photometric)\n+                {\n+                /* Just change the interpretation */\n+                case PHOTOMETRIC_MINISWHITE:\n+                case PHOTOMETRIC_MINISBLACK:\n+                    image->photometric = crop->photometric;\n+                    break;\n+                case INVERT_DATA_ONLY:\n+                case INVERT_DATA_AND_TAG:\n+                    if (invertImage(image->photometric, image->spp, image->bps, \n+                                    width, length, crop_buff))\n+                    {\n+                        TIFFError("processCropSelections", \n+                                  "Failed to invert colorspace for region");\n+                        return (-1);\n+                    }\n+                    if (crop->photometric == INVERT_DATA_AND_TAG)\n+                    {\n+                        switch (image->photometric)\n+                        {\n+                        case PHOTOMETRIC_MINISWHITE:\n+                            image->photometric = PHOTOMETRIC_MINISBLACK;\n+                            break;\n+                        case PHOTOMETRIC_MINISBLACK:\n+                            image->photometric = PHOTOMETRIC_MINISWHITE;\n+                            break;\n+                        default:\n+                            break;\n+                        }\n+                    }\n+                    break;\n+                default: break;\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_MIRROR)\n+            {\n+                if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                                width, length, crop_buff))\n+                {\n+                    TIFFError("processCropSelections", "Failed to mirror crop region %s", \n+                             (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                    return (-1);\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n+            {\n+                if (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n+                                &crop->regionlist[i].length, &crop_buff))\n+                {\n+                    TIFFError("processCropSelections", \n+                              "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n+                    return (-1);\n+                }\n             }\n-          else\n-            crop_buff = next_buff;\n-          }\n-        }\n-\n-      if (!crop_buff)\n-        {\n-        TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-        return (-1);\n-        }\n- \n-      _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      seg_buffs[i].buffer = crop_buff;\n-      seg_buffs[i].size = cropsize;\n-\n-      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n-        {\n-\tTIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n-        return (-1);\n-        }\n-    \n-      width  = crop->regionlist[i].width;\n-      length = crop->regionlist[i].length;\n-\n-      if (crop->crop_mode & CROP_INVERT)\n-        {\n-        switch (crop->photometric)\n-          {\n-          /* Just change the interpretation */\n-          case PHOTOMETRIC_MINISWHITE:\n-          case PHOTOMETRIC_MINISBLACK:\n-\t       image->photometric = crop->photometric;\n-\t       break;\n-          case INVERT_DATA_ONLY:\n-          case INVERT_DATA_AND_TAG:\n-               if (invertImage(image->photometric, image->spp, image->bps, \n-                               width, length, crop_buff))\n-                 {\n-                 TIFFError("processCropSelections", \n-                           "Failed to invert colorspace for region");\n-                 return (-1);\n-                 }\n-               if (crop->photometric == INVERT_DATA_AND_TAG)\n-                 {\n-                 switch (image->photometric)\n-                   {\n-                   case PHOTOMETRIC_MINISWHITE:\n- \t                image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t                break;\n-                   case PHOTOMETRIC_MINISBLACK:\n- \t                image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t                break;\n-                   default:\n-\t                break;\n-\t           }\n-\t         }\n-               break;\n-          default: break;\n-          }\n-        }\n-\n-      if (crop->crop_mode & CROP_MIRROR)\n-        {\n-        if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                        width, length, crop_buff))\n-          {\n-          TIFFError("processCropSelections", "Failed to mirror crop region %s", \n-\t           (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-          return (-1);\n-          }\n-        }\n-\n-      if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-        {\n-          /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it schouldn\'t do here, when more than one section is processed. \n-           * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n-           */\n-\tif (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n-\t\t\t&crop->regionlist[i].length, &crop_buff))\n-          {\n-          TIFFError("processCropSelections", \n-                    "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n-          return (-1);\n-          }\n-        total_width  += crop->regionlist[i].width;\n-        total_length += crop->regionlist[i].length;\n-        crop->combined_width = total_width;\n-        crop->combined_length = total_length;\n-        seg_buffs[i].buffer = crop_buff;\n-        seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n-                               * image->spp) * crop->regionlist[i].length; \n+            total_width  += crop->regionlist[i].width;\n+            total_length += crop->regionlist[i].length;\n+            crop->combined_width = total_width;\n+            crop->combined_length = total_length;\n+            seg_buffs[i].buffer = crop_buff;\n+            seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n+                                  * image->spp) * crop->regionlist[i].length; \n         }\n-      }  /* for crop->selections loop */\n     }  /* Separated Images (else case) */\n-  return (0);\n-  } /* end processCropSelections */\n+    return (0);\n+} /* end processCropSelections */\n+\n \n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n', 'id': 25, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7837:7'}, {'diff': '@@ -7678,236 +7678,234 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n-  {\n-  int       i;\n-  uint32_t    width, length, total_width, total_length;\n-  tsize_t   cropsize;\n-  unsigned  char *crop_buff = NULL;\n-  unsigned  char *read_buff = NULL;\n-  unsigned  char *next_buff = NULL;\n-  tsize_t   prev_cropsize = 0;\n+{\n+    int       i;\n+    uint32_t    width, length, total_width, total_length;\n+    tsize_t   cropsize;\n+    unsigned  char *crop_buff = NULL;\n+    unsigned  char *read_buff = NULL;\n+    unsigned  char *next_buff = NULL;\n+    tsize_t   prev_cropsize = 0;\n \n-  read_buff = *read_buff_ptr;\n+    read_buff = *read_buff_ptr;\n \n-  if (crop->img_mode == COMPOSITE_IMAGES)\n+    if (crop->img_mode == COMPOSITE_IMAGES)\n     {\n-    cropsize = crop->bufftotal;\n-    crop_buff = seg_buffs[0].buffer; \n-    if (!crop_buff)\n-      crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    else\n-      {\n-      prev_cropsize = seg_buffs[0].size;\n-      if (prev_cropsize < cropsize)\n-        {\n-        next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-        if (! next_buff)\n-          {\n-          _TIFFfree (crop_buff);\n-          crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          }\n+        cropsize = crop->bufftotal;\n+        crop_buff = seg_buffs[0].buffer; \n+        if (!crop_buff)\n+            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n         else\n-          crop_buff = next_buff;\n+        {\n+            prev_cropsize = seg_buffs[0].size;\n+            if (prev_cropsize < cropsize)\n+            {\n+                next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                if (!next_buff)\n+                {\n+                    _TIFFfree(crop_buff);\n+                    crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                }\n+                else\n+                    crop_buff = next_buff;\n+            }\n         }\n-      }\n \n-    if (!crop_buff)\n-      {\n-      TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-      return (-1);\n-      }\n- \n-    _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    seg_buffs[0].buffer = crop_buff;\n-    seg_buffs[0].size = cropsize;\n-\n-    /* Checks for matching width or length as required */\n-    if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n-      return (1);\n-\n-    if (crop->crop_mode & CROP_INVERT)\n-      {\n-      switch (crop->photometric)\n-        {\n-        /* Just change the interpretation */\n-        case PHOTOMETRIC_MINISWHITE:\n-        case PHOTOMETRIC_MINISBLACK:\n-\t     image->photometric = crop->photometric;\n-\t     break;\n-        case INVERT_DATA_ONLY:\n-        case INVERT_DATA_AND_TAG:\n-             if (invertImage(image->photometric, image->spp, image->bps, \n-                             crop->combined_width, crop->combined_length, crop_buff))\n-               {\n-               TIFFError("processCropSelections", \n-                         "Failed to invert colorspace for composite regions");\n-               return (-1);\n-               }\n-             if (crop->photometric == INVERT_DATA_AND_TAG)\n-               {\n-               switch (image->photometric)\n-                 {\n-                 case PHOTOMETRIC_MINISWHITE:\n- \t              image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t              break;\n-                 case PHOTOMETRIC_MINISBLACK:\n- \t              image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t              break;\n-                 default:\n-\t              break;\n-\t         }\n-\t       }\n-             break;\n-        default: break;\n+        if (!crop_buff)\n+        {\n+            TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+            return (-1);\n         }\n-      }\n \n-    /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n-    if (crop->crop_mode & CROP_MIRROR)\n-      {\n-      if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                      crop->combined_width, crop->combined_length, crop_buff))\n-        {\n-        TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n-\t         (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-        return (-1);\n-        }\n-      }\n+        _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+        seg_buffs[0].buffer = crop_buff;\n+        seg_buffs[0].size = cropsize;\n \n-    if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-      {\n-      if (rotateImage(crop->rotation, image, &crop->combined_width, \n-                      &crop->combined_length, &crop_buff))\n-        {\n-        TIFFError("processCropSelections", \n-                  "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n-        return (-1);\n-        }\n-      seg_buffs[0].buffer = crop_buff;\n-      seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n-                            * image->spp) * crop->combined_length; \n-      }\n-    }\n-  else  /* Separated Images */\n-    {\n-    total_width = total_length = 0;\n-    for (i = 0; i < crop->selections; i++)\n-      {\n+        /* Checks for matching width or length as required */\n+        if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n+            return (1);\n \n-        cropsize = crop->bufftotal;\n-      crop_buff = seg_buffs[i].buffer; \n-      if (!crop_buff)\n-        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      else\n-        {\n-        prev_cropsize = seg_buffs[0].size;\n-        if (prev_cropsize < cropsize)\n-          {\n-          next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          if (! next_buff)\n+        if (crop->crop_mode & CROP_INVERT)\n+        {\n+            switch (crop->photometric)\n             {\n-            _TIFFfree (crop_buff);\n-            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                /* Just change the interpretation */\n+                case PHOTOMETRIC_MINISWHITE:\n+                case PHOTOMETRIC_MINISBLACK:\n+                    image->photometric = crop->photometric;\n+                    break;\n+                case INVERT_DATA_ONLY:\n+                case INVERT_DATA_AND_TAG:\n+                    if (invertImage(image->photometric, image->spp, image->bps, \n+                                    crop->combined_width, crop->combined_length, crop_buff))\n+                    {\n+                        TIFFError("processCropSelections", \n+                                  "Failed to invert colorspace for composite regions");\n+                        return (-1);\n+                    }\n+                    if (crop->photometric == INVERT_DATA_AND_TAG)\n+                    {\n+                        switch (image->photometric)\n+                        {\n+                            case PHOTOMETRIC_MINISWHITE:\n+                                image->photometric = PHOTOMETRIC_MINISBLACK;\n+                                break;\n+                            case PHOTOMETRIC_MINISBLACK:\n+                                image->photometric = PHOTOMETRIC_MINISWHITE;\n+                                break;\n+                            default:\n+                                break;\n+                        }\n+                    }\n+                    break;\n+                default: break;\n             }\n-          else\n-            crop_buff = next_buff;\n-          }\n         }\n \n-      if (!crop_buff)\n+        /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n+        if (crop->crop_mode & CROP_MIRROR)\n         {\n-        TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-        return (-1);\n+            if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                            crop->combined_width, crop->combined_length, crop_buff))\n+            {\n+                TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n+                          (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                return (-1);\n+            }\n         }\n- \n-      _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      seg_buffs[i].buffer = crop_buff;\n-      seg_buffs[i].size = cropsize;\n \n-      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+        if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n         {\n-\tTIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n-        return (-1);\n-        }\n-    \n-      width  = crop->regionlist[i].width;\n-      length = crop->regionlist[i].length;\n-\n-      if (crop->crop_mode & CROP_INVERT)\n-        {\n-        switch (crop->photometric)\n-          {\n-          /* Just change the interpretation */\n-          case PHOTOMETRIC_MINISWHITE:\n-          case PHOTOMETRIC_MINISBLACK:\n-\t       image->photometric = crop->photometric;\n-\t       break;\n-          case INVERT_DATA_ONLY:\n-          case INVERT_DATA_AND_TAG:\n-               if (invertImage(image->photometric, image->spp, image->bps, \n-                               width, length, crop_buff))\n-                 {\n-                 TIFFError("processCropSelections", \n-                           "Failed to invert colorspace for region");\n-                 return (-1);\n-                 }\n-               if (crop->photometric == INVERT_DATA_AND_TAG)\n-                 {\n-                 switch (image->photometric)\n-                   {\n-                   case PHOTOMETRIC_MINISWHITE:\n- \t                image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t                break;\n-                   case PHOTOMETRIC_MINISBLACK:\n- \t                image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t                break;\n-                   default:\n-\t                break;\n-\t           }\n-\t         }\n-               break;\n-          default: break;\n-          }\n+            if (rotateImage(crop->rotation, image, &crop->combined_width, \n+                            &crop->combined_length, &crop_buff))\n+            {\n+                TIFFError("processCropSelections", \n+                          "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n+                return (-1);\n+            }\n+            seg_buffs[0].buffer = crop_buff;\n+            seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n+                                  * image->spp) * crop->combined_length; \n         }\n-\n-      if (crop->crop_mode & CROP_MIRROR)\n+    }\n+    else  /* Separated Images */\n+    {\n+        total_width = total_length = 0;\n+        for (i = 0; i < crop->selections; i++)\n         {\n-        if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                        width, length, crop_buff))\n-          {\n-          TIFFError("processCropSelections", "Failed to mirror crop region %s", \n-\t           (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-          return (-1);\n-          }\n-        }\n+            cropsize = crop->bufftotal;\n+            crop_buff = seg_buffs[i].buffer; \n+            if (!crop_buff)\n+                crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            else\n+            {\n+                prev_cropsize = seg_buffs[i].size;\n+                if (prev_cropsize < cropsize)\n+                {\n+                    next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    if (!next_buff)\n+                    {\n+                        _TIFFfree(crop_buff);\n+                        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    }\n+                    else\n+                        crop_buff = next_buff;\n+                }\n+            }\n \n-      if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-        {\n-          /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it schouldn\'t do here, when more than one section is processed. \n-           * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n-           */\n-\tif (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n-\t\t\t&crop->regionlist[i].length, &crop_buff))\n-          {\n-          TIFFError("processCropSelections", \n-                    "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n-          return (-1);\n-          }\n-        total_width  += crop->regionlist[i].width;\n-        total_length += crop->regionlist[i].length;\n-        crop->combined_width = total_width;\n-        crop->combined_length = total_length;\n-        seg_buffs[i].buffer = crop_buff;\n-        seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n-                               * image->spp) * crop->regionlist[i].length; \n-        }\n-      }  /* for crop->selections loop */\n+            if (!crop_buff)\n+            {\n+                TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+                return (-1);\n+            }\n+\n+            _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            seg_buffs[i].buffer = crop_buff;\n+            seg_buffs[i].size = cropsize;\n+\n+            if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+            {\n+                TIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n+                return (-1);\n+            }\n+        \n+            width  = crop->regionlist[i].width;\n+            length = crop->regionlist[i].length;\n+\n+            if (crop->crop_mode & CROP_INVERT)\n+            {\n+                switch (crop->photometric)\n+                {\n+                    /* Just change the interpretation */\n+                    case PHOTOMETRIC_MINISWHITE:\n+                    case PHOTOMETRIC_MINISBLACK:\n+                        image->photometric = crop->photometric;\n+                        break;\n+                    case INVERT_DATA_ONLY:\n+                    case INVERT_DATA_AND_TAG:\n+                        if (invertImage(image->photometric, image->spp, image->bps, \n+                                        width, length, crop_buff))\n+                        {\n+                            TIFFError("processCropSelections", \n+                                      "Failed to invert colorspace for region");\n+                            return (-1);\n+                        }\n+                        if (crop->photometric == INVERT_DATA_AND_TAG)\n+                        {\n+                            switch (image->photometric)\n+                            {\n+                                case PHOTOMETRIC_MINISWHITE:\n+                                    image->photometric = PHOTOMETRIC_MINISBLACK;\n+                                    break;\n+                                case PHOTOMETRIC_MINISBLACK:\n+                                    image->photometric = PHOTOMETRIC_MINISWHITE;\n+                                    break;\n+                                default:\n+                                    break;\n+                            }\n+                        }\n+                        break;\n+                    default: break;\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_MIRROR)\n+            {\n+                if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                                width, length, crop_buff))\n+                {\n+                    TIFFError("processCropSelections", "Failed to mirror crop region %s", \n+                              (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                    return (-1);\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n+            {\n+                if (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n+                                &crop->regionlist[i].length, &crop_buff))\n+                {\n+                    TIFFError("processCropSelections", \n+                              "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n+                    return (-1);\n+                }\n+                total_width  += crop->regionlist[i].width;\n+                total_length += crop->regionlist[i].length;\n+                crop->combined_width = total_width;\n+                crop->combined_length = total_length;\n+                seg_buffs[i].buffer = crop_buff;\n+                seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n+                                       * image->spp) * crop->regionlist[i].length; \n+            }\n+        }  /* for crop->selections loop */\n     }  /* Separated Images (else case) */\n-  return (0);\n-  } /* end processCropSelections */\n+    return (0);\n+} /* end processCropSelections */\n+\n \n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n', 'id': 26, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7837:7'}, {'diff': '@@ -7678,236 +7678,234 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n-  {\n-  int       i;\n-  uint32_t    width, length, total_width, total_length;\n-  tsize_t   cropsize;\n-  unsigned  char *crop_buff = NULL;\n-  unsigned  char *read_buff = NULL;\n-  unsigned  char *next_buff = NULL;\n-  tsize_t   prev_cropsize = 0;\n+{\n+    int       i;\n+    uint32_t    width, length, total_width, total_length;\n+    tsize_t   cropsize;\n+    unsigned  char *crop_buff = NULL;\n+    unsigned  char *read_buff = NULL;\n+    unsigned  char *next_buff = NULL;\n+    tsize_t   prev_cropsize = 0;\n \n-  read_buff = *read_buff_ptr;\n+    read_buff = *read_buff_ptr;\n \n-  if (crop->img_mode == COMPOSITE_IMAGES)\n+    if (crop->img_mode == COMPOSITE_IMAGES)\n     {\n-    cropsize = crop->bufftotal;\n-    crop_buff = seg_buffs[0].buffer; \n-    if (!crop_buff)\n-      crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    else\n-      {\n-      prev_cropsize = seg_buffs[0].size;\n-      if (prev_cropsize < cropsize)\n-        {\n-        next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-        if (! next_buff)\n-          {\n-          _TIFFfree (crop_buff);\n-          crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          }\n+        cropsize = crop->bufftotal;\n+        crop_buff = seg_buffs[0].buffer; \n+        if (!crop_buff)\n+            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n         else\n-          crop_buff = next_buff;\n+        {\n+            prev_cropsize = seg_buffs[0].size;\n+            if (prev_cropsize < cropsize)\n+            {\n+                next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                if (!next_buff)\n+                {\n+                    _TIFFfree(crop_buff);\n+                    crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                }\n+                else\n+                    crop_buff = next_buff;\n+            }\n         }\n-      }\n \n-    if (!crop_buff)\n-      {\n-      TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-      return (-1);\n-      }\n- \n-    _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    seg_buffs[0].buffer = crop_buff;\n-    seg_buffs[0].size = cropsize;\n-\n-    /* Checks for matching width or length as required */\n-    if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n-      return (1);\n-\n-    if (crop->crop_mode & CROP_INVERT)\n-      {\n-      switch (crop->photometric)\n-        {\n-        /* Just change the interpretation */\n-        case PHOTOMETRIC_MINISWHITE:\n-        case PHOTOMETRIC_MINISBLACK:\n-\t     image->photometric = crop->photometric;\n-\t     break;\n-        case INVERT_DATA_ONLY:\n-        case INVERT_DATA_AND_TAG:\n-             if (invertImage(image->photometric, image->spp, image->bps, \n-                             crop->combined_width, crop->combined_length, crop_buff))\n-               {\n-               TIFFError("processCropSelections", \n-                         "Failed to invert colorspace for composite regions");\n-               return (-1);\n-               }\n-             if (crop->photometric == INVERT_DATA_AND_TAG)\n-               {\n-               switch (image->photometric)\n-                 {\n-                 case PHOTOMETRIC_MINISWHITE:\n- \t              image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t              break;\n-                 case PHOTOMETRIC_MINISBLACK:\n- \t              image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t              break;\n-                 default:\n-\t              break;\n-\t         }\n-\t       }\n-             break;\n-        default: break;\n+        if (!crop_buff)\n+        {\n+            TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+            return (-1);\n         }\n-      }\n \n-    /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n-    if (crop->crop_mode & CROP_MIRROR)\n-      {\n-      if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                      crop->combined_width, crop->combined_length, crop_buff))\n-        {\n-        TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n-\t         (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-        return (-1);\n-        }\n-      }\n+        _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+        seg_buffs[0].buffer = crop_buff;\n+        seg_buffs[0].size = cropsize;\n \n-    if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-      {\n-      if (rotateImage(crop->rotation, image, &crop->combined_width, \n-                      &crop->combined_length, &crop_buff))\n-        {\n-        TIFFError("processCropSelections", \n-                  "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n-        return (-1);\n-        }\n-      seg_buffs[0].buffer = crop_buff;\n-      seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n-                            * image->spp) * crop->combined_length; \n-      }\n-    }\n-  else  /* Separated Images */\n-    {\n-    total_width = total_length = 0;\n-    for (i = 0; i < crop->selections; i++)\n-      {\n+        /* Checks for matching width or length as required */\n+        if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n+            return (1);\n \n-        cropsize = crop->bufftotal;\n-      crop_buff = seg_buffs[i].buffer; \n-      if (!crop_buff)\n-        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      else\n-        {\n-        prev_cropsize = seg_buffs[0].size;\n-        if (prev_cropsize < cropsize)\n-          {\n-          next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          if (! next_buff)\n+        if (crop->crop_mode & CROP_INVERT)\n+        {\n+            switch (crop->photometric)\n             {\n-            _TIFFfree (crop_buff);\n-            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                /* Just change the interpretation */\n+                case PHOTOMETRIC_MINISWHITE:\n+                case PHOTOMETRIC_MINISBLACK:\n+                    image->photometric = crop->photometric;\n+                    break;\n+                case INVERT_DATA_ONLY:\n+                case INVERT_DATA_AND_TAG:\n+                    if (invertImage(image->photometric, image->spp, image->bps, \n+                                    crop->combined_width, crop->combined_length, crop_buff))\n+                    {\n+                        TIFFError("processCropSelections", \n+                                    "Failed to invert colorspace for composite regions");\n+                        return (-1);\n+                    }\n+                    if (crop->photometric == INVERT_DATA_AND_TAG)\n+                    {\n+                        switch (image->photometric)\n+                        {\n+                            case PHOTOMETRIC_MINISWHITE:\n+                                image->photometric = PHOTOMETRIC_MINISBLACK;\n+                                break;\n+                            case PHOTOMETRIC_MINISBLACK:\n+                                image->photometric = PHOTOMETRIC_MINISWHITE;\n+                                break;\n+                            default:\n+                                break;\n+                        }\n+                    }\n+                    break;\n+                default: break;\n             }\n-          else\n-            crop_buff = next_buff;\n-          }\n         }\n \n-      if (!crop_buff)\n+        /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n+        if (crop->crop_mode & CROP_MIRROR)\n         {\n-        TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-        return (-1);\n+            if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                            crop->combined_width, crop->combined_length, crop_buff))\n+            {\n+                TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n+                         (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                return (-1);\n+            }\n         }\n- \n-      _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      seg_buffs[i].buffer = crop_buff;\n-      seg_buffs[i].size = cropsize;\n \n-      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+        if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n         {\n-\tTIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n-        return (-1);\n-        }\n-    \n-      width  = crop->regionlist[i].width;\n-      length = crop->regionlist[i].length;\n-\n-      if (crop->crop_mode & CROP_INVERT)\n-        {\n-        switch (crop->photometric)\n-          {\n-          /* Just change the interpretation */\n-          case PHOTOMETRIC_MINISWHITE:\n-          case PHOTOMETRIC_MINISBLACK:\n-\t       image->photometric = crop->photometric;\n-\t       break;\n-          case INVERT_DATA_ONLY:\n-          case INVERT_DATA_AND_TAG:\n-               if (invertImage(image->photometric, image->spp, image->bps, \n-                               width, length, crop_buff))\n-                 {\n-                 TIFFError("processCropSelections", \n-                           "Failed to invert colorspace for region");\n-                 return (-1);\n-                 }\n-               if (crop->photometric == INVERT_DATA_AND_TAG)\n-                 {\n-                 switch (image->photometric)\n-                   {\n-                   case PHOTOMETRIC_MINISWHITE:\n- \t                image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t                break;\n-                   case PHOTOMETRIC_MINISBLACK:\n- \t                image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t                break;\n-                   default:\n-\t                break;\n-\t           }\n-\t         }\n-               break;\n-          default: break;\n-          }\n+            if (rotateImage(crop->rotation, image, &crop->combined_width, \n+                            &crop->combined_length, &crop_buff))\n+            {\n+                TIFFError("processCropSelections", \n+                            "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n+                return (-1);\n+            }\n+            seg_buffs[0].buffer = crop_buff;\n+            seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n+                                  * image->spp) * crop->combined_length; \n         }\n-\n-      if (crop->crop_mode & CROP_MIRROR)\n+    }\n+    else  /* Separated Images */\n+    {\n+        total_width = total_length = 0;\n+        for (i = 0; i < crop->selections; i++)\n         {\n-        if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                        width, length, crop_buff))\n-          {\n-          TIFFError("processCropSelections", "Failed to mirror crop region %s", \n-\t           (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-          return (-1);\n-          }\n-        }\n+            cropsize = crop->bufftotal;\n+            crop_buff = seg_buffs[i].buffer; \n+            if (!crop_buff)\n+                crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            else\n+            {\n+                prev_cropsize = seg_buffs[i].size; // Modified to use the correct index\n+                if (prev_cropsize < cropsize)\n+                {\n+                    next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    if (!next_buff)\n+                    {\n+                        _TIFFfree(crop_buff);\n+                        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    }\n+                    else\n+                        crop_buff = next_buff;\n+                }\n+            }\n \n-      if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-        {\n-          /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it schouldn\'t do here, when more than one section is processed. \n-           * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n-           */\n-\tif (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n-\t\t\t&crop->regionlist[i].length, &crop_buff))\n-          {\n-          TIFFError("processCropSelections", \n-                    "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n-          return (-1);\n-          }\n-        total_width  += crop->regionlist[i].width;\n-        total_length += crop->regionlist[i].length;\n-        crop->combined_width = total_width;\n-        crop->combined_length = total_length;\n-        seg_buffs[i].buffer = crop_buff;\n-        seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n-                               * image->spp) * crop->regionlist[i].length; \n-        }\n-      }  /* for crop->selections loop */\n+            if (!crop_buff)\n+            {\n+                TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+                return (-1);\n+            }\n+ \n+            _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            seg_buffs[i].buffer = crop_buff;\n+            seg_buffs[i].size = cropsize;\n+\n+            if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+            {\n+                TIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n+                return (-1);\n+            }\n+\n+            width = crop->regionlist[i].width;\n+            length = crop->regionlist[i].length;\n+\n+            if (crop->crop_mode & CROP_INVERT)\n+            {\n+                switch (crop->photometric)\n+                {\n+                    /* Just change the interpretation */\n+                    case PHOTOMETRIC_MINISWHITE:\n+                    case PHOTOMETRIC_MINISBLACK:\n+                        image->photometric = crop->photometric;\n+                        break;\n+                    case INVERT_DATA_ONLY:\n+                    case INVERT_DATA_AND_TAG:\n+                        if (invertImage(image->photometric, image->spp, image->bps, \n+                                        width, length, crop_buff))\n+                        {\n+                            TIFFError("processCropSelections", \n+                                        "Failed to invert colorspace for region");\n+                            return (-1);\n+                        }\n+                        if (crop->photometric == INVERT_DATA_AND_TAG)\n+                        {\n+                            switch (image->photometric)\n+                            {\n+                                case PHOTOMETRIC_MINISWHITE:\n+                                    image->photometric = PHOTOMETRIC_MINISBLACK;\n+                                    break;\n+                                case PHOTOMETRIC_MINISBLACK:\n+                                    image->photometric = PHOTOMETRIC_MINISWHITE;\n+                                    break;\n+                                default:\n+                                    break;\n+                            }\n+                        }\n+                        break;\n+                    default: break;\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_MIRROR)\n+            {\n+                if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                                width, length, crop_buff))\n+                {\n+                    TIFFError("processCropSelections", "Failed to mirror crop region %s", \n+                             (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                    return (-1);\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n+            {\n+                if (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n+                                &crop->regionlist[i].length, &crop_buff))\n+                {\n+                    TIFFError("processCropSelections", \n+                              "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n+                    return (-1);\n+                }\n+                total_width  += crop->regionlist[i].width;\n+                total_length += crop->regionlist[i].length;\n+                crop->combined_width = total_width;\n+                crop->combined_length = total_length;\n+                seg_buffs[i].buffer = crop_buff;\n+                seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n+                                       * image->spp) * crop->regionlist[i].length; \n+            }\n+        }  /* for crop->selections loop */\n     }  /* Separated Images (else case) */\n-  return (0);\n-  } /* end processCropSelections */\n+    return (0);\n+} /* end processCropSelections */\n+\n \n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n', 'id': 27, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7837:7'}, {'diff': '@@ -7678,236 +7678,232 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n-  {\n-  int       i;\n-  uint32_t    width, length, total_width, total_length;\n-  tsize_t   cropsize;\n-  unsigned  char *crop_buff = NULL;\n-  unsigned  char *read_buff = NULL;\n-  unsigned  char *next_buff = NULL;\n-  tsize_t   prev_cropsize = 0;\n+{\n+    int       i;\n+    uint32_t  width, length, total_width, total_length;\n+    tsize_t   cropsize;\n+    unsigned char *crop_buff = NULL;\n+    unsigned char *read_buff = NULL;\n+    unsigned char *next_buff = NULL;\n+    tsize_t   prev_cropsize = 0;\n \n-  read_buff = *read_buff_ptr;\n+    read_buff = *read_buff_ptr;\n \n-  if (crop->img_mode == COMPOSITE_IMAGES)\n+    if (crop->img_mode == COMPOSITE_IMAGES)\n     {\n-    cropsize = crop->bufftotal;\n-    crop_buff = seg_buffs[0].buffer; \n-    if (!crop_buff)\n-      crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    else\n-      {\n-      prev_cropsize = seg_buffs[0].size;\n-      if (prev_cropsize < cropsize)\n-        {\n-        next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-        if (! next_buff)\n-          {\n-          _TIFFfree (crop_buff);\n-          crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          }\n+        cropsize = crop->bufftotal;\n+        crop_buff = seg_buffs[0].buffer; \n+        if (!crop_buff)\n+            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n         else\n-          crop_buff = next_buff;\n+        {\n+            prev_cropsize = seg_buffs[0].size;\n+            if (prev_cropsize < cropsize)\n+            {\n+                next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                if (!next_buff)\n+                {\n+                    _TIFFfree(crop_buff);\n+                    crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                }\n+                else\n+                    crop_buff = next_buff;\n+            }\n+        }\n+\n+        if (!crop_buff)\n+        {\n+            TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+            return (-1);\n+        }\n+\n+        _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+        seg_buffs[0].buffer = crop_buff;\n+        seg_buffs[0].size = cropsize;\n+\n+        /* Checks for matching width or length as required */\n+        if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n+            return (1);\n+\n+        if (crop->crop_mode & CROP_INVERT)\n+        {\n+            switch (crop->photometric)\n+            {\n+                case PHOTOMETRIC_MINISWHITE:\n+                case PHOTOMETRIC_MINISBLACK:\n+                     image->photometric = crop->photometric;\n+                     break;\n+                case INVERT_DATA_ONLY:\n+                case INVERT_DATA_AND_TAG:\n+                     if (invertImage(image->photometric, image->spp, image->bps, \n+                                     crop->combined_width, crop->combined_length, crop_buff))\n+                     {\n+                         TIFFError("processCropSelections", \n+                                   "Failed to invert colorspace for composite regions");\n+                         return (-1);\n+                     }\n+                     if (crop->photometric == INVERT_DATA_AND_TAG)\n+                     {\n+                         switch (image->photometric)\n+                         {\n+                             case PHOTOMETRIC_MINISWHITE:\n+                              image->photometric = PHOTOMETRIC_MINISBLACK;\n+                              break;\n+                             case PHOTOMETRIC_MINISBLACK:\n+                              image->photometric = PHOTOMETRIC_MINISWHITE;\n+                              break;\n+                             default:\n+                              break;\n+                         }\n+                     }\n+                     break;\n+                default: break;\n+            }\n+        }\n+\n+        /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n+        if (crop->crop_mode & CROP_MIRROR)\n+        {\n+            if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                            crop->combined_width, crop->combined_length, crop_buff))\n+            {\n+                TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n+                          (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                return (-1);\n+            }\n         }\n-      }\n \n-    if (!crop_buff)\n-      {\n-      TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-      return (-1);\n-      }\n- \n-    _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    seg_buffs[0].buffer = crop_buff;\n-    seg_buffs[0].size = cropsize;\n-\n-    /* Checks for matching width or length as required */\n-    if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n-      return (1);\n-\n-    if (crop->crop_mode & CROP_INVERT)\n-      {\n-      switch (crop->photometric)\n-        {\n-        /* Just change the interpretation */\n-        case PHOTOMETRIC_MINISWHITE:\n-        case PHOTOMETRIC_MINISBLACK:\n-\t     image->photometric = crop->photometric;\n-\t     break;\n-        case INVERT_DATA_ONLY:\n-        case INVERT_DATA_AND_TAG:\n-             if (invertImage(image->photometric, image->spp, image->bps, \n-                             crop->combined_width, crop->combined_length, crop_buff))\n-               {\n-               TIFFError("processCropSelections", \n-                         "Failed to invert colorspace for composite regions");\n-               return (-1);\n-               }\n-             if (crop->photometric == INVERT_DATA_AND_TAG)\n-               {\n-               switch (image->photometric)\n-                 {\n-                 case PHOTOMETRIC_MINISWHITE:\n- \t              image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t              break;\n-                 case PHOTOMETRIC_MINISBLACK:\n- \t              image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t              break;\n-                 default:\n-\t              break;\n-\t         }\n-\t       }\n-             break;\n-        default: break;\n-        }\n-      }\n-\n-    /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n-    if (crop->crop_mode & CROP_MIRROR)\n-      {\n-      if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                      crop->combined_width, crop->combined_length, crop_buff))\n-        {\n-        TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n-\t         (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-        return (-1);\n-        }\n-      }\n-\n-    if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-      {\n-      if (rotateImage(crop->rotation, image, &crop->combined_width, \n-                      &crop->combined_length, &crop_buff))\n-        {\n-        TIFFError("processCropSelections", \n-                  "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n-        return (-1);\n-        }\n-      seg_buffs[0].buffer = crop_buff;\n-      seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n-                            * image->spp) * crop->combined_length; \n-      }\n+        if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n+        {\n+            if (rotateImage(crop->rotation, image, &crop->combined_width, \n+                            &crop->combined_length, &crop_buff))\n+            {\n+                TIFFError("processCropSelections", \n+                          "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n+                return (-1);\n+            }\n+            seg_buffs[0].buffer = crop_buff;\n+            seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n+                                  * image->spp) * crop->combined_length; \n+        }\n     }\n-  else  /* Separated Images */\n+    else  /* Separated Images */\n     {\n-    total_width = total_length = 0;\n-    for (i = 0; i < crop->selections; i++)\n-      {\n+        total_width = total_length = 0;\n+        for (i = 0; i < crop->selections; i++)\n+        {\n+            cropsize = crop->bufftotal;\n+            crop_buff = seg_buffs[i].buffer; \n+            if (!crop_buff)\n+                crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            else\n+            {\n+                prev_cropsize = seg_buffs[i].size;\n+                if (prev_cropsize < cropsize)\n+                {\n+                    next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    if (!next_buff)\n+                    {\n+                        _TIFFfree(crop_buff);\n+                        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    }\n+                    else\n+                        crop_buff = next_buff;\n+                }\n+            }\n \n-        cropsize = crop->bufftotal;\n-      crop_buff = seg_buffs[i].buffer; \n-      if (!crop_buff)\n-        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      else\n-        {\n-        prev_cropsize = seg_buffs[0].size;\n-        if (prev_cropsize < cropsize)\n-          {\n-          next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          if (! next_buff)\n+            if (!crop_buff)\n             {\n-            _TIFFfree (crop_buff);\n-            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+                return (-1);\n             }\n-          else\n-            crop_buff = next_buff;\n-          }\n-        }\n-\n-      if (!crop_buff)\n-        {\n-        TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-        return (-1);\n-        }\n- \n-      _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      seg_buffs[i].buffer = crop_buff;\n-      seg_buffs[i].size = cropsize;\n-\n-      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n-        {\n-\tTIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n-        return (-1);\n-        }\n-    \n-      width  = crop->regionlist[i].width;\n-      length = crop->regionlist[i].length;\n-\n-      if (crop->crop_mode & CROP_INVERT)\n-        {\n-        switch (crop->photometric)\n-          {\n-          /* Just change the interpretation */\n-          case PHOTOMETRIC_MINISWHITE:\n-          case PHOTOMETRIC_MINISBLACK:\n-\t       image->photometric = crop->photometric;\n-\t       break;\n-          case INVERT_DATA_ONLY:\n-          case INVERT_DATA_AND_TAG:\n-               if (invertImage(image->photometric, image->spp, image->bps, \n-                               width, length, crop_buff))\n-                 {\n-                 TIFFError("processCropSelections", \n-                           "Failed to invert colorspace for region");\n-                 return (-1);\n-                 }\n-               if (crop->photometric == INVERT_DATA_AND_TAG)\n-                 {\n-                 switch (image->photometric)\n-                   {\n-                   case PHOTOMETRIC_MINISWHITE:\n- \t                image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t                break;\n-                   case PHOTOMETRIC_MINISBLACK:\n- \t                image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t                break;\n-                   default:\n-\t                break;\n-\t           }\n-\t         }\n-               break;\n-          default: break;\n-          }\n-        }\n-\n-      if (crop->crop_mode & CROP_MIRROR)\n-        {\n-        if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                        width, length, crop_buff))\n-          {\n-          TIFFError("processCropSelections", "Failed to mirror crop region %s", \n-\t           (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-          return (-1);\n-          }\n-        }\n-\n-      if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-        {\n-          /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it schouldn\'t do here, when more than one section is processed. \n-           * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n-           */\n-\tif (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n-\t\t\t&crop->regionlist[i].length, &crop_buff))\n-          {\n-          TIFFError("processCropSelections", \n-                    "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n-          return (-1);\n-          }\n-        total_width  += crop->regionlist[i].width;\n-        total_length += crop->regionlist[i].length;\n-        crop->combined_width = total_width;\n-        crop->combined_length = total_length;\n-        seg_buffs[i].buffer = crop_buff;\n-        seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n-                               * image->spp) * crop->regionlist[i].length; \n-        }\n-      }  /* for crop->selections loop */\n-    }  /* Separated Images (else case) */\n-  return (0);\n-  } /* end processCropSelections */\n+\n+            _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            seg_buffs[i].buffer = crop_buff;\n+            seg_buffs[i].size = cropsize;\n+\n+            if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+            {\n+                TIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n+                return (-1);\n+            }\n+\n+            width  = crop->regionlist[i].width;\n+            length = crop->regionlist[i].length;\n+\n+            if (crop->crop_mode & CROP_INVERT)\n+            {\n+                switch (crop->photometric)\n+                {\n+                    case PHOTOMETRIC_MINISWHITE:\n+                    case PHOTOMETRIC_MINISBLACK:\n+                         image->photometric = crop->photometric;\n+                         break;\n+                    case INVERT_DATA_ONLY:\n+                    case INVERT_DATA_AND_TAG:\n+                         if (invertImage(image->photometric, image->spp, image->bps, \n+                                         width, length, crop_buff))\n+                         {\n+                             TIFFError("processCropSelections", \n+                                       "Failed to invert colorspace for region");\n+                             return (-1);\n+                         }\n+                         if (crop->photometric == INVERT_DATA_AND_TAG)\n+                         {\n+                             switch (image->photometric)\n+                             {\n+                                 case PHOTOMETRIC_MINISWHITE:\n+                                  image->photometric = PHOTOMETRIC_MINISBLACK;\n+                                  break;\n+                                 case PHOTOMETRIC_MINISBLACK:\n+                                  image->photometric = PHOTOMETRIC_MINISWHITE;\n+                                  break;\n+                                 default:\n+                                  break;\n+                             }\n+                         }\n+                         break;\n+                    default: break;\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_MIRROR)\n+            {\n+                if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                                width, length, crop_buff))\n+                {\n+                    TIFFError("processCropSelections", "Failed to mirror crop region %s", \n+                               (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                    return (-1);\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n+            {\n+                if (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n+                                &crop->regionlist[i].length, &crop_buff))\n+                {\n+                    TIFFError("processCropSelections", \n+                              "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n+                    return (-1);\n+                }\n+            }\n+            total_width  += crop->regionlist[i].width;\n+            total_length += crop->regionlist[i].length;\n+            crop->combined_width = total_width;\n+            crop->combined_length = total_length;\n+            seg_buffs[i].buffer = crop_buff;\n+            seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n+                                 * image->spp) * crop->regionlist[i].length; \n+        }\n+    }\n+    return (0);\n+} /* end processCropSelections */\n+\n \n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n', 'id': 28, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7837:7'}, {'diff': '@@ -7678,10 +7678,11 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n-  {\n+{\n   int       i;\n   uint32_t    width, length, total_width, total_length;\n   tsize_t   cropsize;\n@@ -7803,7 +7804,7 @@\n         crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n       else\n         {\n-        prev_cropsize = seg_buffs[0].size;\n+        prev_cropsize = seg_buffs[i].size;\n         if (prev_cropsize < cropsize)\n           {\n           next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n@@ -7836,6 +7837,11 @@\n       width  = crop->regionlist[i].width;\n       length = crop->regionlist[i].length;\n \n+      if (width == 0 || length == 0) {\n+          TIFFError("processCropSelections", "Invalid width or length for region %d", i);\n+          return (-1);\n+      }\n+\n       if (crop->crop_mode & CROP_INVERT)\n         {\n         switch (crop->photometric)\n@@ -7886,9 +7892,6 @@\n \n       if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n         {\n-          /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it schouldn\'t do here, when more than one section is processed. \n-           * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n-           */\n \tif (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n \t\t\t&crop->regionlist[i].length, &crop_buff))\n           {\n@@ -7907,7 +7910,8 @@\n       }  /* for crop->selections loop */\n     }  /* Separated Images (else case) */\n   return (0);\n-  } /* end processCropSelections */\n+} /* end processCropSelections */\n+\n \n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n', 'id': 29, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7837:7'}, {'diff': '@@ -7678,236 +7678,240 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n-  {\n-  int       i;\n-  uint32_t    width, length, total_width, total_length;\n-  tsize_t   cropsize;\n-  unsigned  char *crop_buff = NULL;\n-  unsigned  char *read_buff = NULL;\n-  unsigned  char *next_buff = NULL;\n-  tsize_t   prev_cropsize = 0;\n+{\n+    int       i;\n+    uint32_t    width, length, total_width, total_length;\n+    tsize_t   cropsize;\n+    unsigned  char *crop_buff = NULL;\n+    unsigned  char *read_buff = NULL;\n+    unsigned  char *next_buff = NULL;\n+    tsize_t   prev_cropsize = 0;\n \n-  read_buff = *read_buff_ptr;\n+    read_buff = *read_buff_ptr;\n \n-  if (crop->img_mode == COMPOSITE_IMAGES)\n+    if (crop->img_mode == COMPOSITE_IMAGES)\n     {\n-    cropsize = crop->bufftotal;\n-    crop_buff = seg_buffs[0].buffer; \n-    if (!crop_buff)\n-      crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    else\n-      {\n-      prev_cropsize = seg_buffs[0].size;\n-      if (prev_cropsize < cropsize)\n-        {\n-        next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-        if (! next_buff)\n-          {\n-          _TIFFfree (crop_buff);\n-          crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          }\n+        cropsize = crop->bufftotal;\n+        crop_buff = seg_buffs[0].buffer; \n+        if (!crop_buff)\n+            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n         else\n-          crop_buff = next_buff;\n+        {\n+            prev_cropsize = seg_buffs[0].size;\n+            if (prev_cropsize < cropsize)\n+            {\n+                next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                if (!next_buff)\n+                {\n+                    _TIFFfree(crop_buff);\n+                    crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                }\n+                else\n+                    crop_buff = next_buff;\n+            }\n         }\n-      }\n \n-    if (!crop_buff)\n-      {\n-      TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-      return (-1);\n-      }\n- \n-    _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    seg_buffs[0].buffer = crop_buff;\n-    seg_buffs[0].size = cropsize;\n-\n-    /* Checks for matching width or length as required */\n-    if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n-      return (1);\n-\n-    if (crop->crop_mode & CROP_INVERT)\n-      {\n-      switch (crop->photometric)\n-        {\n-        /* Just change the interpretation */\n-        case PHOTOMETRIC_MINISWHITE:\n-        case PHOTOMETRIC_MINISBLACK:\n-\t     image->photometric = crop->photometric;\n-\t     break;\n-        case INVERT_DATA_ONLY:\n-        case INVERT_DATA_AND_TAG:\n-             if (invertImage(image->photometric, image->spp, image->bps, \n-                             crop->combined_width, crop->combined_length, crop_buff))\n-               {\n-               TIFFError("processCropSelections", \n-                         "Failed to invert colorspace for composite regions");\n-               return (-1);\n-               }\n-             if (crop->photometric == INVERT_DATA_AND_TAG)\n-               {\n-               switch (image->photometric)\n-                 {\n-                 case PHOTOMETRIC_MINISWHITE:\n- \t              image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t              break;\n-                 case PHOTOMETRIC_MINISBLACK:\n- \t              image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t              break;\n-                 default:\n-\t              break;\n-\t         }\n-\t       }\n-             break;\n-        default: break;\n+        if (!crop_buff)\n+        {\n+            TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+            return (-1);\n         }\n-      }\n \n-    /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n-    if (crop->crop_mode & CROP_MIRROR)\n-      {\n-      if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                      crop->combined_width, crop->combined_length, crop_buff))\n-        {\n-        TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n-\t         (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-        return (-1);\n-        }\n-      }\n+        _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+        seg_buffs[0].buffer = crop_buff;\n+        seg_buffs[0].size = cropsize;\n \n-    if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-      {\n-      if (rotateImage(crop->rotation, image, &crop->combined_width, \n-                      &crop->combined_length, &crop_buff))\n-        {\n-        TIFFError("processCropSelections", \n-                  "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n-        return (-1);\n-        }\n-      seg_buffs[0].buffer = crop_buff;\n-      seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n-                            * image->spp) * crop->combined_length; \n-      }\n-    }\n-  else  /* Separated Images */\n-    {\n-    total_width = total_length = 0;\n-    for (i = 0; i < crop->selections; i++)\n-      {\n+        /* Checks for matching width or length as required */\n+        if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n+            return (1);\n \n-        cropsize = crop->bufftotal;\n-      crop_buff = seg_buffs[i].buffer; \n-      if (!crop_buff)\n-        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      else\n-        {\n-        prev_cropsize = seg_buffs[0].size;\n-        if (prev_cropsize < cropsize)\n-          {\n-          next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          if (! next_buff)\n+        if (crop->crop_mode & CROP_INVERT)\n+        {\n+            switch (crop->photometric)\n             {\n-            _TIFFfree (crop_buff);\n-            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                /* Just change the interpretation */\n+                case PHOTOMETRIC_MINISWHITE:\n+                case PHOTOMETRIC_MINISBLACK:\n+                    image->photometric = crop->photometric;\n+                    break;\n+                case INVERT_DATA_ONLY:\n+                case INVERT_DATA_AND_TAG:\n+                    if (invertImage(image->photometric, image->spp, image->bps, \n+                                    crop->combined_width, crop->combined_length, crop_buff))\n+                    {\n+                        TIFFError("processCropSelections", \n+                                  "Failed to invert colorspace for composite regions");\n+                        return (-1);\n+                    }\n+                    if (crop->photometric == INVERT_DATA_AND_TAG)\n+                    {\n+                        switch (image->photometric)\n+                        {\n+                            case PHOTOMETRIC_MINISWHITE:\n+                                image->photometric = PHOTOMETRIC_MINISBLACK;\n+                                break;\n+                            case PHOTOMETRIC_MINISBLACK:\n+                                image->photometric = PHOTOMETRIC_MINISWHITE;\n+                                break;\n+                            default:\n+                                break;\n+                        }\n+                    }\n+                    break;\n+                default: break;\n             }\n-          else\n-            crop_buff = next_buff;\n-          }\n         }\n \n-      if (!crop_buff)\n+        /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n+        if (crop->crop_mode & CROP_MIRROR)\n         {\n-        TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-        return (-1);\n+            if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                            crop->combined_width, crop->combined_length, crop_buff))\n+            {\n+                TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n+                          (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                return (-1);\n+            }\n         }\n- \n-      _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      seg_buffs[i].buffer = crop_buff;\n-      seg_buffs[i].size = cropsize;\n \n-      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+        if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n         {\n-\tTIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n-        return (-1);\n-        }\n-    \n-      width  = crop->regionlist[i].width;\n-      length = crop->regionlist[i].length;\n-\n-      if (crop->crop_mode & CROP_INVERT)\n-        {\n-        switch (crop->photometric)\n-          {\n-          /* Just change the interpretation */\n-          case PHOTOMETRIC_MINISWHITE:\n-          case PHOTOMETRIC_MINISBLACK:\n-\t       image->photometric = crop->photometric;\n-\t       break;\n-          case INVERT_DATA_ONLY:\n-          case INVERT_DATA_AND_TAG:\n-               if (invertImage(image->photometric, image->spp, image->bps, \n-                               width, length, crop_buff))\n-                 {\n-                 TIFFError("processCropSelections", \n-                           "Failed to invert colorspace for region");\n-                 return (-1);\n-                 }\n-               if (crop->photometric == INVERT_DATA_AND_TAG)\n-                 {\n-                 switch (image->photometric)\n-                   {\n-                   case PHOTOMETRIC_MINISWHITE:\n- \t                image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t                break;\n-                   case PHOTOMETRIC_MINISBLACK:\n- \t                image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t                break;\n-                   default:\n-\t                break;\n-\t           }\n-\t         }\n-               break;\n-          default: break;\n-          }\n+            if (rotateImage(crop->rotation, image, &crop->combined_width, \n+                            &crop->combined_length, &crop_buff))\n+            {\n+                TIFFError("processCropSelections", \n+                          "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n+                return (-1);\n+            }\n+            seg_buffs[0].buffer = crop_buff;\n+            seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n+                                  * image->spp) * crop->combined_length; \n         }\n-\n-      if (crop->crop_mode & CROP_MIRROR)\n+    }\n+    else  /* Separated Images */\n+    {\n+        total_width = total_length = 0;\n+        for (i = 0; i < crop->selections; i++)\n         {\n-        if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                        width, length, crop_buff))\n-          {\n-          TIFFError("processCropSelections", "Failed to mirror crop region %s", \n-\t           (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-          return (-1);\n-          }\n-        }\n+            cropsize = crop->bufftotal;\n+            crop_buff = seg_buffs[i].buffer; \n+            if (!crop_buff)\n+                crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            else\n+            {\n+                prev_cropsize = seg_buffs[i].size;\n+                if (prev_cropsize < cropsize)\n+                {\n+                    next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    if (!next_buff)\n+                    {\n+                        _TIFFfree(crop_buff);\n+                        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    }\n+                    else\n+                        crop_buff = next_buff;\n+                }\n+            }\n \n-      if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-        {\n-          /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it schouldn\'t do here, when more than one section is processed. \n-           * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n-           */\n-\tif (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n-\t\t\t&crop->regionlist[i].length, &crop_buff))\n-          {\n-          TIFFError("processCropSelections", \n-                    "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n-          return (-1);\n-          }\n-        total_width  += crop->regionlist[i].width;\n-        total_length += crop->regionlist[i].length;\n-        crop->combined_width = total_width;\n-        crop->combined_length = total_length;\n-        seg_buffs[i].buffer = crop_buff;\n-        seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n-                               * image->spp) * crop->regionlist[i].length; \n-        }\n-      }  /* for crop->selections loop */\n+            if (!crop_buff)\n+            {\n+                TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+                return (-1);\n+            }\n+\n+            _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            seg_buffs[i].buffer = crop_buff;\n+            seg_buffs[i].size = cropsize;\n+\n+            if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+            {\n+                TIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n+                return (-1);\n+            }\n+\n+            width  = crop->regionlist[i].width;\n+            length = crop->regionlist[i].length;\n+\n+            if (width <= 0 || length <= 0)\n+            {\n+                TIFFError("processCropSelections", "Invalid dimensions for crop region %d", i);\n+                return (-1);\n+            }\n+\n+            if (crop->crop_mode & CROP_INVERT)\n+            {\n+                switch (crop->photometric)\n+                {\n+                    /* Just change the interpretation */\n+                    case PHOTOMETRIC_MINISWHITE:\n+                    case PHOTOMETRIC_MINISBLACK:\n+                        image->photometric = crop->photometric;\n+                        break;\n+                    case INVERT_DATA_ONLY:\n+                    case INVERT_DATA_AND_TAG:\n+                        if (invertImage(image->photometric, image->spp, image->bps, \n+                                        width, length, crop_buff))\n+                        {\n+                            TIFFError("processCropSelections", \n+                                      "Failed to invert colorspace for region");\n+                            return (-1);\n+                        }\n+                        if (crop->photometric == INVERT_DATA_AND_TAG)\n+                        {\n+                            switch (image->photometric)\n+                            {\n+                                case PHOTOMETRIC_MINISWHITE:\n+                                    image->photometric = PHOTOMETRIC_MINISBLACK;\n+                                    break;\n+                                case PHOTOMETRIC_MINISBLACK:\n+                                    image->photometric = PHOTOMETRIC_MINISWHITE;\n+                                    break;\n+                                default:\n+                                    break;\n+                            }\n+                        }\n+                        break;\n+                    default: break;\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_MIRROR)\n+            {\n+                if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                                width, length, crop_buff))\n+                {\n+                    TIFFError("processCropSelections", "Failed to mirror crop region %s", \n+                               (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                    return (-1);\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n+            {\n+                if (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n+                                &crop->regionlist[i].length, &crop_buff))\n+                {\n+                    TIFFError("processCropSelections", \n+                              "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n+                    return (-1);\n+                }\n+            total_width  += crop->regionlist[i].width;\n+            total_length += crop->regionlist[i].length;\n+            crop->combined_width = total_width;\n+            crop->combined_length = total_length;\n+            seg_buffs[i].buffer = crop_buff;\n+            seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n+                                  * image->spp) * crop->regionlist[i].length; \n+            }\n+        }  /* for crop->selections loop */\n     }  /* Separated Images (else case) */\n-  return (0);\n-  } /* end processCropSelections */\n+    return (0);\n+} /* end processCropSelections */\n+\n \n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n', 'id': 30, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7836:7'}, {'diff': '@@ -7678,236 +7678,236 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n-  {\n-  int       i;\n-  uint32_t    width, length, total_width, total_length;\n-  tsize_t   cropsize;\n-  unsigned  char *crop_buff = NULL;\n-  unsigned  char *read_buff = NULL;\n-  unsigned  char *next_buff = NULL;\n-  tsize_t   prev_cropsize = 0;\n+{\n+    int       i;\n+    uint32_t    width, length, total_width, total_length;\n+    tsize_t   cropsize;\n+    unsigned  char *crop_buff = NULL;\n+    unsigned  char *read_buff = NULL;\n+    unsigned  char *next_buff = NULL;\n+    tsize_t   prev_cropsize = 0;\n \n-  read_buff = *read_buff_ptr;\n+    read_buff = *read_buff_ptr;\n \n-  if (crop->img_mode == COMPOSITE_IMAGES)\n+    if (crop->img_mode == COMPOSITE_IMAGES)\n     {\n-    cropsize = crop->bufftotal;\n-    crop_buff = seg_buffs[0].buffer; \n-    if (!crop_buff)\n-      crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    else\n-      {\n-      prev_cropsize = seg_buffs[0].size;\n-      if (prev_cropsize < cropsize)\n-        {\n-        next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-        if (! next_buff)\n-          {\n-          _TIFFfree (crop_buff);\n-          crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          }\n+        cropsize = crop->bufftotal;\n+        crop_buff = seg_buffs[0].buffer; \n+        if (!crop_buff)\n+            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n         else\n-          crop_buff = next_buff;\n+        {\n+            prev_cropsize = seg_buffs[0].size;\n+            if (prev_cropsize < cropsize)\n+            {\n+                next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                if (! next_buff)\n+                {\n+                    _TIFFfree (crop_buff);\n+                    crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                }\n+                else\n+                    crop_buff = next_buff;\n+            }\n         }\n-      }\n \n-    if (!crop_buff)\n-      {\n-      TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-      return (-1);\n-      }\n- \n-    _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    seg_buffs[0].buffer = crop_buff;\n-    seg_buffs[0].size = cropsize;\n-\n-    /* Checks for matching width or length as required */\n-    if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n-      return (1);\n-\n-    if (crop->crop_mode & CROP_INVERT)\n-      {\n-      switch (crop->photometric)\n-        {\n-        /* Just change the interpretation */\n-        case PHOTOMETRIC_MINISWHITE:\n-        case PHOTOMETRIC_MINISBLACK:\n-\t     image->photometric = crop->photometric;\n-\t     break;\n-        case INVERT_DATA_ONLY:\n-        case INVERT_DATA_AND_TAG:\n-             if (invertImage(image->photometric, image->spp, image->bps, \n-                             crop->combined_width, crop->combined_length, crop_buff))\n-               {\n-               TIFFError("processCropSelections", \n-                         "Failed to invert colorspace for composite regions");\n-               return (-1);\n-               }\n-             if (crop->photometric == INVERT_DATA_AND_TAG)\n-               {\n-               switch (image->photometric)\n-                 {\n-                 case PHOTOMETRIC_MINISWHITE:\n- \t              image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t              break;\n-                 case PHOTOMETRIC_MINISBLACK:\n- \t              image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t              break;\n-                 default:\n-\t              break;\n-\t         }\n-\t       }\n-             break;\n-        default: break;\n+        if (!crop_buff)\n+        {\n+            TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+            return (-1);\n         }\n-      }\n \n-    /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n-    if (crop->crop_mode & CROP_MIRROR)\n-      {\n-      if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                      crop->combined_width, crop->combined_length, crop_buff))\n-        {\n-        TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n-\t         (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-        return (-1);\n-        }\n-      }\n+        _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+        seg_buffs[0].buffer = crop_buff;\n+        seg_buffs[0].size = cropsize;\n \n-    if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-      {\n-      if (rotateImage(crop->rotation, image, &crop->combined_width, \n-                      &crop->combined_length, &crop_buff))\n-        {\n-        TIFFError("processCropSelections", \n-                  "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n-        return (-1);\n-        }\n-      seg_buffs[0].buffer = crop_buff;\n-      seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n-                            * image->spp) * crop->combined_length; \n-      }\n-    }\n-  else  /* Separated Images */\n-    {\n-    total_width = total_length = 0;\n-    for (i = 0; i < crop->selections; i++)\n-      {\n+        /* Checks for matching width or length as required */\n+        if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n+            return (1);\n \n-        cropsize = crop->bufftotal;\n-      crop_buff = seg_buffs[i].buffer; \n-      if (!crop_buff)\n-        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      else\n-        {\n-        prev_cropsize = seg_buffs[0].size;\n-        if (prev_cropsize < cropsize)\n-          {\n-          next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          if (! next_buff)\n+        if (crop->crop_mode & CROP_INVERT)\n+        {\n+            switch (crop->photometric)\n             {\n-            _TIFFfree (crop_buff);\n-            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                /* Just change the interpretation */\n+                case PHOTOMETRIC_MINISWHITE:\n+                case PHOTOMETRIC_MINISBLACK:\n+                    image->photometric = crop->photometric;\n+                    break;\n+                case INVERT_DATA_ONLY:\n+                case INVERT_DATA_AND_TAG:\n+                    if (invertImage(image->photometric, image->spp, image->bps, \n+                                    crop->combined_width, crop->combined_length, crop_buff))\n+                    {\n+                        TIFFError("processCropSelections", \n+                        "Failed to invert colorspace for composite regions");\n+                        return (-1);\n+                    }\n+                    if (crop->photometric == INVERT_DATA_AND_TAG)\n+                    {\n+                        switch (image->photometric)\n+                        {\n+                            case PHOTOMETRIC_MINISWHITE:\n+                                image->photometric = PHOTOMETRIC_MINISBLACK;\n+                                break;\n+                            case PHOTOMETRIC_MINISBLACK:\n+                                image->photometric = PHOTOMETRIC_MINISWHITE;\n+                                break;\n+                            default:\n+                                break;\n+                        }\n+                    }\n+                    break;\n+                default: break;\n             }\n-          else\n-            crop_buff = next_buff;\n-          }\n         }\n \n-      if (!crop_buff)\n+        /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n+        if (crop->crop_mode & CROP_MIRROR)\n         {\n-        TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-        return (-1);\n+            if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                            crop->combined_width, crop->combined_length, crop_buff))\n+            {\n+                TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n+                          (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                return (-1);\n+            }\n         }\n- \n-      _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      seg_buffs[i].buffer = crop_buff;\n-      seg_buffs[i].size = cropsize;\n \n-      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+        if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n         {\n-\tTIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n-        return (-1);\n-        }\n-    \n-      width  = crop->regionlist[i].width;\n-      length = crop->regionlist[i].length;\n-\n-      if (crop->crop_mode & CROP_INVERT)\n-        {\n-        switch (crop->photometric)\n-          {\n-          /* Just change the interpretation */\n-          case PHOTOMETRIC_MINISWHITE:\n-          case PHOTOMETRIC_MINISBLACK:\n-\t       image->photometric = crop->photometric;\n-\t       break;\n-          case INVERT_DATA_ONLY:\n-          case INVERT_DATA_AND_TAG:\n-               if (invertImage(image->photometric, image->spp, image->bps, \n-                               width, length, crop_buff))\n-                 {\n-                 TIFFError("processCropSelections", \n-                           "Failed to invert colorspace for region");\n-                 return (-1);\n-                 }\n-               if (crop->photometric == INVERT_DATA_AND_TAG)\n-                 {\n-                 switch (image->photometric)\n-                   {\n-                   case PHOTOMETRIC_MINISWHITE:\n- \t                image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t                break;\n-                   case PHOTOMETRIC_MINISBLACK:\n- \t                image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t                break;\n-                   default:\n-\t                break;\n-\t           }\n-\t         }\n-               break;\n-          default: break;\n-          }\n+            if (rotateImage(crop->rotation, image, &crop->combined_width, \n+                            &crop->combined_length, &crop_buff))\n+            {\n+                TIFFError("processCropSelections", \n+                        "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n+                return (-1);\n+            }\n+            seg_buffs[0].buffer = crop_buff;\n+            seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n+                                  * image->spp) * crop->combined_length; \n         }\n-\n-      if (crop->crop_mode & CROP_MIRROR)\n+    }\n+    else  /* Separated Images */\n+    {\n+        total_width = total_length = 0;\n+        for (i = 0; i < crop->selections; i++)\n         {\n-        if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                        width, length, crop_buff))\n-          {\n-          TIFFError("processCropSelections", "Failed to mirror crop region %s", \n-\t           (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-          return (-1);\n-          }\n-        }\n+            cropsize = crop->bufftotal;\n+            crop_buff = seg_buffs[i].buffer; \n+            if (!crop_buff)\n+                crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            else\n+            {\n+                prev_cropsize = seg_buffs[i].size;\n+                if (prev_cropsize < cropsize)\n+                {\n+                    next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    if (! next_buff)\n+                    {\n+                        _TIFFfree (crop_buff);\n+                        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    }\n+                    else\n+                        crop_buff = next_buff;\n+                }\n+            }\n \n-      if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-        {\n-          /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it schouldn\'t do here, when more than one section is processed. \n-           * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n-           */\n-\tif (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n-\t\t\t&crop->regionlist[i].length, &crop_buff))\n-          {\n-          TIFFError("processCropSelections", \n-                    "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n-          return (-1);\n-          }\n-        total_width  += crop->regionlist[i].width;\n-        total_length += crop->regionlist[i].length;\n-        crop->combined_width = total_width;\n-        crop->combined_length = total_length;\n-        seg_buffs[i].buffer = crop_buff;\n-        seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n-                               * image->spp) * crop->regionlist[i].length; \n-        }\n-      }  /* for crop->selections loop */\n+            if (!crop_buff)\n+            {\n+                TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+                return (-1);\n+            }\n+\n+            _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            seg_buffs[i].buffer = crop_buff;\n+            seg_buffs[i].size = cropsize;\n+\n+            if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+            {\n+                TIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n+                return (-1);\n+            }\n+\n+            length = crop->regionlist[i].length;\n+\n+            if (i < crop->selections)  // Check to prevent out-of-bounds access\n+                width  = crop->regionlist[i].width;\n+\n+            if (crop->crop_mode & CROP_INVERT)\n+            {\n+                switch (crop->photometric)\n+                {\n+                    /* Just change the interpretation */\n+                    case PHOTOMETRIC_MINISWHITE:\n+                    case PHOTOMETRIC_MINISBLACK:\n+                        image->photographic = crop->photometric;\n+                        break;\n+                    case INVERT_DATA_ONLY:\n+                    case INVERT_DATA_AND_TAG:\n+                        if (invertImage(image->photometric, image->spp, image->bps, \n+                                        width, length, crop_buff))\n+                        {\n+                            TIFFError("processCropSelections", \n+                                      "Failed to invert colorspace for region");\n+                            return (-1);\n+                        }\n+                        if (crop->photometric == INVERT_DATA_AND_TAG)\n+                        {\n+                            switch (image->photometric)\n+                            {\n+                                case PHOTOMETRIC_MINISWHITE:\n+                                    image->photometric = PHOTOMETRIC_MINISBLACK;\n+                                    break;\n+                                case PHOTOMETRIC_MINISBLACK:\n+                                    image->photometric = PHOTOMETRIC_MINISWHITE;\n+                                    break;\n+                                default:\n+                                    break;\n+                            }\n+                        }\n+                        break;\n+                    default: break;\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_MIRROR)\n+            {\n+                if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                                width, length, crop_buff))\n+                {\n+                    TIFFError("processCropSelections", "Failed to mirror crop region %s", \n+                              (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                    return (-1);\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n+            {\n+                if (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n+                                &crop->regionlist[i].length, &crop_buff))\n+                {\n+                    TIFFError("processCropSelections", \n+                            "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n+                    return (-1);\n+                }\n+            total_width  += crop->regionlist[i].width;\n+            total_length += crop->regionlist[i].length;\n+            crop->combined_width = total_width;\n+            crop->combined_length = total_length;\n+            seg_buffs[i].buffer = crop_buff;\n+            seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n+                                  * image->spp) * crop->regionlist[i].length; \n+            }\n+        }  /* for crop->selections loop */\n     }  /* Separated Images (else case) */\n-  return (0);\n-  } /* end processCropSelections */\n+    return (0);\n+} /* end processCropSelections */\n+\n \n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n', 'id': 31, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7836:7'}, {'diff': "@@ -7678,10 +7678,11 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n-  {\n+{\n   int       i;\n   uint32_t    width, length, total_width, total_length;\n   tsize_t   cropsize;\n@@ -7803,7 +7804,7 @@\n         crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n       else\n         {\n-        prev_cropsize = seg_buffs[0].size;\n+        prev_cropsize = seg_buffs[i].size; // Modified to use seg_buffs[i].size\n         if (prev_cropsize < cropsize)\n           {\n           next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n@@ -7886,9 +7887,6 @@\n \n       if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n         {\n-          /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it schouldn't do here, when more than one section is processed. \n-           * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n-           */\n \tif (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n \t\t\t&crop->regionlist[i].length, &crop_buff))\n           {\n@@ -7907,7 +7905,8 @@\n       }  /* for crop->selections loop */\n     }  /* Separated Images (else case) */\n   return (0);\n-  } /* end processCropSelections */\n+} /* end processCropSelections */\n+\n \n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n", 'id': 32, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7836:7'}, {'diff': "@@ -7678,10 +7678,11 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n-  {\n+{\n   int       i;\n   uint32_t    width, length, total_width, total_length;\n   tsize_t   cropsize;\n@@ -7796,14 +7797,13 @@\n     total_width = total_length = 0;\n     for (i = 0; i < crop->selections; i++)\n       {\n-\n         cropsize = crop->bufftotal;\n       crop_buff = seg_buffs[i].buffer; \n       if (!crop_buff)\n         crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n       else\n         {\n-        prev_cropsize = seg_buffs[0].size;\n+        prev_cropsize = seg_buffs[i].size; // Fix here\n         if (prev_cropsize < cropsize)\n           {\n           next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n@@ -7833,7 +7833,7 @@\n         return (-1);\n         }\n     \n-      width  = crop->regionlist[i].width;\n+      width  = crop->regionlist[i].width; // Fix here\n       length = crop->regionlist[i].length;\n \n       if (crop->crop_mode & CROP_INVERT)\n@@ -7886,9 +7886,6 @@\n \n       if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n         {\n-          /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it schouldn't do here, when more than one section is processed. \n-           * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n-           */\n \tif (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n \t\t\t&crop->regionlist[i].length, &crop_buff))\n           {\n@@ -7907,7 +7904,8 @@\n       }  /* for crop->selections loop */\n     }  /* Separated Images (else case) */\n   return (0);\n-  } /* end processCropSelections */\n+} /* end processCropSelections */\n+\n \n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n", 'id': 33, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7836:7'}, {'diff': '@@ -7678,10 +7678,11 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n-  {\n+{\n   int       i;\n   uint32_t    width, length, total_width, total_length;\n   tsize_t   cropsize;\n@@ -7735,32 +7736,32 @@\n         /* Just change the interpretation */\n         case PHOTOMETRIC_MINISWHITE:\n         case PHOTOMETRIC_MINISBLACK:\n-\t     image->photometric = crop->photometric;\n-\t     break;\n+          image->photometric = crop->photometric;\n+          break;\n         case INVERT_DATA_ONLY:\n         case INVERT_DATA_AND_TAG:\n-             if (invertImage(image->photometric, image->spp, image->bps, \n-                             crop->combined_width, crop->combined_length, crop_buff))\n-               {\n-               TIFFError("processCropSelections", \n-                         "Failed to invert colorspace for composite regions");\n-               return (-1);\n-               }\n-             if (crop->photometric == INVERT_DATA_AND_TAG)\n-               {\n-               switch (image->photometric)\n-                 {\n-                 case PHOTOMETRIC_MINISWHITE:\n- \t              image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t              break;\n-                 case PHOTOMETRIC_MINISBLACK:\n- \t              image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t              break;\n-                 default:\n-\t              break;\n-\t         }\n-\t       }\n-             break;\n+          if (invertImage(image->photometric, image->spp, image->bps, \n+                          crop->combined_width, crop->combined_length, crop_buff))\n+            {\n+            TIFFError("processCropSelections", \n+                      "Failed to invert colorspace for composite regions");\n+            return (-1);\n+            }\n+          if (crop->photometric == INVERT_DATA_AND_TAG)\n+            {\n+            switch (image->photometric)\n+              {\n+              case PHOTOMETRIC_MINISWHITE:\n+                image->photometric = PHOTOMETRIC_MINISBLACK;\n+                break;\n+              case PHOTOMETRIC_MINISBLACK:\n+                image->photometric = PHOTOMETRIC_MINISWHITE;\n+                break;\n+              default:\n+                break;\n+              }\n+            }\n+          break;\n         default: break;\n         }\n       }\n@@ -7772,7 +7773,7 @@\n                       crop->combined_width, crop->combined_length, crop_buff))\n         {\n         TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n-\t         (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                  (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n         return (-1);\n         }\n       }\n@@ -7796,118 +7797,124 @@\n     total_width = total_length = 0;\n     for (i = 0; i < crop->selections; i++)\n       {\n+        if (i >= MAX_CROP_SELECTIONS) // Added bounds checking\n+        {\n+          TIFFError("processCropSelections", "Index out of bounds for crop selections");\n+          return (-1);\n+        }\n \n         cropsize = crop->bufftotal;\n-      crop_buff = seg_buffs[i].buffer; \n-      if (!crop_buff)\n-        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      else\n-        {\n-        prev_cropsize = seg_buffs[0].size;\n-        if (prev_cropsize < cropsize)\n+        crop_buff = seg_buffs[i].buffer; \n+        if (!crop_buff)\n+          crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+        else\n           {\n-          next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          if (! next_buff)\n+          prev_cropsize = seg_buffs[i].size; // Changed to seg_buffs[i].size for correct verification\n+          if (prev_cropsize < cropsize)\n             {\n-            _TIFFfree (crop_buff);\n-            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            if (! next_buff)\n+              {\n+              _TIFFfree (crop_buff);\n+              crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+              }\n+            else\n+              crop_buff = next_buff;\n             }\n-          else\n-            crop_buff = next_buff;\n           }\n-        }\n \n-      if (!crop_buff)\n-        {\n-        TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-        return (-1);\n-        }\n+        if (!crop_buff)\n+          {\n+          TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+          return (-1);\n+          }\n  \n-      _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      seg_buffs[i].buffer = crop_buff;\n-      seg_buffs[i].size = cropsize;\n+        _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+        seg_buffs[i].buffer = crop_buff;\n+        seg_buffs[i].size = cropsize;\n \n-      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n-        {\n-\tTIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n-        return (-1);\n-        }\n+        if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+          {\n+          TIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n+          return (-1);\n+          }\n     \n-      width  = crop->regionlist[i].width;\n-      length = crop->regionlist[i].length;\n+        width  = crop->regionlist[i].width;\n+        length = crop->regionlist[i].length;\n \n-      if (crop->crop_mode & CROP_INVERT)\n-        {\n-        switch (crop->photometric)\n+        if (crop->crop_mode & CROP_INVERT)\n           {\n-          /* Just change the interpretation */\n-          case PHOTOMETRIC_MINISWHITE:\n-          case PHOTOMETRIC_MINISBLACK:\n-\t       image->photometric = crop->photometric;\n-\t       break;\n-          case INVERT_DATA_ONLY:\n-          case INVERT_DATA_AND_TAG:\n-               if (invertImage(image->photometric, image->spp, image->bps, \n-                               width, length, crop_buff))\n-                 {\n-                 TIFFError("processCropSelections", \n-                           "Failed to invert colorspace for region");\n-                 return (-1);\n-                 }\n-               if (crop->photometric == INVERT_DATA_AND_TAG)\n-                 {\n-                 switch (image->photometric)\n-                   {\n-                   case PHOTOMETRIC_MINISWHITE:\n- \t                image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t                break;\n-                   case PHOTOMETRIC_MINISBLACK:\n- \t                image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t                break;\n-                   default:\n-\t                break;\n-\t           }\n-\t         }\n-               break;\n-          default: break;\n+          switch (crop->photometric)\n+            {\n+            /* Just change the interpretation */\n+            case PHOTOMETRIC_MINISWHITE:\n+            case PHOTOMETRIC_MINISBLACK:\n+              image->photometric = crop->photometric;\n+              break;\n+            case INVERT_DATA_ONLY:\n+            case INVERT_DATA_AND_TAG:\n+              if (invertImage(image->photometric, image->spp, image->bps, \n+                              width, length, crop_buff))\n+                {\n+                TIFFError("processCropSelections", \n+                          "Failed to invert colorspace for region");\n+                return (-1);\n+                }\n+              if (crop->photometric == INVERT_DATA_AND_TAG)\n+                {\n+                switch (image->photometric)\n+                  {\n+                  case PHOTOMETRIC_MINISWHITE:\n+                    image->photometric = PHOTOMETRIC_MINISBLACK;\n+                    break;\n+                  case PHOTOMETRIC_MINISBLACK:\n+                    image->photometric = PHOTOMETRIC_MINISWHITE;\n+                    break;\n+                  default:\n+                    break;\n+                  }\n+                }\n+              break;\n+            default: break;\n+            }\n           }\n-        }\n \n-      if (crop->crop_mode & CROP_MIRROR)\n-        {\n-        if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                        width, length, crop_buff))\n+        if (crop->crop_mode & CROP_MIRROR)\n           {\n-          TIFFError("processCropSelections", "Failed to mirror crop region %s", \n-\t           (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-          return (-1);\n+          if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                          width, length, crop_buff))\n+            {\n+            TIFFError("processCropSelections", "Failed to mirror crop region %s", \n+                     (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+            return (-1);\n+            }\n           }\n-        }\n \n-      if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-        {\n+        if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n+          {\n           /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it schouldn\'t do here, when more than one section is processed. \n            * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n            */\n-\tif (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n-\t\t\t&crop->regionlist[i].length, &crop_buff))\n-          {\n-          TIFFError("processCropSelections", \n-                    "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n-          return (-1);\n-          }\n-        total_width  += crop->regionlist[i].width;\n-        total_length += crop->regionlist[i].length;\n-        crop->combined_width = total_width;\n-        crop->combined_length = total_length;\n-        seg_buffs[i].buffer = crop_buff;\n-        seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n+          if (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n+                          &crop->regionlist[i].length, &crop_buff))\n+            {\n+            TIFFError("processCropSelections", \n+                      "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n+            return (-1);\n+            }\n+          total_width  += crop->regionlist[i].width;\n+          total_length += crop->regionlist[i].length;\n+          crop->combined_width = total_width;\n+          crop->combined_length = total_length;\n+          seg_buffs[i].buffer = crop_buff;\n+          seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n                                * image->spp) * crop->regionlist[i].length; \n-        }\n+          }\n       }  /* for crop->selections loop */\n     }  /* Separated Images (else case) */\n   return (0);\n-  } /* end processCropSelections */\n+} /* end processCropSelections */\n+\n \n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n', 'id': 34, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7836:7'}, {'diff': '@@ -7678,10 +7678,11 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n-  {\n+{\n   int       i;\n   uint32_t    width, length, total_width, total_length;\n   tsize_t   cropsize;\n@@ -7827,9 +7828,10 @@\n       seg_buffs[i].buffer = crop_buff;\n       seg_buffs[i].size = cropsize;\n \n-      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i) != 0)\n         {\n-\tTIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n+        TIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n+        _TIFFfree(crop_buff); // Free memory to prevent leaks\n         return (-1);\n         }\n     \n@@ -7852,6 +7854,7 @@\n                  {\n                  TIFFError("processCropSelections", \n                            "Failed to invert colorspace for region");\n+                 _TIFFfree(crop_buff); // Free memory to prevent leaks\n                  return (-1);\n                  }\n                if (crop->photometric == INVERT_DATA_AND_TAG)\n@@ -7880,20 +7883,19 @@\n           {\n           TIFFError("processCropSelections", "Failed to mirror crop region %s", \n \t           (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+          _TIFFfree(crop_buff); // Free memory to prevent leaks\n           return (-1);\n           }\n         }\n \n       if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n         {\n-          /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it schouldn\'t do here, when more than one section is processed. \n-           * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n-           */\n \tif (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n \t\t\t&crop->regionlist[i].length, &crop_buff))\n           {\n           TIFFError("processCropSelections", \n                     "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n+          _TIFFfree(crop_buff); // Free memory to prevent leaks\n           return (-1);\n           }\n         total_width  += crop->regionlist[i].width;\n@@ -7907,7 +7909,8 @@\n       }  /* for crop->selections loop */\n     }  /* Separated Images (else case) */\n   return (0);\n-  } /* end processCropSelections */\n+} /* end processCropSelections */\n+\n \n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n', 'id': 35, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7830:11'}, {'diff': '@@ -7678,10 +7678,11 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n-  {\n+{\n   int       i;\n   uint32_t    width, length, total_width, total_length;\n   tsize_t   cropsize;\n@@ -7803,7 +7804,7 @@\n         crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n       else\n         {\n-        prev_cropsize = seg_buffs[0].size;\n+        prev_cropsize = seg_buffs[i].size;\n         if (prev_cropsize < cropsize)\n           {\n           next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n@@ -7827,9 +7828,10 @@\n       seg_buffs[i].buffer = crop_buff;\n       seg_buffs[i].size = cropsize;\n \n-      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i) != 0)\n         {\n \tTIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n+        _TIFFfree(crop_buff); // Fix: Free allocated buffer on error.\n         return (-1);\n         }\n     \n@@ -7852,6 +7854,7 @@\n                  {\n                  TIFFError("processCropSelections", \n                            "Failed to invert colorspace for region");\n+                 _TIFFfree(crop_buff); // Fix: Free allocated buffer on error.\n                  return (-1);\n                  }\n                if (crop->photometric == INVERT_DATA_AND_TAG)\n@@ -7880,20 +7883,19 @@\n           {\n           TIFFError("processCropSelections", "Failed to mirror crop region %s", \n \t           (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+          _TIFFfree(crop_buff); // Fix: Free allocated buffer on error.\n           return (-1);\n           }\n         }\n \n       if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n         {\n-          /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it schouldn\'t do here, when more than one section is processed. \n-           * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n-           */\n \tif (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n \t\t\t&crop->regionlist[i].length, &crop_buff))\n           {\n           TIFFError("processCropSelections", \n                     "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n+          _TIFFfree(crop_buff); // Fix: Free allocated buffer on error.\n           return (-1);\n           }\n         total_width  += crop->regionlist[i].width;\n@@ -7907,7 +7909,8 @@\n       }  /* for crop->selections loop */\n     }  /* Separated Images (else case) */\n   return (0);\n-  } /* end processCropSelections */\n+} /* end processCropSelections */\n+\n \n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n', 'id': 36, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7830:11'}, {'diff': '@@ -7678,236 +7678,241 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n-  {\n-  int       i;\n-  uint32_t    width, length, total_width, total_length;\n-  tsize_t   cropsize;\n-  unsigned  char *crop_buff = NULL;\n-  unsigned  char *read_buff = NULL;\n-  unsigned  char *next_buff = NULL;\n-  tsize_t   prev_cropsize = 0;\n+{\n+    int       i;\n+    uint32_t    width, length, total_width, total_length;\n+    tsize_t   cropsize;\n+    unsigned  char *crop_buff = NULL;\n+    unsigned  char *read_buff = NULL;\n+    unsigned  char *next_buff = NULL;\n+    tsize_t   prev_cropsize = 0;\n \n-  read_buff = *read_buff_ptr;\n+    read_buff = *read_buff_ptr;\n \n-  if (crop->img_mode == COMPOSITE_IMAGES)\n+    if (crop->img_mode == COMPOSITE_IMAGES)\n     {\n-    cropsize = crop->bufftotal;\n-    crop_buff = seg_buffs[0].buffer; \n-    if (!crop_buff)\n-      crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    else\n-      {\n-      prev_cropsize = seg_buffs[0].size;\n-      if (prev_cropsize < cropsize)\n-        {\n-        next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-        if (! next_buff)\n-          {\n-          _TIFFfree (crop_buff);\n-          crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          }\n+        cropsize = crop->bufftotal;\n+        crop_buff = seg_buffs[0].buffer; \n+        if (!crop_buff)\n+            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n         else\n-          crop_buff = next_buff;\n+        {\n+            prev_cropsize = seg_buffs[0].size;\n+            if (prev_cropsize < cropsize)\n+            {\n+                next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                if (!next_buff)\n+                {\n+                    _TIFFfree(crop_buff);\n+                    crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                }\n+                else\n+                    crop_buff = next_buff;\n+            }\n         }\n-      }\n \n-    if (!crop_buff)\n-      {\n-      TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-      return (-1);\n-      }\n- \n-    _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    seg_buffs[0].buffer = crop_buff;\n-    seg_buffs[0].size = cropsize;\n-\n-    /* Checks for matching width or length as required */\n-    if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n-      return (1);\n-\n-    if (crop->crop_mode & CROP_INVERT)\n-      {\n-      switch (crop->photometric)\n-        {\n-        /* Just change the interpretation */\n-        case PHOTOMETRIC_MINISWHITE:\n-        case PHOTOMETRIC_MINISBLACK:\n-\t     image->photometric = crop->photometric;\n-\t     break;\n-        case INVERT_DATA_ONLY:\n-        case INVERT_DATA_AND_TAG:\n-             if (invertImage(image->photometric, image->spp, image->bps, \n-                             crop->combined_width, crop->combined_length, crop_buff))\n-               {\n-               TIFFError("processCropSelections", \n-                         "Failed to invert colorspace for composite regions");\n-               return (-1);\n-               }\n-             if (crop->photometric == INVERT_DATA_AND_TAG)\n-               {\n-               switch (image->photometric)\n-                 {\n-                 case PHOTOMETRIC_MINISWHITE:\n- \t              image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t              break;\n-                 case PHOTOMETRIC_MINISBLACK:\n- \t              image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t              break;\n-                 default:\n-\t              break;\n-\t         }\n-\t       }\n-             break;\n-        default: break;\n+        if (!crop_buff)\n+        {\n+            TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+            return (-1);\n         }\n-      }\n+ \n+        _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+        seg_buffs[0].buffer = crop_buff;\n+        seg_buffs[0].size = cropsize;\n \n-    /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n-    if (crop->crop_mode & CROP_MIRROR)\n-      {\n-      if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                      crop->combined_width, crop->combined_length, crop_buff))\n-        {\n-        TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n-\t         (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-        return (-1);\n-        }\n-      }\n+        /* Checks for matching width or length as required */\n+        if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n+            return (1);\n \n-    if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-      {\n-      if (rotateImage(crop->rotation, image, &crop->combined_width, \n-                      &crop->combined_length, &crop_buff))\n-        {\n-        TIFFError("processCropSelections", \n-                  "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n-        return (-1);\n+        if (crop->crop_mode & CROP_INVERT)\n+        {\n+            switch (crop->photometric)\n+            {\n+                /* Just change the interpretation */\n+                case PHOTOMETRIC_MINISWHITE:\n+                case PHOTOMETRIC_MINISBLACK:\n+                    image->photometric = crop->photometric;\n+                    break;\n+                case INVERT_DATA_ONLY:\n+                case INVERT_DATA_AND_TAG:\n+                    if (invertImage(image->photometric, image->spp, image->bps, \n+                                    crop->combined_width, crop->combined_length, crop_buff))\n+                    {\n+                        TIFFError("processCropSelections", \n+                                  "Failed to invert colorspace for composite regions");\n+                        return (-1);\n+                    }\n+                    if (crop->photometric == INVERT_DATA_AND_TAG)\n+                    {\n+                        switch (image->photometric)\n+                        {\n+                            case PHOTOMETRIC_MINISWHITE:\n+                                image->photometric = PHOTOMETRIC_MINISBLACK;\n+                                break;\n+                            case PHOTOMETRIC_MINISBLACK:\n+                                image->photometric = PHOTOMETRIC_MINISWHITE;\n+                                break;\n+                            default:\n+                                break;\n+                        }\n+                    }\n+                    break;\n+                default: break;\n+            }\n         }\n-      seg_buffs[0].buffer = crop_buff;\n-      seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n-                            * image->spp) * crop->combined_length; \n-      }\n-    }\n-  else  /* Separated Images */\n-    {\n-    total_width = total_length = 0;\n-    for (i = 0; i < crop->selections; i++)\n-      {\n \n-        cropsize = crop->bufftotal;\n-      crop_buff = seg_buffs[i].buffer; \n-      if (!crop_buff)\n-        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      else\n-        {\n-        prev_cropsize = seg_buffs[0].size;\n-        if (prev_cropsize < cropsize)\n-          {\n-          next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          if (! next_buff)\n+        /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n+        if (crop->crop_mode & CROP_MIRROR)\n+        {\n+            if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                            crop->combined_width, crop->combined_length, crop_buff))\n             {\n-            _TIFFfree (crop_buff);\n-            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n+                         (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                return (-1);\n             }\n-          else\n-            crop_buff = next_buff;\n-          }\n         }\n \n-      if (!crop_buff)\n+        if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n         {\n-        TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-        return (-1);\n+            if (rotateImage(crop->rotation, image, &crop->combined_width, \n+                            &crop->combined_length, &crop_buff))\n+            {\n+                TIFFError("processCropSelections", \n+                          "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n+                return (-1);\n+            }\n+            seg_buffs[0].buffer = crop_buff;\n+            seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n+                                  * image->spp) * crop->combined_length; \n         }\n+    }\n+    else  /* Separated Images */\n+    {\n+        total_width = total_length = 0;\n+        for (i = 0; i < crop->selections; i++)\n+        {\n+            cropsize = crop->bufftotal;\n+            crop_buff = seg_buffs[i].buffer; \n+            if (!crop_buff)\n+                crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            else\n+            {\n+                prev_cropsize = seg_buffs[i].size;\n+                if (prev_cropsize < cropsize)\n+                {\n+                    next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    if (!next_buff)\n+                    {\n+                        _TIFFfree(crop_buff);\n+                        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    }\n+                    else\n+                        crop_buff = next_buff;\n+                }\n+            }\n+\n+            if (!crop_buff)\n+            {\n+                TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+                return (-1);\n+            }\n  \n-      _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      seg_buffs[i].buffer = crop_buff;\n-      seg_buffs[i].size = cropsize;\n+            _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            seg_buffs[i].buffer = crop_buff;\n+            seg_buffs[i].size = cropsize;\n \n-      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n-        {\n-\tTIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n-        return (-1);\n-        }\n-    \n-      width  = crop->regionlist[i].width;\n-      length = crop->regionlist[i].length;\n-\n-      if (crop->crop_mode & CROP_INVERT)\n-        {\n-        switch (crop->photometric)\n-          {\n-          /* Just change the interpretation */\n-          case PHOTOMETRIC_MINISWHITE:\n-          case PHOTOMETRIC_MINISBLACK:\n-\t       image->photometric = crop->photometric;\n-\t       break;\n-          case INVERT_DATA_ONLY:\n-          case INVERT_DATA_AND_TAG:\n-               if (invertImage(image->photometric, image->spp, image->bps, \n-                               width, length, crop_buff))\n-                 {\n-                 TIFFError("processCropSelections", \n-                           "Failed to invert colorspace for region");\n-                 return (-1);\n-                 }\n-               if (crop->photometric == INVERT_DATA_AND_TAG)\n-                 {\n-                 switch (image->photometric)\n-                   {\n-                   case PHOTOMETRIC_MINISWHITE:\n- \t                image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t                break;\n-                   case PHOTOMETRIC_MINISBLACK:\n- \t                image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t                break;\n-                   default:\n-\t                break;\n-\t           }\n-\t         }\n-               break;\n-          default: break;\n-          }\n-        }\n+            if (extractSeparateRegion(image, crop, read_buff, crop_buff, i) != 0)\n+            {\n+                TIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n+                _TIFFfree(crop_buff); // Free allocated memory to prevent memory leak\n+                return (-1);\n+            }\n+        \n+            width  = crop->regionlist[i].width;\n+            length = crop->regionlist[i].length;\n \n-      if (crop->crop_mode & CROP_MIRROR)\n-        {\n-        if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                        width, length, crop_buff))\n-          {\n-          TIFFError("processCropSelections", "Failed to mirror crop region %s", \n-\t           (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-          return (-1);\n-          }\n-        }\n+            if (crop->crop_mode & CROP_INVERT)\n+            {\n+                switch (crop->photometric)\n+                {\n+                    /* Just change the interpretation */\n+                    case PHOTOMETRIC_MINISWHITE:\n+                    case PHOTOMETRIC_MINISBLACK:\n+                        image->photometric = crop->photometric;\n+                        break;\n+                    case INVERT_DATA_ONLY:\n+                    case INVERT_DATA_AND_TAG:\n+                        if (invertImage(image->photometric, image->spp, image->bps, \n+                                        width, length, crop_buff))\n+                        {\n+                            TIFFError("processCropSelections", \n+                                      "Failed to invert colorspace for region");\n+                            _TIFFfree(crop_buff); // Free allocated memory to prevent memory leak\n+                            return (-1);\n+                        }\n+                        if (crop->photometric == INVERT_DATA_AND_TAG)\n+                        {\n+                            switch (image->photometric)\n+                            {\n+                                case PHOTOMETRIC_MINISWHITE:\n+                                    image->photometric = PHOTOMETRIC_MINISBLACK;\n+                                    break;\n+                                case PHOTOMETRIC_MINISBLACK:\n+                                    image->photometric = PHOTOMETRIC_MINISWHITE;\n+                                    break;\n+                                default:\n+                                    break;\n+                            }\n+                        }\n+                        break;\n+                    default: break;\n+                }\n+            }\n \n-      if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-        {\n-          /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it schouldn\'t do here, when more than one section is processed. \n-           * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n-           */\n-\tif (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n-\t\t\t&crop->regionlist[i].length, &crop_buff))\n-          {\n-          TIFFError("processCropSelections", \n-                    "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n-          return (-1);\n-          }\n-        total_width  += crop->regionlist[i].width;\n-        total_length += crop->regionlist[i].length;\n-        crop->combined_width = total_width;\n-        crop->combined_length = total_length;\n-        seg_buffs[i].buffer = crop_buff;\n-        seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n-                               * image->spp) * crop->regionlist[i].length; \n-        }\n-      }  /* for crop->selections loop */\n+            if (crop->crop_mode & CROP_MIRROR)\n+            {\n+                if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                                width, length, crop_buff))\n+                {\n+                    TIFFError("processCropSelections", "Failed to mirror crop region %s", \n+                             (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                    _TIFFfree(crop_buff); // Free allocated memory to prevent memory leak\n+                    return (-1);\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n+            {\n+                /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it shouldn\'t do here, when more than one section is processed. \n+                 * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n+                 */\n+                if (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n+                                &crop->regionlist[i].length, &crop_buff))\n+                {\n+                    TIFFError("processCropSelections", \n+                              "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n+                    _TIFFfree(crop_buff); // Free allocated memory to prevent memory leak\n+                    return (-1);\n+                }\n+            total_width  += crop->regionlist[i].width;\n+            total_length += crop->regionlist[i].length;\n+            crop->combined_width = total_width;\n+            crop->combined_length = total_length;\n+            seg_buffs[i].buffer = crop_buff;\n+            seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n+                                   * image->spp) * crop->regionlist[i].length; \n+            }\n+        }  /* for crop->selections loop */\n     }  /* Separated Images (else case) */\n-  return (0);\n-  } /* end processCropSelections */\n+    return (0);\n+} /* end processCropSelections */\n+\n \n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n', 'id': 37, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7830:11'}, {'diff': '@@ -7678,236 +7678,231 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n-  {\n-  int       i;\n-  uint32_t    width, length, total_width, total_length;\n-  tsize_t   cropsize;\n-  unsigned  char *crop_buff = NULL;\n-  unsigned  char *read_buff = NULL;\n-  unsigned  char *next_buff = NULL;\n-  tsize_t   prev_cropsize = 0;\n+{\n+    int       i;\n+    uint32_t    width, length, total_width, total_length;\n+    tsize_t   cropsize;\n+    unsigned  char *crop_buff = NULL;\n+    unsigned  char *read_buff = NULL;\n+    unsigned  char *next_buff = NULL;\n+    tsize_t   prev_cropsize = 0;\n \n-  read_buff = *read_buff_ptr;\n+    read_buff = *read_buff_ptr;\n \n-  if (crop->img_mode == COMPOSITE_IMAGES)\n+    if (crop->img_mode == COMPOSITE_IMAGES)\n     {\n-    cropsize = crop->bufftotal;\n-    crop_buff = seg_buffs[0].buffer; \n-    if (!crop_buff)\n-      crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    else\n-      {\n-      prev_cropsize = seg_buffs[0].size;\n-      if (prev_cropsize < cropsize)\n-        {\n-        next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-        if (! next_buff)\n-          {\n-          _TIFFfree (crop_buff);\n-          crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          }\n+        cropsize = crop->bufftotal;\n+        crop_buff = seg_buffs[0].buffer; \n+        if (!crop_buff)\n+            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n         else\n-          crop_buff = next_buff;\n+        {\n+            prev_cropsize = seg_buffs[0].size;\n+            if (prev_cropsize < cropsize)\n+            {\n+                next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                if (! next_buff)\n+                {\n+                    _TIFFfree (crop_buff);\n+                    crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                }\n+                else\n+                    crop_buff = next_buff;\n+            }\n         }\n-      }\n \n-    if (!crop_buff)\n-      {\n-      TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-      return (-1);\n-      }\n- \n-    _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-    seg_buffs[0].buffer = crop_buff;\n-    seg_buffs[0].size = cropsize;\n-\n-    /* Checks for matching width or length as required */\n-    if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n-      return (1);\n-\n-    if (crop->crop_mode & CROP_INVERT)\n-      {\n-      switch (crop->photometric)\n-        {\n-        /* Just change the interpretation */\n-        case PHOTOMETRIC_MINISWHITE:\n-        case PHOTOMETRIC_MINISBLACK:\n-\t     image->photometric = crop->photometric;\n-\t     break;\n-        case INVERT_DATA_ONLY:\n-        case INVERT_DATA_AND_TAG:\n-             if (invertImage(image->photometric, image->spp, image->bps, \n-                             crop->combined_width, crop->combined_length, crop_buff))\n-               {\n-               TIFFError("processCropSelections", \n-                         "Failed to invert colorspace for composite regions");\n-               return (-1);\n-               }\n-             if (crop->photometric == INVERT_DATA_AND_TAG)\n-               {\n-               switch (image->photometric)\n-                 {\n-                 case PHOTOMETRIC_MINISWHITE:\n- \t              image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t              break;\n-                 case PHOTOMETRIC_MINISBLACK:\n- \t              image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t              break;\n-                 default:\n-\t              break;\n-\t         }\n-\t       }\n-             break;\n-        default: break;\n+        if (!crop_buff)\n+        {\n+            TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+            return (-1);\n         }\n-      }\n \n-    /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n-    if (crop->crop_mode & CROP_MIRROR)\n-      {\n-      if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                      crop->combined_width, crop->combined_length, crop_buff))\n-        {\n-        TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n-\t         (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-        return (-1);\n-        }\n-      }\n+        _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+        seg_buffs[0].buffer = crop_buff;\n+        seg_buffs[0].size = cropsize;\n \n-    if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-      {\n-      if (rotateImage(crop->rotation, image, &crop->combined_width, \n-                      &crop->combined_length, &crop_buff))\n-        {\n-        TIFFError("processCropSelections", \n-                  "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n-        return (-1);\n-        }\n-      seg_buffs[0].buffer = crop_buff;\n-      seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n-                            * image->spp) * crop->combined_length; \n-      }\n-    }\n-  else  /* Separated Images */\n-    {\n-    total_width = total_length = 0;\n-    for (i = 0; i < crop->selections; i++)\n-      {\n+        /* Checks for matching width or length as required */\n+        if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n+            return (1);\n \n-        cropsize = crop->bufftotal;\n-      crop_buff = seg_buffs[i].buffer; \n-      if (!crop_buff)\n-        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      else\n-        {\n-        prev_cropsize = seg_buffs[0].size;\n-        if (prev_cropsize < cropsize)\n-          {\n-          next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-          if (! next_buff)\n+        if (crop->crop_mode & CROP_INVERT)\n+        {\n+            switch (crop->photometric)\n             {\n-            _TIFFfree (crop_buff);\n-            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                case PHOTOMETRIC_MINISWHITE:\n+                case PHOTOMETRIC_MINISBLACK:\n+                    image->photometric = crop->photometric;\n+                    break;\n+                case INVERT_DATA_ONLY:\n+                case INVERT_DATA_AND_TAG:\n+                    if (invertImage(image->photometric, image->spp, image->bps, \n+                                    crop->combined_width, crop->combined_length, crop_buff))\n+                    {\n+                        TIFFError("processCropSelections", \n+                                  "Failed to invert colorspace for composite regions");\n+                        return (-1);\n+                    }\n+                    if (crop->photometric == INVERT_DATA_AND_TAG)\n+                    {\n+                        switch (image->photometric)\n+                        {\n+                            case PHOTOMETRIC_MINISWHITE:\n+                                image->photometric = PHOTOMETRIC_MINISBLACK;\n+                                break;\n+                            case PHOTOMETRIC_MINISBLACK:\n+                                image->photometric = PHOTOMETRIC_MINISWHITE;\n+                                break;\n+                            default:\n+                                break;\n+                        }\n+                    }\n+                    break;\n+                default: break;\n             }\n-          else\n-            crop_buff = next_buff;\n-          }\n         }\n \n-      if (!crop_buff)\n+        if (crop->crop_mode & CROP_MIRROR)\n         {\n-        TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n-        return (-1);\n+            if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                            crop->combined_width, crop->combined_length, crop_buff))\n+            {\n+                TIFFError("processCropSelections", "Failed to mirror composite regions %s", \n+                         (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                return (-1);\n+            }\n         }\n- \n-      _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n-      seg_buffs[i].buffer = crop_buff;\n-      seg_buffs[i].size = cropsize;\n \n-      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+        if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n         {\n-\tTIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n-        return (-1);\n-        }\n-    \n-      width  = crop->regionlist[i].width;\n-      length = crop->regionlist[i].length;\n-\n-      if (crop->crop_mode & CROP_INVERT)\n-        {\n-        switch (crop->photometric)\n-          {\n-          /* Just change the interpretation */\n-          case PHOTOMETRIC_MINISWHITE:\n-          case PHOTOMETRIC_MINISBLACK:\n-\t       image->photometric = crop->photometric;\n-\t       break;\n-          case INVERT_DATA_ONLY:\n-          case INVERT_DATA_AND_TAG:\n-               if (invertImage(image->photometric, image->spp, image->bps, \n-                               width, length, crop_buff))\n-                 {\n-                 TIFFError("processCropSelections", \n-                           "Failed to invert colorspace for region");\n-                 return (-1);\n-                 }\n-               if (crop->photometric == INVERT_DATA_AND_TAG)\n-                 {\n-                 switch (image->photometric)\n-                   {\n-                   case PHOTOMETRIC_MINISWHITE:\n- \t                image->photometric = PHOTOMETRIC_MINISBLACK;\n-\t                break;\n-                   case PHOTOMETRIC_MINISBLACK:\n- \t                image->photometric = PHOTOMETRIC_MINISWHITE;\n-\t                break;\n-                   default:\n-\t                break;\n-\t           }\n-\t         }\n-               break;\n-          default: break;\n-          }\n+            if (rotateImage(crop->rotation, image, &crop->combined_width, \n+                            &crop->combined_length, &crop_buff))\n+            {\n+                TIFFError("processCropSelections", \n+                          "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);\n+                return (-1);\n+            }\n+            seg_buffs[0].buffer = crop_buff;\n+            seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n+                                  * image->spp) * crop->combined_length; \n         }\n-\n-      if (crop->crop_mode & CROP_MIRROR)\n+    }\n+    else  /* Separated Images */\n+    {\n+        total_width = total_length = 0;\n+        for (i = 0; i < crop->selections; i++)\n         {\n-        if (mirrorImage(image->spp, image->bps, crop->mirror, \n-                        width, length, crop_buff))\n-          {\n-          TIFFError("processCropSelections", "Failed to mirror crop region %s", \n-\t           (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n-          return (-1);\n-          }\n-        }\n+            cropsize = crop->bufftotal;\n+            crop_buff = seg_buffs[i].buffer; \n+            if (!crop_buff)\n+                crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            else\n+            {\n+                prev_cropsize = seg_buffs[i].size;\n+                if (prev_cropsize < cropsize)\n+                {\n+                    next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    if (!next_buff)\n+                    {\n+                        _TIFFfree(crop_buff);\n+                        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+                    }\n+                    else\n+                        crop_buff = next_buff;\n+                }\n+            }\n \n-      if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n-        {\n-          /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it schouldn\'t do here, when more than one section is processed. \n-           * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!\n-           */\n-\tif (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n-\t\t\t&crop->regionlist[i].length, &crop_buff))\n-          {\n-          TIFFError("processCropSelections", \n-                    "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n-          return (-1);\n-          }\n-        total_width  += crop->regionlist[i].width;\n-        total_length += crop->regionlist[i].length;\n-        crop->combined_width = total_width;\n-        crop->combined_length = total_length;\n-        seg_buffs[i].buffer = crop_buff;\n-        seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n-                               * image->spp) * crop->regionlist[i].length; \n-        }\n-      }  /* for crop->selections loop */\n+            if (!crop_buff)\n+            {\n+                TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");\n+                return (-1);\n+            }\n+\n+            _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n+            seg_buffs[i].buffer = crop_buff;\n+            seg_buffs[i].size = cropsize;\n+\n+            if (extractSeparateRegion(image, crop, read_buff, crop_buff, i) != 0)\n+            {\n+                TIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n+                return (-1);\n+            }\n+\n+            width  = crop->regionlist[i].width;\n+            length = crop->regionlist[i].length;\n+\n+            if (crop->crop_mode & CROP_INVERT)\n+            {\n+                switch (crop->photometric)\n+                {\n+                    case PHOTOMETRIC_MINISWHITE:\n+                    case PHOTOMETRIC_MINISBLACK:\n+                        image->photometric = crop->photometric;\n+                        break;\n+                    case INVERT_DATA_ONLY:\n+                    case INVERT_DATA_AND_TAG:\n+                        if (invertImage(image->photometric, image->spp, image->bps, \n+                                        width, length, crop_buff))\n+                        {\n+                            TIFFError("processCropSelections", \n+                                      "Failed to invert colorspace for region");\n+                            return (-1);\n+                        }\n+                        if (crop->photometric == INVERT_DATA_AND_TAG)\n+                        {\n+                            switch (image->photometric)\n+                            {\n+                                case PHOTOMETRIC_MINISWHITE:\n+                                    image->photometric = PHOTOMETRIC_MINISBLACK;\n+                                    break;\n+                                case PHOTOMETRIC_MINISBLACK:\n+                                    image->photometric = PHOTOMETRIC_MINISWHITE;\n+                                    break;\n+                                default:\n+                                    break;\n+                            }\n+                        }\n+                        break;\n+                    default: break;\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_MIRROR)\n+            {\n+                if (mirrorImage(image->spp, image->bps, crop->mirror, \n+                                width, length, crop_buff))\n+                {\n+                    TIFFError("processCropSelections", "Failed to mirror crop region %s", \n+                             (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");\n+                    return (-1);\n+                }\n+            }\n+\n+            if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n+            {\n+                if (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n+                                &crop->regionlist[i].length, &crop_buff))\n+                {\n+                    TIFFError("processCropSelections", \n+                              "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);\n+                    return (-1);\n+                }\n+            total_width  += crop->regionlist[i].width;\n+            total_length += crop->regionlist[i].length;\n+            crop->combined_width = total_width;\n+            crop->combined_length = total_length;\n+            seg_buffs[i].buffer = crop_buff;\n+            seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n+                                  * image->spp) * crop->regionlist[i].length; \n+            }\n+        }  /* for crop->selections loop */\n     }  /* Separated Images (else case) */\n-  return (0);\n-  } /* end processCropSelections */\n+    return (0);\n+} /* end processCropSelections */\n+\n \n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n', 'id': 38, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7830:11'}, {'diff': '@@ -7678,6 +7678,7 @@\n \n \n /* Process selections defined by regions, zones, margins, or fixed sized areas */\n+\n static int\n processCropSelections(struct image_data *image, struct crop_mask *crop, \n                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n@@ -7803,7 +7804,7 @@\n         crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n       else\n         {\n-        prev_cropsize = seg_buffs[0].size;\n+        prev_cropsize = seg_buffs[i].size;\n         if (prev_cropsize < cropsize)\n           {\n           next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n@@ -7827,9 +7828,10 @@\n       seg_buffs[i].buffer = crop_buff;\n       seg_buffs[i].size = cropsize;\n \n-      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n+      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i) != 0)\n         {\n-\tTIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n+        TIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);\n+        _TIFFfree(crop_buff); // Prevent memory leak\n         return (-1);\n         }\n     \n@@ -7856,7 +7858,7 @@\n                  }\n                if (crop->photometric == INVERT_DATA_AND_TAG)\n                  {\n-                 switch (image->photometric)\n+                 switch (image->photographic)\n                    {\n                    case PHOTOMETRIC_MINISWHITE:\n  \t                image->photometric = PHOTOMETRIC_MINISBLACK;\n@@ -7909,6 +7911,7 @@\n   return (0);\n   } /* end processCropSelections */\n \n+\n /* Copy the crop section of the data from the current image into a buffer\n  * and adjust the IFD values to reflect the new size. If no cropping is\n  * required, use the original read buffer as the crop buffer.\n', 'id': 39, 'location': '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop.c:7830:11'}]2025-02-05 20:16:47.520 | INFO     | scenario:validate:475 - beginning candidate patch evaluation with time limit: 45 minutes
2025-02-05 20:16:47.522 | DEBUG    | scenario:rebuild:369 - original environment: environ({'CONDA_SHLVL': '2', 'LC_ALL': 'C.UTF-8', 'LS_COLORS': 'rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:', 'LD_LIBRARY_PATH': '/opt/crashrepair/lib:/CrashRepair/lib:/klee/build/lib:', 'CONDA_EXE': '/root/anaconda3/bin/conda', 'LANG': 'C.UTF-8', 'TZ': 'Asia/Shanghai', 'HOSTNAME': 'fea22102047d', 'OLDPWD': '/orchestrator', 'CONDA_PREFIX': '/root/anaconda3/envs/CrashRepair', '_CE_M': '', 'CC': 'crepair-cc', 'LLVM_COMPILER': 'clang', 'CONDA_PREFIX_1': '/root/anaconda3', 'PWD': '/orchestrator/crashrepair', 'HOME': '/root', 'CONDA_PYTHON_EXE': '/root/anaconda3/bin/python', '_CE_CONDA': '', 'CONDA_PROMPT_MODIFIER': '(CrashRepair) ', 'CXX': 'crepair-cxx', 'TERM': 'xterm', 'SHLVL': '2', 'PYTHONPATH': '/usr/lib/python3.8/site-packages:', 'PATH': '/root/anaconda3/envs/CrashRepair/bin:/root/anaconda3/condabin:~/anaconda3/bin:/opt/crashrepair/bin:/CrashRepair/compiler:/klee/build/bin:/opt/llvm-6/bin:/klee/build/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin', 'CONDA_DEFAULT_ENV': 'CrashRepair', '_': '/root/anaconda3/envs/CrashRepair/bin/python'})
2025-02-05 20:16:47.522 | DEBUG    | scenario:rebuild:382 - injecting ghost function into CFLAGS during build: -lcrepair_ghost
2025-02-05 20:16:47.522 | DEBUG    | scenario:rebuild:398 - using environment: {'INJECT_CFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address', 'INJECT_CXXFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address', 'INJECT_LDFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address'}
2025-02-05 20:16:47.522 | DEBUG    | shell:__call__:41 - executing: make clean
Making clean in port
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/port'
rm -rf .libs _libs
test -z "libport.la" || rm -f libport.la
rm -f ./so_locations
rm -f *.o
rm -f *.lo
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/port'
Making clean in libtiff
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff'
test -z "libtiff.la libtiffxx.la" || rm -f libtiff.la libtiffxx.la
rm -f ./so_locations
rm -rf .libs _libs
 rm -f mkg3states
rm -f *.o
rm -f *.lo
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff'
Making clean in tools
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools'
 rm -f fax2ps fax2tiff pal2rgb ppm2tiff raw2tiff tiff2bw tiff2pdf tiff2ps tiff2rgba tiffcmp tiffcp tiffcrop tiffdither tiffdump tiffinfo tiffmedian tiffset tiffsplit
 rm -f rgb2ycbcr thumbnail
rm -rf .libs _libs
rm -f *.o
rm -f *.lo
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools'
Making clean in build
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/build'
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/build'
rm -rf .libs _libs
rm -f *.lo
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/build'
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/build'
Making clean in contrib
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib'
Making clean in addtiffo
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/addtiffo'
rm -rf .libs _libs
 rm -f addtiffo
rm -f *.o
rm -f *.lo
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/addtiffo'
Making clean in dbs
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs'
Making clean in xtiff
make[3]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs/xtiff'
rm -rf .libs _libs
rm -f *.lo
make[3]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs/xtiff'
make[3]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs'
rm -rf .libs _libs
 rm -f tiff-bi tiff-grayscale tiff-palette tiff-rgb
rm -f *.o
rm -f *.lo
make[3]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs'
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs'
Making clean in iptcutil
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/iptcutil'
rm -rf .libs _libs
 rm -f iptcutil
rm -f *.o
rm -f *.lo
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/iptcutil'
Making clean in mfs
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/mfs'
rm -rf .libs _libs
rm -f *.lo
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/mfs'
Making clean in pds
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/pds'
rm -rf .libs _libs
rm -f *.lo
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/pds'
Making clean in ras
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/ras'
rm -rf .libs _libs
rm -f *.lo
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/ras'
Making clean in stream
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/stream'
rm -rf .libs _libs
rm -f *.lo
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/stream'
Making clean in tags
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/tags'
rm -rf .libs _libs
rm -f *.lo
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/tags'
Making clean in win_dib
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/win_dib'
rm -rf .libs _libs
rm -f *.lo
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/win_dib'
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib'
rm -rf .libs _libs
rm -f *.lo
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib'
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib'
Making clean in test
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/test'
 rm -f ascii_tag long_tag short_tag strip_rw rewrite custom_dir custom_dir_EXIF_231 defer_strile_loading defer_strile_writing test_directory test_open_options testtypes test_signed_tags raw_decode rational_precision2double
test -z "test_packbits.tif o-*" || rm -f test_packbits.tif o-*
rm -rf .libs _libs
rm -f *.o
test -z "ascii_tag.log long_tag.log short_tag.log strip_rw.log rewrite.log custom_dir.log custom_dir_EXIF_231.log defer_strile_loading.log defer_strile_writing.log test_directory.log test_open_options.log testtypes.log test_signed_tags.log raw_decode.log rational_precision2double.log ppm2tiff_pbm.sh.log ppm2tiff_pgm.sh.log ppm2tiff_ppm.sh.log fax2tiff.sh.log tiffcp-g3.sh.log tiffcp-g3-1d.sh.log tiffcp-g3-1d-fill.sh.log tiffcp-g3-2d.sh.log tiffcp-g3-2d-fill.sh.log tiffcp-g4.sh.log tiffcp-logluv.sh.log tiffcp-thumbnail.sh.log tiffcp-lzw-compat.sh.log tiffcp-lzw-scanline-decode.sh.log tiffdump.sh.log tiffinfo.sh.log tiffcp-split.sh.log tiffcp-split-join.sh.log tiff2ps-PS1.sh.log tiff2ps-PS2.sh.log tiff2ps-PS3.sh.log tiff2ps-EPS1.sh.log tiff2pdf.sh.log tiffcrop-doubleflip-logluv-3c-16b.sh.log tiffcrop-doubleflip-minisblack-1c-16b.sh.log tiffcrop-doubleflip-minisblack-1c-8b.sh.log tiffcrop-doubleflip-minisblack-2c-8b-alpha.sh.log tiffcrop-doubleflip-miniswhite-1c-1b.sh.log tiffcrop-doubleflip-palette-1c-1b.sh.log tiffcrop-doubleflip-palette-1c-4b.sh.log tiffcrop-doubleflip-palette-1c-8b.sh.log tiffcrop-doubleflip-rgb-3c-16b.sh.log tiffcrop-doubleflip-rgb-3c-8b.sh.log tiffcrop-extract-logluv-3c-16b.sh.log tiffcrop-extract-minisblack-1c-16b.sh.log tiffcrop-extract-minisblack-1c-8b.sh.log tiffcrop-extract-minisblack-2c-8b-alpha.sh.log tiffcrop-extract-miniswhite-1c-1b.sh.log tiffcrop-extract-palette-1c-1b.sh.log tiffcrop-extract-palette-1c-4b.sh.log tiffcrop-extract-palette-1c-8b.sh.log tiffcrop-extract-rgb-3c-16b.sh.log tiffcrop-extract-rgb-3c-8b.sh.log tiffcrop-extractz14-logluv-3c-16b.sh.log tiffcrop-extractz14-minisblack-1c-16b.sh.log tiffcrop-extractz14-minisblack-1c-8b.sh.log tiffcrop-extractz14-minisblack-2c-8b-alpha.sh.log tiffcrop-extractz14-miniswhite-1c-1b.sh.log tiffcrop-extractz14-palette-1c-1b.sh.log tiffcrop-extractz14-palette-1c-4b.sh.log tiffcrop-extractz14-palette-1c-8b.sh.log tiffcrop-extractz14-rgb-3c-16b.sh.log tiffcrop-extractz14-rgb-3c-8b.sh.log tiffcrop-R90-logluv-3c-16b.sh.log tiffcrop-R90-minisblack-1c-16b.sh.log tiffcrop-R90-minisblack-1c-8b.sh.log tiffcrop-R90-minisblack-2c-8b-alpha.sh.log tiffcrop-R90-miniswhite-1c-1b.sh.log tiffcrop-R90-palette-1c-1b.sh.log tiffcrop-R90-palette-1c-4b.sh.log tiffcrop-R90-palette-1c-8b.sh.log tiffcrop-R90-rgb-3c-16b.sh.log tiffcrop-R90-rgb-3c-8b.sh.log tiff2bw-palette-1c-8b.sh.log tiff2bw-quad-lzw-compat.sh.log tiff2bw-rgb-3c-8b.sh.log tiff2rgba-logluv-3c-16b.sh.log tiff2rgba-minisblack-1c-16b.sh.log tiff2rgba-minisblack-1c-8b.sh.log tiff2rgba-minisblack-2c-8b-alpha.sh.log tiff2rgba-miniswhite-1c-1b.sh.log tiff2rgba-palette-1c-1b.sh.log tiff2rgba-palette-1c-4b.sh.log tiff2rgba-palette-1c-8b.sh.log tiff2rgba-rgb-3c-16b.sh.log tiff2rgba-rgb-3c-8b.sh.log testfax4.sh.log testdeflatelaststripextradata.sh.log tiff2rgba-quad-tile.jpg.sh.log tiff2rgba-ojpeg_zackthecat_subsamp22_single_strip.sh.log tiff2rgba-ojpeg_chewey_subsamp21_multi_strip.sh.log tiff2rgba-ojpeg_single_strip_no_rowsperstrip.sh.log" || rm -f ascii_tag.log long_tag.log short_tag.log strip_rw.log rewrite.log custom_dir.log custom_dir_EXIF_231.log defer_strile_loading.log defer_strile_writing.log test_directory.log test_open_options.log testtypes.log test_signed_tags.log raw_decode.log rational_precision2double.log ppm2tiff_pbm.sh.log ppm2tiff_pgm.sh.log ppm2tiff_ppm.sh.log fax2tiff.sh.log tiffcp-g3.sh.log tiffcp-g3-1d.sh.log tiffcp-g3-1d-fill.sh.log tiffcp-g3-2d.sh.log tiffcp-g3-2d-fill.sh.log tiffcp-g4.sh.log tiffcp-logluv.sh.log tiffcp-thumbnail.sh.log tiffcp-lzw-compat.sh.log tiffcp-lzw-scanline-decode.sh.log tiffdump.sh.log tiffinfo.sh.log tiffcp-split.sh.log tiffcp-split-join.sh.log tiff2ps-PS1.sh.log tiff2ps-PS2.sh.log tiff2ps-PS3.sh.log tiff2ps-EPS1.sh.log tiff2pdf.sh.log tiffcrop-doubleflip-logluv-3c-16b.sh.log tiffcrop-doubleflip-minisblack-1c-16b.sh.log tiffcrop-doubleflip-minisblack-1c-8b.sh.log tiffcrop-doubleflip-minisblack-2c-8b-alpha.sh.log tiffcrop-doubleflip-miniswhite-1c-1b.sh.log tiffcrop-doubleflip-palette-1c-1b.sh.log tiffcrop-doubleflip-palette-1c-4b.sh.log tiffcrop-doubleflip-palette-1c-8b.sh.log tiffcrop-doubleflip-rgb-3c-16b.sh.log tiffcrop-doubleflip-rgb-3c-8b.sh.log tiffcrop-extract-logluv-3c-16b.sh.log tiffcrop-extract-minisblack-1c-16b.sh.log tiffcrop-extract-minisblack-1c-8b.sh.log tiffcrop-extract-minisblack-2c-8b-alpha.sh.log tiffcrop-extract-miniswhite-1c-1b.sh.log tiffcrop-extract-palette-1c-1b.sh.log tiffcrop-extract-palette-1c-4b.sh.log tiffcrop-extract-palette-1c-8b.sh.log tiffcrop-extract-rgb-3c-16b.sh.log tiffcrop-extract-rgb-3c-8b.sh.log tiffcrop-extractz14-logluv-3c-16b.sh.log tiffcrop-extractz14-minisblack-1c-16b.sh.log tiffcrop-extractz14-minisblack-1c-8b.sh.log tiffcrop-extractz14-minisblack-2c-8b-alpha.sh.log tiffcrop-extractz14-miniswhite-1c-1b.sh.log tiffcrop-extractz14-palette-1c-1b.sh.log tiffcrop-extractz14-palette-1c-4b.sh.log tiffcrop-extractz14-palette-1c-8b.sh.log tiffcrop-extractz14-rgb-3c-16b.sh.log tiffcrop-extractz14-rgb-3c-8b.sh.log tiffcrop-R90-logluv-3c-16b.sh.log tiffcrop-R90-minisblack-1c-16b.sh.log tiffcrop-R90-minisblack-1c-8b.sh.log tiffcrop-R90-minisblack-2c-8b-alpha.sh.log tiffcrop-R90-miniswhite-1c-1b.sh.log tiffcrop-R90-palette-1c-1b.sh.log tiffcrop-R90-palette-1c-4b.sh.log tiffcrop-R90-palette-1c-8b.sh.log tiffcrop-R90-rgb-3c-16b.sh.log tiffcrop-R90-rgb-3c-8b.sh.log tiff2bw-palette-1c-8b.sh.log tiff2bw-quad-lzw-compat.sh.log tiff2bw-rgb-3c-8b.sh.log tiff2rgba-logluv-3c-16b.sh.log tiff2rgba-minisblack-1c-16b.sh.log tiff2rgba-minisblack-1c-8b.sh.log tiff2rgba-minisblack-2c-8b-alpha.sh.log tiff2rgba-miniswhite-1c-1b.sh.log tiff2rgba-palette-1c-1b.sh.log tiff2rgba-palette-1c-4b.sh.log tiff2rgba-palette-1c-8b.sh.log tiff2rgba-rgb-3c-16b.sh.log tiff2rgba-rgb-3c-8b.sh.log testfax4.sh.log testdeflatelaststripextradata.sh.log tiff2rgba-quad-tile.jpg.sh.log tiff2rgba-ojpeg_zackthecat_subsamp22_single_strip.sh.log tiff2rgba-ojpeg_chewey_subsamp21_multi_strip.sh.log tiff2rgba-ojpeg_single_strip_no_rowsperstrip.sh.log
test -z "ascii_tag.trs long_tag.trs short_tag.trs strip_rw.trs rewrite.trs custom_dir.trs custom_dir_EXIF_231.trs defer_strile_loading.trs defer_strile_writing.trs test_directory.trs test_open_options.trs testtypes.trs test_signed_tags.trs raw_decode.trs rational_precision2double.trs ppm2tiff_pbm.sh.trs ppm2tiff_pgm.sh.trs ppm2tiff_ppm.sh.trs fax2tiff.sh.trs tiffcp-g3.sh.trs tiffcp-g3-1d.sh.trs tiffcp-g3-1d-fill.sh.trs tiffcp-g3-2d.sh.trs tiffcp-g3-2d-fill.sh.trs tiffcp-g4.sh.trs tiffcp-logluv.sh.trs tiffcp-thumbnail.sh.trs tiffcp-lzw-compat.sh.trs tiffcp-lzw-scanline-decode.sh.trs tiffdump.sh.trs tiffinfo.sh.trs tiffcp-split.sh.trs tiffcp-split-join.sh.trs tiff2ps-PS1.sh.trs tiff2ps-PS2.sh.trs tiff2ps-PS3.sh.trs tiff2ps-EPS1.sh.trs tiff2pdf.sh.trs tiffcrop-doubleflip-logluv-3c-16b.sh.trs tiffcrop-doubleflip-minisblack-1c-16b.sh.trs tiffcrop-doubleflip-minisblack-1c-8b.sh.trs tiffcrop-doubleflip-minisblack-2c-8b-alpha.sh.trs tiffcrop-doubleflip-miniswhite-1c-1b.sh.trs tiffcrop-doubleflip-palette-1c-1b.sh.trs tiffcrop-doubleflip-palette-1c-4b.sh.trs tiffcrop-doubleflip-palette-1c-8b.sh.trs tiffcrop-doubleflip-rgb-3c-16b.sh.trs tiffcrop-doubleflip-rgb-3c-8b.sh.trs tiffcrop-extract-logluv-3c-16b.sh.trs tiffcrop-extract-minisblack-1c-16b.sh.trs tiffcrop-extract-minisblack-1c-8b.sh.trs tiffcrop-extract-minisblack-2c-8b-alpha.sh.trs tiffcrop-extract-miniswhite-1c-1b.sh.trs tiffcrop-extract-palette-1c-1b.sh.trs tiffcrop-extract-palette-1c-4b.sh.trs tiffcrop-extract-palette-1c-8b.sh.trs tiffcrop-extract-rgb-3c-16b.sh.trs tiffcrop-extract-rgb-3c-8b.sh.trs tiffcrop-extractz14-logluv-3c-16b.sh.trs tiffcrop-extractz14-minisblack-1c-16b.sh.trs tiffcrop-extractz14-minisblack-1c-8b.sh.trs tiffcrop-extractz14-minisblack-2c-8b-alpha.sh.trs tiffcrop-extractz14-miniswhite-1c-1b.sh.trs tiffcrop-extractz14-palette-1c-1b.sh.trs tiffcrop-extractz14-palette-1c-4b.sh.trs tiffcrop-extractz14-palette-1c-8b.sh.trs tiffcrop-extractz14-rgb-3c-16b.sh.trs tiffcrop-extractz14-rgb-3c-8b.sh.trs tiffcrop-R90-logluv-3c-16b.sh.trs tiffcrop-R90-minisblack-1c-16b.sh.trs tiffcrop-R90-minisblack-1c-8b.sh.trs tiffcrop-R90-minisblack-2c-8b-alpha.sh.trs tiffcrop-R90-miniswhite-1c-1b.sh.trs tiffcrop-R90-palette-1c-1b.sh.trs tiffcrop-R90-palette-1c-4b.sh.trs tiffcrop-R90-palette-1c-8b.sh.trs tiffcrop-R90-rgb-3c-16b.sh.trs tiffcrop-R90-rgb-3c-8b.sh.trs tiff2bw-palette-1c-8b.sh.trs tiff2bw-quad-lzw-compat.sh.trs tiff2bw-rgb-3c-8b.sh.trs tiff2rgba-logluv-3c-16b.sh.trs tiff2rgba-minisblack-1c-16b.sh.trs tiff2rgba-minisblack-1c-8b.sh.trs tiff2rgba-minisblack-2c-8b-alpha.sh.trs tiff2rgba-miniswhite-1c-1b.sh.trs tiff2rgba-palette-1c-1b.sh.trs tiff2rgba-palette-1c-4b.sh.trs tiff2rgba-palette-1c-8b.sh.trs tiff2rgba-rgb-3c-16b.sh.trs tiff2rgba-rgb-3c-8b.sh.trs testfax4.sh.trs testdeflatelaststripextradata.sh.trs tiff2rgba-quad-tile.jpg.sh.trs tiff2rgba-ojpeg_zackthecat_subsamp22_single_strip.sh.trs tiff2rgba-ojpeg_chewey_subsamp21_multi_strip.sh.trs tiff2rgba-ojpeg_single_strip_no_rowsperstrip.sh.trs" || rm -f ascii_tag.trs long_tag.trs short_tag.trs strip_rw.trs rewrite.trs custom_dir.trs custom_dir_EXIF_231.trs defer_strile_loading.trs defer_strile_writing.trs test_directory.trs test_open_options.trs testtypes.trs test_signed_tags.trs raw_decode.trs rational_precision2double.trs ppm2tiff_pbm.sh.trs ppm2tiff_pgm.sh.trs ppm2tiff_ppm.sh.trs fax2tiff.sh.trs tiffcp-g3.sh.trs tiffcp-g3-1d.sh.trs tiffcp-g3-1d-fill.sh.trs tiffcp-g3-2d.sh.trs tiffcp-g3-2d-fill.sh.trs tiffcp-g4.sh.trs tiffcp-logluv.sh.trs tiffcp-thumbnail.sh.trs tiffcp-lzw-compat.sh.trs tiffcp-lzw-scanline-decode.sh.trs tiffdump.sh.trs tiffinfo.sh.trs tiffcp-split.sh.trs tiffcp-split-join.sh.trs tiff2ps-PS1.sh.trs tiff2ps-PS2.sh.trs tiff2ps-PS3.sh.trs tiff2ps-EPS1.sh.trs tiff2pdf.sh.trs tiffcrop-doubleflip-logluv-3c-16b.sh.trs tiffcrop-doubleflip-minisblack-1c-16b.sh.trs tiffcrop-doubleflip-minisblack-1c-8b.sh.trs tiffcrop-doubleflip-minisblack-2c-8b-alpha.sh.trs tiffcrop-doubleflip-miniswhite-1c-1b.sh.trs tiffcrop-doubleflip-palette-1c-1b.sh.trs tiffcrop-doubleflip-palette-1c-4b.sh.trs tiffcrop-doubleflip-palette-1c-8b.sh.trs tiffcrop-doubleflip-rgb-3c-16b.sh.trs tiffcrop-doubleflip-rgb-3c-8b.sh.trs tiffcrop-extract-logluv-3c-16b.sh.trs tiffcrop-extract-minisblack-1c-16b.sh.trs tiffcrop-extract-minisblack-1c-8b.sh.trs tiffcrop-extract-minisblack-2c-8b-alpha.sh.trs tiffcrop-extract-miniswhite-1c-1b.sh.trs tiffcrop-extract-palette-1c-1b.sh.trs tiffcrop-extract-palette-1c-4b.sh.trs tiffcrop-extract-palette-1c-8b.sh.trs tiffcrop-extract-rgb-3c-16b.sh.trs tiffcrop-extract-rgb-3c-8b.sh.trs tiffcrop-extractz14-logluv-3c-16b.sh.trs tiffcrop-extractz14-minisblack-1c-16b.sh.trs tiffcrop-extractz14-minisblack-1c-8b.sh.trs tiffcrop-extractz14-minisblack-2c-8b-alpha.sh.trs tiffcrop-extractz14-miniswhite-1c-1b.sh.trs tiffcrop-extractz14-palette-1c-1b.sh.trs tiffcrop-extractz14-palette-1c-4b.sh.trs tiffcrop-extractz14-palette-1c-8b.sh.trs tiffcrop-extractz14-rgb-3c-16b.sh.trs tiffcrop-extractz14-rgb-3c-8b.sh.trs tiffcrop-R90-logluv-3c-16b.sh.trs tiffcrop-R90-minisblack-1c-16b.sh.trs tiffcrop-R90-minisblack-1c-8b.sh.trs tiffcrop-R90-minisblack-2c-8b-alpha.sh.trs tiffcrop-R90-miniswhite-1c-1b.sh.trs tiffcrop-R90-palette-1c-1b.sh.trs tiffcrop-R90-palette-1c-4b.sh.trs tiffcrop-R90-palette-1c-8b.sh.trs tiffcrop-R90-rgb-3c-16b.sh.trs tiffcrop-R90-rgb-3c-8b.sh.trs tiff2bw-palette-1c-8b.sh.trs tiff2bw-quad-lzw-compat.sh.trs tiff2bw-rgb-3c-8b.sh.trs tiff2rgba-logluv-3c-16b.sh.trs tiff2rgba-minisblack-1c-16b.sh.trs tiff2rgba-minisblack-1c-8b.sh.trs tiff2rgba-minisblack-2c-8b-alpha.sh.trs tiff2rgba-miniswhite-1c-1b.sh.trs tiff2rgba-palette-1c-1b.sh.trs tiff2rgba-palette-1c-4b.sh.trs tiff2rgba-palette-1c-8b.sh.trs tiff2rgba-rgb-3c-16b.sh.trs tiff2rgba-rgb-3c-8b.sh.trs testfax4.sh.trs testdeflatelaststripextradata.sh.trs tiff2rgba-quad-tile.jpg.sh.trs tiff2rgba-ojpeg_zackthecat_subsamp22_single_strip.sh.trs tiff2rgba-ojpeg_chewey_subsamp21_multi_strip.sh.trs tiff2rgba-ojpeg_single_strip_no_rowsperstrip.sh.trs
test -z "test-suite.log" || rm -f test-suite.log
rm -f *.lo
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/test'
Making clean in doc
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/doc'
rm -rf .libs _libs
rm -f *.lo
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/doc'
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src'
rm -rf .libs _libs
rm -f *.lo
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src'
2025-02-05 20:16:47.665 | DEBUG    | shell:__call__:41 - executing: make CFLAGS="${INJECT_CFLAGS}" CXXFLAGS="${INJECT_CXXFLAGS}" LDFLAGS="${INJECT_LDFLAGS}"
Making all in port
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/port'
make  all-am
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/port'
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../libtiff   -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT dummy.lo -MD -MP -MF .deps/dummy.Tpo -c -o dummy.lo dummy.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../libtiff -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT dummy.lo -MD -MP -MF .deps/dummy.Tpo -c dummy.c -o dummy.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/dummy.Tpo .deps/dummy.Plo
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o libport.la  dummy.lo  -llzma -ljbig -ljpeg -lz -lm 
libtool: link: ar cru .libs/libport.a  dummy.o
ar: `u' modifier ignored since `D' is the default (see `U')
libtool: link: ranlib .libs/libport.a
libtool: link: ( cd ".libs" && rm -f "libport.la" && ln -s "../libport.la" "libport.la" )
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/port'
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/port'
Making all in libtiff
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff'
make  all-am
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff'
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_aux.lo -MD -MP -MF .deps/tif_aux.Tpo -c -o tif_aux.lo tif_aux.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_aux.lo -MD -MP -MF .deps/tif_aux.Tpo -c tif_aux.c -o tif_aux.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_aux.Tpo .deps/tif_aux.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_close.lo -MD -MP -MF .deps/tif_close.Tpo -c -o tif_close.lo tif_close.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_close.lo -MD -MP -MF .deps/tif_close.Tpo -c tif_close.c -o tif_close.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_close.Tpo .deps/tif_close.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_codec.lo -MD -MP -MF .deps/tif_codec.Tpo -c -o tif_codec.lo tif_codec.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_codec.lo -MD -MP -MF .deps/tif_codec.Tpo -c tif_codec.c -o tif_codec.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_codec.Tpo .deps/tif_codec.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_color.lo -MD -MP -MF .deps/tif_color.Tpo -c -o tif_color.lo tif_color.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_color.lo -MD -MP -MF .deps/tif_color.Tpo -c tif_color.c -o tif_color.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_color.Tpo .deps/tif_color.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_compress.lo -MD -MP -MF .deps/tif_compress.Tpo -c -o tif_compress.lo tif_compress.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_compress.lo -MD -MP -MF .deps/tif_compress.Tpo -c tif_compress.c -o tif_compress.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_compress.Tpo .deps/tif_compress.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_dir.lo -MD -MP -MF .deps/tif_dir.Tpo -c -o tif_dir.lo tif_dir.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_dir.lo -MD -MP -MF .deps/tif_dir.Tpo -c tif_dir.c -o tif_dir.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_dir.Tpo .deps/tif_dir.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_dirinfo.lo -MD -MP -MF .deps/tif_dirinfo.Tpo -c -o tif_dirinfo.lo tif_dirinfo.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_dirinfo.lo -MD -MP -MF .deps/tif_dirinfo.Tpo -c tif_dirinfo.c -o tif_dirinfo.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_dirinfo.Tpo .deps/tif_dirinfo.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_dirread.lo -MD -MP -MF .deps/tif_dirread.Tpo -c -o tif_dirread.lo tif_dirread.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_dirread.lo -MD -MP -MF .deps/tif_dirread.Tpo -c tif_dirread.c -o tif_dirread.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_dirread.Tpo .deps/tif_dirread.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_dirwrite.lo -MD -MP -MF .deps/tif_dirwrite.Tpo -c -o tif_dirwrite.lo tif_dirwrite.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_dirwrite.lo -MD -MP -MF .deps/tif_dirwrite.Tpo -c tif_dirwrite.c -o tif_dirwrite.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_dirwrite.Tpo .deps/tif_dirwrite.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_dumpmode.lo -MD -MP -MF .deps/tif_dumpmode.Tpo -c -o tif_dumpmode.lo tif_dumpmode.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_dumpmode.lo -MD -MP -MF .deps/tif_dumpmode.Tpo -c tif_dumpmode.c -o tif_dumpmode.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_dumpmode.Tpo .deps/tif_dumpmode.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_error.lo -MD -MP -MF .deps/tif_error.Tpo -c -o tif_error.lo tif_error.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_error.lo -MD -MP -MF .deps/tif_error.Tpo -c tif_error.c -o tif_error.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_error.Tpo .deps/tif_error.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_extension.lo -MD -MP -MF .deps/tif_extension.Tpo -c -o tif_extension.lo tif_extension.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_extension.lo -MD -MP -MF .deps/tif_extension.Tpo -c tif_extension.c -o tif_extension.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_extension.Tpo .deps/tif_extension.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_fax3.lo -MD -MP -MF .deps/tif_fax3.Tpo -c -o tif_fax3.lo tif_fax3.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_fax3.lo -MD -MP -MF .deps/tif_fax3.Tpo -c tif_fax3.c -o tif_fax3.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_fax3.Tpo .deps/tif_fax3.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_fax3sm.lo -MD -MP -MF .deps/tif_fax3sm.Tpo -c -o tif_fax3sm.lo tif_fax3sm.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_fax3sm.lo -MD -MP -MF .deps/tif_fax3sm.Tpo -c tif_fax3sm.c -o tif_fax3sm.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_fax3sm.Tpo .deps/tif_fax3sm.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_flush.lo -MD -MP -MF .deps/tif_flush.Tpo -c -o tif_flush.lo tif_flush.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_flush.lo -MD -MP -MF .deps/tif_flush.Tpo -c tif_flush.c -o tif_flush.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_flush.Tpo .deps/tif_flush.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_getimage.lo -MD -MP -MF .deps/tif_getimage.Tpo -c -o tif_getimage.lo tif_getimage.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_getimage.lo -MD -MP -MF .deps/tif_getimage.Tpo -c tif_getimage.c -o tif_getimage.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_getimage.Tpo .deps/tif_getimage.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_jbig.lo -MD -MP -MF .deps/tif_jbig.Tpo -c -o tif_jbig.lo tif_jbig.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_jbig.lo -MD -MP -MF .deps/tif_jbig.Tpo -c tif_jbig.c -o tif_jbig.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_jbig.Tpo .deps/tif_jbig.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_jpeg.lo -MD -MP -MF .deps/tif_jpeg.Tpo -c -o tif_jpeg.lo tif_jpeg.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_jpeg.lo -MD -MP -MF .deps/tif_jpeg.Tpo -c tif_jpeg.c -o tif_jpeg.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_jpeg.Tpo .deps/tif_jpeg.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_jpeg_12.lo -MD -MP -MF .deps/tif_jpeg_12.Tpo -c -o tif_jpeg_12.lo tif_jpeg_12.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_jpeg_12.lo -MD -MP -MF .deps/tif_jpeg_12.Tpo -c tif_jpeg_12.c -o tif_jpeg_12.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_jpeg_12.Tpo .deps/tif_jpeg_12.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_lerc.lo -MD -MP -MF .deps/tif_lerc.Tpo -c -o tif_lerc.lo tif_lerc.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_lerc.lo -MD -MP -MF .deps/tif_lerc.Tpo -c tif_lerc.c -o tif_lerc.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_lerc.Tpo .deps/tif_lerc.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_luv.lo -MD -MP -MF .deps/tif_luv.Tpo -c -o tif_luv.lo tif_luv.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_luv.lo -MD -MP -MF .deps/tif_luv.Tpo -c tif_luv.c -o tif_luv.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_luv.Tpo .deps/tif_luv.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_lzma.lo -MD -MP -MF .deps/tif_lzma.Tpo -c -o tif_lzma.lo tif_lzma.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_lzma.lo -MD -MP -MF .deps/tif_lzma.Tpo -c tif_lzma.c -o tif_lzma.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_lzma.Tpo .deps/tif_lzma.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_lzw.lo -MD -MP -MF .deps/tif_lzw.Tpo -c -o tif_lzw.lo tif_lzw.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_lzw.lo -MD -MP -MF .deps/tif_lzw.Tpo -c tif_lzw.c -o tif_lzw.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_lzw.Tpo .deps/tif_lzw.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_next.lo -MD -MP -MF .deps/tif_next.Tpo -c -o tif_next.lo tif_next.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_next.lo -MD -MP -MF .deps/tif_next.Tpo -c tif_next.c -o tif_next.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_next.Tpo .deps/tif_next.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_ojpeg.lo -MD -MP -MF .deps/tif_ojpeg.Tpo -c -o tif_ojpeg.lo tif_ojpeg.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_ojpeg.lo -MD -MP -MF .deps/tif_ojpeg.Tpo -c tif_ojpeg.c -o tif_ojpeg.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_ojpeg.Tpo .deps/tif_ojpeg.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_open.lo -MD -MP -MF .deps/tif_open.Tpo -c -o tif_open.lo tif_open.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_open.lo -MD -MP -MF .deps/tif_open.Tpo -c tif_open.c -o tif_open.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_open.Tpo .deps/tif_open.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_packbits.lo -MD -MP -MF .deps/tif_packbits.Tpo -c -o tif_packbits.lo tif_packbits.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_packbits.lo -MD -MP -MF .deps/tif_packbits.Tpo -c tif_packbits.c -o tif_packbits.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_packbits.Tpo .deps/tif_packbits.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_pixarlog.lo -MD -MP -MF .deps/tif_pixarlog.Tpo -c -o tif_pixarlog.lo tif_pixarlog.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_pixarlog.lo -MD -MP -MF .deps/tif_pixarlog.Tpo -c tif_pixarlog.c -o tif_pixarlog.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_pixarlog.Tpo .deps/tif_pixarlog.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_predict.lo -MD -MP -MF .deps/tif_predict.Tpo -c -o tif_predict.lo tif_predict.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_predict.lo -MD -MP -MF .deps/tif_predict.Tpo -c tif_predict.c -o tif_predict.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_predict.Tpo .deps/tif_predict.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_print.lo -MD -MP -MF .deps/tif_print.Tpo -c -o tif_print.lo tif_print.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_print.lo -MD -MP -MF .deps/tif_print.Tpo -c tif_print.c -o tif_print.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_print.Tpo .deps/tif_print.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_read.lo -MD -MP -MF .deps/tif_read.Tpo -c -o tif_read.lo tif_read.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_read.lo -MD -MP -MF .deps/tif_read.Tpo -c tif_read.c -o tif_read.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_read.Tpo .deps/tif_read.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_strip.lo -MD -MP -MF .deps/tif_strip.Tpo -c -o tif_strip.lo tif_strip.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_strip.lo -MD -MP -MF .deps/tif_strip.Tpo -c tif_strip.c -o tif_strip.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_strip.Tpo .deps/tif_strip.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_swab.lo -MD -MP -MF .deps/tif_swab.Tpo -c -o tif_swab.lo tif_swab.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_swab.lo -MD -MP -MF .deps/tif_swab.Tpo -c tif_swab.c -o tif_swab.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_swab.Tpo .deps/tif_swab.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_thunder.lo -MD -MP -MF .deps/tif_thunder.Tpo -c -o tif_thunder.lo tif_thunder.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_thunder.lo -MD -MP -MF .deps/tif_thunder.Tpo -c tif_thunder.c -o tif_thunder.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_thunder.Tpo .deps/tif_thunder.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_tile.lo -MD -MP -MF .deps/tif_tile.Tpo -c -o tif_tile.lo tif_tile.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_tile.lo -MD -MP -MF .deps/tif_tile.Tpo -c tif_tile.c -o tif_tile.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_tile.Tpo .deps/tif_tile.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_version.lo -MD -MP -MF .deps/tif_version.Tpo -c -o tif_version.lo tif_version.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_version.lo -MD -MP -MF .deps/tif_version.Tpo -c tif_version.c -o tif_version.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_version.Tpo .deps/tif_version.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_warning.lo -MD -MP -MF .deps/tif_warning.Tpo -c -o tif_warning.lo tif_warning.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_warning.lo -MD -MP -MF .deps/tif_warning.Tpo -c tif_warning.c -o tif_warning.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_warning.Tpo .deps/tif_warning.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_webp.lo -MD -MP -MF .deps/tif_webp.Tpo -c -o tif_webp.lo tif_webp.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_webp.lo -MD -MP -MF .deps/tif_webp.Tpo -c tif_webp.c -o tif_webp.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_webp.Tpo .deps/tif_webp.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_write.lo -MD -MP -MF .deps/tif_write.Tpo -c -o tif_write.lo tif_write.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_write.lo -MD -MP -MF .deps/tif_write.Tpo -c tif_write.c -o tif_write.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_write.Tpo .deps/tif_write.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_zip.lo -MD -MP -MF .deps/tif_zip.Tpo -c -o tif_zip.lo tif_zip.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_zip.lo -MD -MP -MF .deps/tif_zip.Tpo -c tif_zip.c -o tif_zip.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_zip.Tpo .deps/tif_zip.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_zstd.lo -MD -MP -MF .deps/tif_zstd.Tpo -c -o tif_zstd.lo tif_zstd.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_zstd.lo -MD -MP -MF .deps/tif_zstd.Tpo -c tif_zstd.c -o tif_zstd.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_zstd.Tpo .deps/tif_zstd.Plo
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_unix.lo -MD -MP -MF .deps/tif_unix.Tpo -c -o tif_unix.lo tif_unix.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_unix.lo -MD -MP -MF .deps/tif_unix.Tpo -c tif_unix.c -o tif_unix.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_unix.Tpo .deps/tif_unix.Plo
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -no-undefined -version-info 6:0:0  -Wl,--version-script=./libtiff.map -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o libtiff.la -rpath /usr/local/lib tif_aux.lo tif_close.lo tif_codec.lo tif_color.lo tif_compress.lo tif_dir.lo tif_dirinfo.lo tif_dirread.lo tif_dirwrite.lo tif_dumpmode.lo tif_error.lo tif_extension.lo tif_fax3.lo tif_fax3sm.lo tif_flush.lo tif_getimage.lo tif_jbig.lo tif_jpeg.lo tif_jpeg_12.lo tif_lerc.lo tif_luv.lo tif_lzma.lo tif_lzw.lo tif_next.lo tif_ojpeg.lo tif_open.lo tif_packbits.lo tif_pixarlog.lo tif_predict.lo tif_print.lo tif_read.lo tif_strip.lo tif_swab.lo tif_thunder.lo tif_tile.lo tif_version.lo tif_warning.lo tif_webp.lo tif_write.lo tif_zip.lo tif_zstd.lo  tif_unix.lo  -llzma -ljbig -ljpeg -lz -lm 
libtool: link: ar cru .libs/libtiff.a  tif_aux.o tif_close.o tif_codec.o tif_color.o tif_compress.o tif_dir.o tif_dirinfo.o tif_dirread.o tif_dirwrite.o tif_dumpmode.o tif_error.o tif_extension.o tif_fax3.o tif_fax3sm.o tif_flush.o tif_getimage.o tif_jbig.o tif_jpeg.o tif_jpeg_12.o tif_lerc.o tif_luv.o tif_lzma.o tif_lzw.o tif_next.o tif_ojpeg.o tif_open.o tif_packbits.o tif_pixarlog.o tif_predict.o tif_print.o tif_read.o tif_strip.o tif_swab.o tif_thunder.o tif_tile.o tif_version.o tif_warning.o tif_webp.o tif_write.o tif_zip.o tif_zstd.o tif_unix.o
ar: `u' modifier ignored since `D' is the default (see `U')
libtool: link: ranlib .libs/libtiff.a
libtool: link: ( cd ".libs" && rm -f "libtiff.la" && ln -s "../libtiff.la" "libtiff.la" )
/bin/bash ../libtool  --tag=CXX   --mode=compile crepair-cxx -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_stream.lo -MD -MP -MF .deps/tif_stream.Tpo -c -o tif_stream.lo tif_stream.cxx
libtool: compile:  crepair-cxx -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_stream.lo -MD -MP -MF .deps/tif_stream.Tpo -c tif_stream.cxx -o tif_stream.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_stream.Tpo .deps/tif_stream.Plo
/bin/bash ../libtool  --tag=CXX   --mode=link crepair-cxx  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -no-undefined -version-info 6:0:0  -Wl,--version-script=./libtiffxx.map -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o libtiffxx.la -rpath /usr/local/lib tif_stream.lo ../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: ar cru .libs/libtiffxx.a  tif_stream.o
ar: `u' modifier ignored since `D' is the default (see `U')
libtool: link: ranlib .libs/libtiffxx.a
libtool: link: ( cd ".libs" && rm -f "libtiffxx.la" && ln -s "../libtiffxx.la" "libtiffxx.la" )
crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT mkg3states.o -MD -MP -MF .deps/mkg3states.Tpo -c -o mkg3states.o mkg3states.c
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/mkg3states.Tpo .deps/mkg3states.Po
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o mkg3states mkg3states.o ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o mkg3states mkg3states.o  -L/klee/build/lib -L/CrashRepair/lib ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff'
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff'
Making all in tools
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools'
crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../libtiff -I../port  -I../libtiff -I../port -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT fax2ps.o -MD -MP -MF .deps/fax2ps.Tpo -c -o fax2ps.o fax2ps.c
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/fax2ps.Tpo .deps/fax2ps.Po
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o fax2ps fax2ps.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o fax2ps fax2ps.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../libtiff -I../port  -I../libtiff -I../port -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT fax2tiff.o -MD -MP -MF .deps/fax2tiff.Tpo -c -o fax2tiff.o fax2tiff.c
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/fax2tiff.Tpo .deps/fax2tiff.Po
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o fax2tiff fax2tiff.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o fax2tiff fax2tiff.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../libtiff -I../port  -I../libtiff -I../port -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT pal2rgb.o -MD -MP -MF .deps/pal2rgb.Tpo -c -o pal2rgb.o pal2rgb.c
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/pal2rgb.Tpo .deps/pal2rgb.Po
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o pal2rgb pal2rgb.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o pal2rgb pal2rgb.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../libtiff -I../port  -I../libtiff -I../port -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT ppm2tiff.o -MD -MP -MF .deps/ppm2tiff.Tpo -c -o ppm2tiff.o ppm2tiff.c
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/ppm2tiff.Tpo .deps/ppm2tiff.Po
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o ppm2tiff ppm2tiff.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o ppm2tiff ppm2tiff.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../libtiff -I../port  -I../libtiff -I../port -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT raw2tiff.o -MD -MP -MF .deps/raw2tiff.Tpo -c -o raw2tiff.o raw2tiff.c
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/raw2tiff.Tpo .deps/raw2tiff.Po
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o raw2tiff raw2tiff.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o raw2tiff raw2tiff.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../libtiff -I../port  -I../libtiff -I../port -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tiff2bw.o -MD -MP -MF .deps/tiff2bw.Tpo -c -o tiff2bw.o tiff2bw.c
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tiff2bw.Tpo .deps/tiff2bw.Po
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff2bw tiff2bw.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff2bw tiff2bw.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../libtiff -I../port  -I../libtiff -I../port -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tiff2pdf.o -MD -MP -MF .deps/tiff2pdf.Tpo -c -o tiff2pdf.o tiff2pdf.c
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tiff2pdf.Tpo .deps/tiff2pdf.Po
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff2pdf tiff2pdf.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff2pdf tiff2pdf.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../libtiff -I../port  -I../libtiff -I../port -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tiff2ps.o -MD -MP -MF .deps/tiff2ps.Tpo -c -o tiff2ps.o tiff2ps.c
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tiff2ps.Tpo .deps/tiff2ps.Po
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff2ps tiff2ps.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff2ps tiff2ps.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../libtiff -I../port  -I../libtiff -I../port -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tiff2rgba.o -MD -MP -MF .deps/tiff2rgba.Tpo -c -o tiff2rgba.o tiff2rgba.c
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tiff2rgba.Tpo .deps/tiff2rgba.Po
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff2rgba tiff2rgba.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff2rgba tiff2rgba.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../libtiff -I../port  -I../libtiff -I../port -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tiffcmp.o -MD -MP -MF .deps/tiffcmp.Tpo -c -o tiffcmp.o tiffcmp.c
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tiffcmp.Tpo .deps/tiffcmp.Po
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffcmp tiffcmp.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffcmp tiffcmp.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../libtiff -I../port  -I../libtiff -I../port -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tiffcp.o -MD -MP -MF .deps/tiffcp.Tpo -c -o tiffcp.o tiffcp.c
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tiffcp.Tpo .deps/tiffcp.Po
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffcp tiffcp.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffcp tiffcp.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../libtiff -I../port  -I../libtiff -I../port -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tiffcrop.o -MD -MP -MF .deps/tiffcrop.Tpo -c -o tiffcrop.o tiffcrop.c
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tiffcrop.Tpo .deps/tiffcrop.Po
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffcrop tiffcrop.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffcrop tiffcrop.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../libtiff -I../port  -I../libtiff -I../port -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tiffdither.o -MD -MP -MF .deps/tiffdither.Tpo -c -o tiffdither.o tiffdither.c
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tiffdither.Tpo .deps/tiffdither.Po
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffdither tiffdither.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffdither tiffdither.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../libtiff -I../port  -I../libtiff -I../port -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tiffdump.o -MD -MP -MF .deps/tiffdump.Tpo -c -o tiffdump.o tiffdump.c
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tiffdump.Tpo .deps/tiffdump.Po
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffdump tiffdump.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffdump tiffdump.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../libtiff -I../port  -I../libtiff -I../port -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tiffinfo.o -MD -MP -MF .deps/tiffinfo.Tpo -c -o tiffinfo.o tiffinfo.c
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tiffinfo.Tpo .deps/tiffinfo.Po
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffinfo tiffinfo.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffinfo tiffinfo.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../libtiff -I../port  -I../libtiff -I../port -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tiffmedian.o -MD -MP -MF .deps/tiffmedian.Tpo -c -o tiffmedian.o tiffmedian.c
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tiffmedian.Tpo .deps/tiffmedian.Po
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffmedian tiffmedian.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffmedian tiffmedian.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../libtiff -I../port  -I../libtiff -I../port -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tiffset.o -MD -MP -MF .deps/tiffset.Tpo -c -o tiffset.o tiffset.c
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tiffset.Tpo .deps/tiffset.Po
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffset tiffset.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffset tiffset.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../libtiff -I../port  -I../libtiff -I../port -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tiffsplit.o -MD -MP -MF .deps/tiffsplit.Tpo -c -o tiffsplit.o tiffsplit.c
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tiffsplit.Tpo .deps/tiffsplit.Po
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffsplit tiffsplit.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffsplit tiffsplit.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools'
Making all in build
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/build'
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/build'
make[2]: Nothing to be done for 'all-am'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/build'
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/build'
Making all in contrib
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib'
Making all in addtiffo
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/addtiffo'
crepair-cc -DHAVE_CONFIG_H -I. -I../../config -I../../libtiff -I../../port  -I../../libtiff -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT addtiffo.o -MD -MP -MF .deps/addtiffo.Tpo -c -o addtiffo.o addtiffo.c
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/addtiffo.Tpo .deps/addtiffo.Po
crepair-cc -DHAVE_CONFIG_H -I. -I../../config -I../../libtiff -I../../port  -I../../libtiff -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_overview.o -MD -MP -MF .deps/tif_overview.Tpo -c -o tif_overview.o tif_overview.c
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_overview.Tpo .deps/tif_overview.Po
crepair-cc -DHAVE_CONFIG_H -I. -I../../config -I../../libtiff -I../../port  -I../../libtiff -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_ovrcache.o -MD -MP -MF .deps/tif_ovrcache.Tpo -c -o tif_ovrcache.o tif_ovrcache.c
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_ovrcache.Tpo .deps/tif_ovrcache.Po
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o addtiffo addtiffo.o tif_overview.o tif_ovrcache.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o addtiffo addtiffo.o tif_overview.o tif_ovrcache.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/addtiffo'
Making all in dbs
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs'
Making all in xtiff
make[3]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs/xtiff'
make[3]: Nothing to be done for 'all'.
make[3]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs/xtiff'
make[3]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs'
crepair-cc -DHAVE_CONFIG_H -I. -I../../config -I../../libtiff -I../../port  -I../../libtiff -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tiff-bi.o -MD -MP -MF .deps/tiff-bi.Tpo -c -o tiff-bi.o tiff-bi.c
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tiff-bi.Tpo .deps/tiff-bi.Po
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff-bi tiff-bi.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff-bi tiff-bi.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
crepair-cc -DHAVE_CONFIG_H -I. -I../../config -I../../libtiff -I../../port  -I../../libtiff -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tiff-grayscale.o -MD -MP -MF .deps/tiff-grayscale.Tpo -c -o tiff-grayscale.o tiff-grayscale.c
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tiff-grayscale.Tpo .deps/tiff-grayscale.Po
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff-grayscale tiff-grayscale.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff-grayscale tiff-grayscale.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
crepair-cc -DHAVE_CONFIG_H -I. -I../../config -I../../libtiff -I../../port  -I../../libtiff -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tiff-palette.o -MD -MP -MF .deps/tiff-palette.Tpo -c -o tiff-palette.o tiff-palette.c
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tiff-palette.Tpo .deps/tiff-palette.Po
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff-palette tiff-palette.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff-palette tiff-palette.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
crepair-cc -DHAVE_CONFIG_H -I. -I../../config -I../../libtiff -I../../port  -I../../libtiff -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tiff-rgb.o -MD -MP -MF .deps/tiff-rgb.Tpo -c -o tiff-rgb.o tiff-rgb.c
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tiff-rgb.Tpo .deps/tiff-rgb.Po
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff-rgb tiff-rgb.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff-rgb tiff-rgb.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
make[3]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs'
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs'
Making all in iptcutil
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/iptcutil'
crepair-cc -DHAVE_CONFIG_H -I. -I../../config -I../../libtiff -I../../port  -I../../libtiff -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT iptcutil.o -MD -MP -MF .deps/iptcutil.Tpo -c -o iptcutil.o iptcutil.c
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/iptcutil.Tpo .deps/iptcutil.Po
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o iptcutil iptcutil.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o iptcutil iptcutil.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/iptcutil'
Making all in mfs
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/mfs'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/mfs'
Making all in pds
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/pds'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/pds'
Making all in ras
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/ras'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/ras'
Making all in stream
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/stream'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/stream'
Making all in tags
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/tags'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/tags'
Making all in win_dib
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/win_dib'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/win_dib'
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib'
make[2]: Nothing to be done for 'all-am'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib'
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib'
Making all in test
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/test'
make[1]: Nothing to be done for 'all'.
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/test'
Making all in doc
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/doc'
make[1]: Nothing to be done for 'all'.
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/doc'
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src'
make[1]: Nothing to be done for 'all-am'.
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src'
2025-02-05 20:17:01.620 | INFO     | scenario:evaluate:635 - evaluating candidate patch #0:
@@ -356,12 +356,16 @@
 	return (realloc(p, (size_t) s));
 }
 
+
 void
 _TIFFmemset(void* p, int v, tmsize_t c)
 {
-	memset(p, v, (size_t) c);
+    if (p != NULL && c > 0) {
+        memset(p, v, (size_t) c);
+    }
 }
 
+
 void
 _TIFFmemcpy(void* d, const void* s, tmsize_t c)
 {

2025-02-05 20:17:01.626 | DEBUG    | scenario:rebuild:369 - original environment: environ({'CONDA_SHLVL': '2', 'LC_ALL': 'C.UTF-8', 'LS_COLORS': 'rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:', 'LD_LIBRARY_PATH': '/opt/crashrepair/lib:/CrashRepair/lib:/klee/build/lib:', 'CONDA_EXE': '/root/anaconda3/bin/conda', 'LANG': 'C.UTF-8', 'TZ': 'Asia/Shanghai', 'HOSTNAME': 'fea22102047d', 'OLDPWD': '/orchestrator', 'CONDA_PREFIX': '/root/anaconda3/envs/CrashRepair', '_CE_M': '', 'CC': 'crepair-cc', 'LLVM_COMPILER': 'clang', 'CONDA_PREFIX_1': '/root/anaconda3', 'PWD': '/orchestrator/crashrepair', 'HOME': '/root', 'CONDA_PYTHON_EXE': '/root/anaconda3/bin/python', '_CE_CONDA': '', 'CONDA_PROMPT_MODIFIER': '(CrashRepair) ', 'CXX': 'crepair-cxx', 'TERM': 'xterm', 'SHLVL': '2', 'PYTHONPATH': '/usr/lib/python3.8/site-packages:', 'PATH': '/root/anaconda3/envs/CrashRepair/bin:/root/anaconda3/condabin:~/anaconda3/bin:/opt/crashrepair/bin:/CrashRepair/compiler:/klee/build/bin:/opt/llvm-6/bin:/klee/build/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin', 'CONDA_DEFAULT_ENV': 'CrashRepair', '_': '/root/anaconda3/envs/CrashRepair/bin/python'})
2025-02-05 20:17:01.626 | DEBUG    | scenario:rebuild:382 - injecting ghost function into CFLAGS during build: -lcrepair_ghost
2025-02-05 20:17:01.626 | DEBUG    | scenario:rebuild:398 - using environment: {'INJECT_CFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address', 'INJECT_CXXFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address', 'INJECT_LDFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address'}
2025-02-05 20:17:01.626 | DEBUG    | shell:__call__:41 - executing: make CFLAGS="${INJECT_CFLAGS}" CXXFLAGS="${INJECT_CXXFLAGS}" LDFLAGS="${INJECT_LDFLAGS}"
Making all in port
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/port'
make  all-am
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/port'
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/port'
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/port'
Making all in libtiff
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff'
make  all-am
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff'
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_unix.lo -MD -MP -MF .deps/tif_unix.Tpo -c -o tif_unix.lo tif_unix.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_unix.lo -MD -MP -MF .deps/tif_unix.Tpo -c tif_unix.c -o tif_unix.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_unix.Tpo .deps/tif_unix.Plo
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -no-undefined -version-info 6:0:0  -Wl,--version-script=./libtiff.map -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o libtiff.la -rpath /usr/local/lib tif_aux.lo tif_close.lo tif_codec.lo tif_color.lo tif_compress.lo tif_dir.lo tif_dirinfo.lo tif_dirread.lo tif_dirwrite.lo tif_dumpmode.lo tif_error.lo tif_extension.lo tif_fax3.lo tif_fax3sm.lo tif_flush.lo tif_getimage.lo tif_jbig.lo tif_jpeg.lo tif_jpeg_12.lo tif_lerc.lo tif_luv.lo tif_lzma.lo tif_lzw.lo tif_next.lo tif_ojpeg.lo tif_open.lo tif_packbits.lo tif_pixarlog.lo tif_predict.lo tif_print.lo tif_read.lo tif_strip.lo tif_swab.lo tif_thunder.lo tif_tile.lo tif_version.lo tif_warning.lo tif_webp.lo tif_write.lo tif_zip.lo tif_zstd.lo  tif_unix.lo  -llzma -ljbig -ljpeg -lz -lm 
libtool: link: rm -fr  .libs/libtiff.a .libs/libtiff.la .libs/libtiff.lai
libtool: link: ar cru .libs/libtiff.a  tif_aux.o tif_close.o tif_codec.o tif_color.o tif_compress.o tif_dir.o tif_dirinfo.o tif_dirread.o tif_dirwrite.o tif_dumpmode.o tif_error.o tif_extension.o tif_fax3.o tif_fax3sm.o tif_flush.o tif_getimage.o tif_jbig.o tif_jpeg.o tif_jpeg_12.o tif_lerc.o tif_luv.o tif_lzma.o tif_lzw.o tif_next.o tif_ojpeg.o tif_open.o tif_packbits.o tif_pixarlog.o tif_predict.o tif_print.o tif_read.o tif_strip.o tif_swab.o tif_thunder.o tif_tile.o tif_version.o tif_warning.o tif_webp.o tif_write.o tif_zip.o tif_zstd.o tif_unix.o
ar: `u' modifier ignored since `D' is the default (see `U')
libtool: link: ranlib .libs/libtiff.a
libtool: link: ( cd ".libs" && rm -f "libtiff.la" && ln -s "../libtiff.la" "libtiff.la" )
/bin/bash ../libtool  --tag=CXX   --mode=link crepair-cxx  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -no-undefined -version-info 6:0:0  -Wl,--version-script=./libtiffxx.map -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o libtiffxx.la -rpath /usr/local/lib tif_stream.lo ../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: rm -fr  .libs/libtiffxx.a .libs/libtiffxx.la .libs/libtiffxx.lai
libtool: link: ar cru .libs/libtiffxx.a  tif_stream.o
ar: `u' modifier ignored since `D' is the default (see `U')
libtool: link: ranlib .libs/libtiffxx.a
libtool: link: ( cd ".libs" && rm -f "libtiffxx.la" && ln -s "../libtiffxx.la" "libtiffxx.la" )
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff'
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff'
Making all in tools
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools'
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o fax2ps fax2ps.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o fax2ps fax2ps.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o fax2tiff fax2tiff.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o fax2tiff fax2tiff.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o pal2rgb pal2rgb.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o pal2rgb pal2rgb.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o ppm2tiff ppm2tiff.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o ppm2tiff ppm2tiff.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o raw2tiff raw2tiff.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o raw2tiff raw2tiff.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff2bw tiff2bw.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff2bw tiff2bw.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff2pdf tiff2pdf.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff2pdf tiff2pdf.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff2ps tiff2ps.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff2ps tiff2ps.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff2rgba tiff2rgba.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff2rgba tiff2rgba.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffcmp tiffcmp.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffcmp tiffcmp.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffcp tiffcp.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffcp tiffcp.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffcrop tiffcrop.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffcrop tiffcrop.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffdither tiffdither.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffdither tiffdither.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffdump tiffdump.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffdump tiffdump.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffinfo tiffinfo.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffinfo tiffinfo.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffmedian tiffmedian.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffmedian tiffmedian.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffset tiffset.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffset tiffset.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffsplit tiffsplit.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffsplit tiffsplit.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools'
Making all in build
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/build'
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/build'
make[2]: Nothing to be done for 'all-am'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/build'
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/build'
Making all in contrib
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib'
Making all in addtiffo
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/addtiffo'
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o addtiffo addtiffo.o tif_overview.o tif_ovrcache.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o addtiffo addtiffo.o tif_overview.o tif_ovrcache.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/addtiffo'
Making all in dbs
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs'
Making all in xtiff
make[3]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs/xtiff'
make[3]: Nothing to be done for 'all'.
make[3]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs/xtiff'
make[3]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs'
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff-bi tiff-bi.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff-bi tiff-bi.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff-grayscale tiff-grayscale.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff-grayscale tiff-grayscale.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff-palette tiff-palette.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff-palette tiff-palette.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff-rgb tiff-rgb.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff-rgb tiff-rgb.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
make[3]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs'
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs'
Making all in iptcutil
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/iptcutil'
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o iptcutil iptcutil.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o iptcutil iptcutil.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/iptcutil'
Making all in mfs
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/mfs'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/mfs'
Making all in pds
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/pds'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/pds'
Making all in ras
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/ras'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/ras'
Making all in stream
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/stream'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/stream'
Making all in tags
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/tags'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/tags'
Making all in win_dib
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/win_dib'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/win_dib'
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib'
make[2]: Nothing to be done for 'all-am'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib'
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib'
Making all in test
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/test'
make[1]: Nothing to be done for 'all'.
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/test'
Making all in doc
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/doc'
make[1]: Nothing to be done for 'all'.
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/doc'
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src'
make[1]: Nothing to be done for 'all-am'.
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src'
2025-02-05 20:17:04.768 | DEBUG    | scenario:evaluate:655 - testing candidate #0 against test #crash...
2025-02-05 20:17:04.769 | DEBUG    | shell:__call__:41 - executing: /data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop -Z 1:3,2:4 -e divided /data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/exploit /dev/null
2025-02-05 20:17:04.789 | DEBUG    | test:run:189 - test failed: unexpected exit code (actual: 139, expected: 0)
2025-02-05 20:17:04.789 | INFO     | scenario:evaluate:662 - candidate #0 fails test #crash
2025-02-05 20:17:04.802 | INFO     | scenario:evaluate:635 - evaluating candidate patch #1:
@@ -356,12 +356,18 @@
 	return (realloc(p, (size_t) s));
 }
 
+
 void
 _TIFFmemset(void* p, int v, tmsize_t c)
 {
-	memset(p, v, (size_t) c);
+    if (p == NULL || c < 0) {
+        // Handle error: invalid pointer or size
+        return;
+    }
+    memset(p, v, (size_t) c);
 }
 
+
 void
 _TIFFmemcpy(void* d, const void* s, tmsize_t c)
 {

2025-02-05 20:17:04.809 | DEBUG    | scenario:rebuild:369 - original environment: environ({'CONDA_SHLVL': '2', 'LC_ALL': 'C.UTF-8', 'LS_COLORS': 'rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:', 'LD_LIBRARY_PATH': '/opt/crashrepair/lib:/CrashRepair/lib:/klee/build/lib:', 'CONDA_EXE': '/root/anaconda3/bin/conda', 'LANG': 'C.UTF-8', 'TZ': 'Asia/Shanghai', 'HOSTNAME': 'fea22102047d', 'OLDPWD': '/orchestrator', 'CONDA_PREFIX': '/root/anaconda3/envs/CrashRepair', '_CE_M': '', 'CC': 'crepair-cc', 'LLVM_COMPILER': 'clang', 'CONDA_PREFIX_1': '/root/anaconda3', 'PWD': '/orchestrator/crashrepair', 'HOME': '/root', 'CONDA_PYTHON_EXE': '/root/anaconda3/bin/python', '_CE_CONDA': '', 'CONDA_PROMPT_MODIFIER': '(CrashRepair) ', 'CXX': 'crepair-cxx', 'TERM': 'xterm', 'SHLVL': '2', 'PYTHONPATH': '/usr/lib/python3.8/site-packages:', 'PATH': '/root/anaconda3/envs/CrashRepair/bin:/root/anaconda3/condabin:~/anaconda3/bin:/opt/crashrepair/bin:/CrashRepair/compiler:/klee/build/bin:/opt/llvm-6/bin:/klee/build/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin', 'CONDA_DEFAULT_ENV': 'CrashRepair', '_': '/root/anaconda3/envs/CrashRepair/bin/python'})
2025-02-05 20:17:04.809 | DEBUG    | scenario:rebuild:382 - injecting ghost function into CFLAGS during build: -lcrepair_ghost
2025-02-05 20:17:04.809 | DEBUG    | scenario:rebuild:398 - using environment: {'INJECT_CFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address', 'INJECT_CXXFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address', 'INJECT_LDFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address'}
2025-02-05 20:17:04.809 | DEBUG    | shell:__call__:41 - executing: make CFLAGS="${INJECT_CFLAGS}" CXXFLAGS="${INJECT_CXXFLAGS}" LDFLAGS="${INJECT_LDFLAGS}"
Making all in port
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/port'
make  all-am
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/port'
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/port'
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/port'
Making all in libtiff
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff'
make  all-am
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff'
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_unix.lo -MD -MP -MF .deps/tif_unix.Tpo -c -o tif_unix.lo tif_unix.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_unix.lo -MD -MP -MF .deps/tif_unix.Tpo -c tif_unix.c -o tif_unix.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_unix.Tpo .deps/tif_unix.Plo
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -no-undefined -version-info 6:0:0  -Wl,--version-script=./libtiff.map -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o libtiff.la -rpath /usr/local/lib tif_aux.lo tif_close.lo tif_codec.lo tif_color.lo tif_compress.lo tif_dir.lo tif_dirinfo.lo tif_dirread.lo tif_dirwrite.lo tif_dumpmode.lo tif_error.lo tif_extension.lo tif_fax3.lo tif_fax3sm.lo tif_flush.lo tif_getimage.lo tif_jbig.lo tif_jpeg.lo tif_jpeg_12.lo tif_lerc.lo tif_luv.lo tif_lzma.lo tif_lzw.lo tif_next.lo tif_ojpeg.lo tif_open.lo tif_packbits.lo tif_pixarlog.lo tif_predict.lo tif_print.lo tif_read.lo tif_strip.lo tif_swab.lo tif_thunder.lo tif_tile.lo tif_version.lo tif_warning.lo tif_webp.lo tif_write.lo tif_zip.lo tif_zstd.lo  tif_unix.lo  -llzma -ljbig -ljpeg -lz -lm 
libtool: link: rm -fr  .libs/libtiff.a .libs/libtiff.la .libs/libtiff.lai
libtool: link: ar cru .libs/libtiff.a  tif_aux.o tif_close.o tif_codec.o tif_color.o tif_compress.o tif_dir.o tif_dirinfo.o tif_dirread.o tif_dirwrite.o tif_dumpmode.o tif_error.o tif_extension.o tif_fax3.o tif_fax3sm.o tif_flush.o tif_getimage.o tif_jbig.o tif_jpeg.o tif_jpeg_12.o tif_lerc.o tif_luv.o tif_lzma.o tif_lzw.o tif_next.o tif_ojpeg.o tif_open.o tif_packbits.o tif_pixarlog.o tif_predict.o tif_print.o tif_read.o tif_strip.o tif_swab.o tif_thunder.o tif_tile.o tif_version.o tif_warning.o tif_webp.o tif_write.o tif_zip.o tif_zstd.o tif_unix.o
ar: `u' modifier ignored since `D' is the default (see `U')
libtool: link: ranlib .libs/libtiff.a
libtool: link: ( cd ".libs" && rm -f "libtiff.la" && ln -s "../libtiff.la" "libtiff.la" )
/bin/bash ../libtool  --tag=CXX   --mode=link crepair-cxx  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -no-undefined -version-info 6:0:0  -Wl,--version-script=./libtiffxx.map -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o libtiffxx.la -rpath /usr/local/lib tif_stream.lo ../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: rm -fr  .libs/libtiffxx.a .libs/libtiffxx.la .libs/libtiffxx.lai
libtool: link: ar cru .libs/libtiffxx.a  tif_stream.o
ar: `u' modifier ignored since `D' is the default (see `U')
libtool: link: ranlib .libs/libtiffxx.a
libtool: link: ( cd ".libs" && rm -f "libtiffxx.la" && ln -s "../libtiffxx.la" "libtiffxx.la" )
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff'
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff'
Making all in tools
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools'
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o fax2ps fax2ps.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o fax2ps fax2ps.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o fax2tiff fax2tiff.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o fax2tiff fax2tiff.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o pal2rgb pal2rgb.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o pal2rgb pal2rgb.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o ppm2tiff ppm2tiff.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o ppm2tiff ppm2tiff.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o raw2tiff raw2tiff.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o raw2tiff raw2tiff.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff2bw tiff2bw.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff2bw tiff2bw.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff2pdf tiff2pdf.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff2pdf tiff2pdf.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff2ps tiff2ps.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff2ps tiff2ps.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff2rgba tiff2rgba.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff2rgba tiff2rgba.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffcmp tiffcmp.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffcmp tiffcmp.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffcp tiffcp.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffcp tiffcp.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffcrop tiffcrop.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffcrop tiffcrop.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffdither tiffdither.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffdither tiffdither.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffdump tiffdump.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffdump tiffdump.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffinfo tiffinfo.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffinfo tiffinfo.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffmedian tiffmedian.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffmedian tiffmedian.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffset tiffset.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffset tiffset.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffsplit tiffsplit.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffsplit tiffsplit.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools'
Making all in build
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/build'
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/build'
make[2]: Nothing to be done for 'all-am'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/build'
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/build'
Making all in contrib
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib'
Making all in addtiffo
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/addtiffo'
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o addtiffo addtiffo.o tif_overview.o tif_ovrcache.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o addtiffo addtiffo.o tif_overview.o tif_ovrcache.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/addtiffo'
Making all in dbs
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs'
Making all in xtiff
make[3]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs/xtiff'
make[3]: Nothing to be done for 'all'.
make[3]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs/xtiff'
make[3]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs'
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff-bi tiff-bi.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff-bi tiff-bi.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff-grayscale tiff-grayscale.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff-grayscale tiff-grayscale.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff-palette tiff-palette.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff-palette tiff-palette.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff-rgb tiff-rgb.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff-rgb tiff-rgb.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
make[3]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs'
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs'
Making all in iptcutil
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/iptcutil'
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o iptcutil iptcutil.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o iptcutil iptcutil.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/iptcutil'
Making all in mfs
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/mfs'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/mfs'
Making all in pds
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/pds'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/pds'
Making all in ras
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/ras'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/ras'
Making all in stream
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/stream'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/stream'
Making all in tags
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/tags'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/tags'
Making all in win_dib
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/win_dib'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/win_dib'
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib'
make[2]: Nothing to be done for 'all-am'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib'
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib'
Making all in test
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/test'
make[1]: Nothing to be done for 'all'.
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/test'
Making all in doc
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/doc'
make[1]: Nothing to be done for 'all'.
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/doc'
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src'
make[1]: Nothing to be done for 'all-am'.
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src'
2025-02-05 20:17:07.965 | DEBUG    | scenario:evaluate:655 - testing candidate #1 against test #crash...
2025-02-05 20:17:07.965 | DEBUG    | shell:__call__:41 - executing: /data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop -Z 1:3,2:4 -e divided /data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/exploit /dev/null
2025-02-05 20:17:07.993 | DEBUG    | test:run:189 - test failed: unexpected exit code (actual: 139, expected: 0)
2025-02-05 20:17:07.994 | INFO     | scenario:evaluate:662 - candidate #1 fails test #crash
2025-02-05 20:17:07.999 | INFO     | scenario:evaluate:635 - evaluating candidate patch #2:
@@ -356,12 +356,15 @@
 	return (realloc(p, (size_t) s));
 }
 
+
 void
 _TIFFmemset(void* p, int v, tmsize_t c)
 {
-	memset(p, v, (size_t) c);
+    if (c <= 0 || p == NULL) return; // Check for valid parameters
+    memset(p, v, (size_t) c);
 }
 
+
 void
 _TIFFmemcpy(void* d, const void* s, tmsize_t c)
 {

2025-02-05 20:17:08.005 | DEBUG    | scenario:rebuild:369 - original environment: environ({'CONDA_SHLVL': '2', 'LC_ALL': 'C.UTF-8', 'LS_COLORS': 'rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:', 'LD_LIBRARY_PATH': '/opt/crashrepair/lib:/CrashRepair/lib:/klee/build/lib:', 'CONDA_EXE': '/root/anaconda3/bin/conda', 'LANG': 'C.UTF-8', 'TZ': 'Asia/Shanghai', 'HOSTNAME': 'fea22102047d', 'OLDPWD': '/orchestrator', 'CONDA_PREFIX': '/root/anaconda3/envs/CrashRepair', '_CE_M': '', 'CC': 'crepair-cc', 'LLVM_COMPILER': 'clang', 'CONDA_PREFIX_1': '/root/anaconda3', 'PWD': '/orchestrator/crashrepair', 'HOME': '/root', 'CONDA_PYTHON_EXE': '/root/anaconda3/bin/python', '_CE_CONDA': '', 'CONDA_PROMPT_MODIFIER': '(CrashRepair) ', 'CXX': 'crepair-cxx', 'TERM': 'xterm', 'SHLVL': '2', 'PYTHONPATH': '/usr/lib/python3.8/site-packages:', 'PATH': '/root/anaconda3/envs/CrashRepair/bin:/root/anaconda3/condabin:~/anaconda3/bin:/opt/crashrepair/bin:/CrashRepair/compiler:/klee/build/bin:/opt/llvm-6/bin:/klee/build/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin', 'CONDA_DEFAULT_ENV': 'CrashRepair', '_': '/root/anaconda3/envs/CrashRepair/bin/python'})
2025-02-05 20:17:08.005 | DEBUG    | scenario:rebuild:382 - injecting ghost function into CFLAGS during build: -lcrepair_ghost
2025-02-05 20:17:08.005 | DEBUG    | scenario:rebuild:398 - using environment: {'INJECT_CFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address', 'INJECT_CXXFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address', 'INJECT_LDFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address'}
2025-02-05 20:17:08.005 | DEBUG    | shell:__call__:41 - executing: make CFLAGS="${INJECT_CFLAGS}" CXXFLAGS="${INJECT_CXXFLAGS}" LDFLAGS="${INJECT_LDFLAGS}"
Making all in port
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/port'
make  all-am
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/port'
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/port'
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/port'
Making all in libtiff
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff'
make  all-am
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff'
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_unix.lo -MD -MP -MF .deps/tif_unix.Tpo -c -o tif_unix.lo tif_unix.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_unix.lo -MD -MP -MF .deps/tif_unix.Tpo -c tif_unix.c -o tif_unix.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_unix.Tpo .deps/tif_unix.Plo
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -no-undefined -version-info 6:0:0  -Wl,--version-script=./libtiff.map -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o libtiff.la -rpath /usr/local/lib tif_aux.lo tif_close.lo tif_codec.lo tif_color.lo tif_compress.lo tif_dir.lo tif_dirinfo.lo tif_dirread.lo tif_dirwrite.lo tif_dumpmode.lo tif_error.lo tif_extension.lo tif_fax3.lo tif_fax3sm.lo tif_flush.lo tif_getimage.lo tif_jbig.lo tif_jpeg.lo tif_jpeg_12.lo tif_lerc.lo tif_luv.lo tif_lzma.lo tif_lzw.lo tif_next.lo tif_ojpeg.lo tif_open.lo tif_packbits.lo tif_pixarlog.lo tif_predict.lo tif_print.lo tif_read.lo tif_strip.lo tif_swab.lo tif_thunder.lo tif_tile.lo tif_version.lo tif_warning.lo tif_webp.lo tif_write.lo tif_zip.lo tif_zstd.lo  tif_unix.lo  -llzma -ljbig -ljpeg -lz -lm 
libtool: link: rm -fr  .libs/libtiff.a .libs/libtiff.la .libs/libtiff.lai
libtool: link: ar cru .libs/libtiff.a  tif_aux.o tif_close.o tif_codec.o tif_color.o tif_compress.o tif_dir.o tif_dirinfo.o tif_dirread.o tif_dirwrite.o tif_dumpmode.o tif_error.o tif_extension.o tif_fax3.o tif_fax3sm.o tif_flush.o tif_getimage.o tif_jbig.o tif_jpeg.o tif_jpeg_12.o tif_lerc.o tif_luv.o tif_lzma.o tif_lzw.o tif_next.o tif_ojpeg.o tif_open.o tif_packbits.o tif_pixarlog.o tif_predict.o tif_print.o tif_read.o tif_strip.o tif_swab.o tif_thunder.o tif_tile.o tif_version.o tif_warning.o tif_webp.o tif_write.o tif_zip.o tif_zstd.o tif_unix.o
ar: `u' modifier ignored since `D' is the default (see `U')
libtool: link: ranlib .libs/libtiff.a
libtool: link: ( cd ".libs" && rm -f "libtiff.la" && ln -s "../libtiff.la" "libtiff.la" )
/bin/bash ../libtool  --tag=CXX   --mode=link crepair-cxx  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -no-undefined -version-info 6:0:0  -Wl,--version-script=./libtiffxx.map -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o libtiffxx.la -rpath /usr/local/lib tif_stream.lo ../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: rm -fr  .libs/libtiffxx.a .libs/libtiffxx.la .libs/libtiffxx.lai
libtool: link: ar cru .libs/libtiffxx.a  tif_stream.o
ar: `u' modifier ignored since `D' is the default (see `U')
libtool: link: ranlib .libs/libtiffxx.a
libtool: link: ( cd ".libs" && rm -f "libtiffxx.la" && ln -s "../libtiffxx.la" "libtiffxx.la" )
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff'
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff'
Making all in tools
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools'
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o fax2ps fax2ps.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o fax2ps fax2ps.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o fax2tiff fax2tiff.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o fax2tiff fax2tiff.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o pal2rgb pal2rgb.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o pal2rgb pal2rgb.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o ppm2tiff ppm2tiff.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o ppm2tiff ppm2tiff.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o raw2tiff raw2tiff.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o raw2tiff raw2tiff.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff2bw tiff2bw.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff2bw tiff2bw.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff2pdf tiff2pdf.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff2pdf tiff2pdf.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff2ps tiff2ps.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff2ps tiff2ps.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff2rgba tiff2rgba.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff2rgba tiff2rgba.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffcmp tiffcmp.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffcmp tiffcmp.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffcp tiffcp.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffcp tiffcp.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffcrop tiffcrop.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffcrop tiffcrop.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffdither tiffdither.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffdither tiffdither.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffdump tiffdump.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffdump tiffdump.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffinfo tiffinfo.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffinfo tiffinfo.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffmedian tiffmedian.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffmedian tiffmedian.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffset tiffset.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffset tiffset.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffsplit tiffsplit.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffsplit tiffsplit.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools'
Making all in build
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/build'
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/build'
make[2]: Nothing to be done for 'all-am'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/build'
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/build'
Making all in contrib
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib'
Making all in addtiffo
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/addtiffo'
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o addtiffo addtiffo.o tif_overview.o tif_ovrcache.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o addtiffo addtiffo.o tif_overview.o tif_ovrcache.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/addtiffo'
Making all in dbs
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs'
Making all in xtiff
make[3]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs/xtiff'
make[3]: Nothing to be done for 'all'.
make[3]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs/xtiff'
make[3]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs'
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff-bi tiff-bi.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff-bi tiff-bi.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff-grayscale tiff-grayscale.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff-grayscale tiff-grayscale.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff-palette tiff-palette.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff-palette tiff-palette.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff-rgb tiff-rgb.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff-rgb tiff-rgb.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
make[3]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs'
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs'
Making all in iptcutil
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/iptcutil'
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o iptcutil iptcutil.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o iptcutil iptcutil.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/iptcutil'
Making all in mfs
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/mfs'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/mfs'
Making all in pds
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/pds'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/pds'
Making all in ras
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/ras'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/ras'
Making all in stream
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/stream'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/stream'
Making all in tags
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/tags'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/tags'
Making all in win_dib
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/win_dib'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/win_dib'
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib'
make[2]: Nothing to be done for 'all-am'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib'
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib'
Making all in test
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/test'
make[1]: Nothing to be done for 'all'.
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/test'
Making all in doc
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/doc'
make[1]: Nothing to be done for 'all'.
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/doc'
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src'
make[1]: Nothing to be done for 'all-am'.
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src'
2025-02-05 20:17:11.198 | DEBUG    | scenario:evaluate:655 - testing candidate #2 against test #crash...
2025-02-05 20:17:11.198 | DEBUG    | shell:__call__:41 - executing: /data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop -Z 1:3,2:4 -e divided /data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/exploit /dev/null
2025-02-05 20:17:11.218 | DEBUG    | test:run:189 - test failed: unexpected exit code (actual: 139, expected: 0)
2025-02-05 20:17:11.218 | INFO     | scenario:evaluate:662 - candidate #2 fails test #crash
2025-02-05 20:17:11.223 | INFO     | scenario:evaluate:635 - evaluating candidate patch #3:
@@ -356,12 +356,17 @@
 	return (realloc(p, (size_t) s));
 }
 
+
 void
 _TIFFmemset(void* p, int v, tmsize_t c)
 {
-	memset(p, v, (size_t) c);
+    if (p == NULL || c <= 0) {
+        return;
+    }
+    memset(p, v, (size_t) c);
 }
 
+
 void
 _TIFFmemcpy(void* d, const void* s, tmsize_t c)
 {

2025-02-05 20:17:11.240 | DEBUG    | scenario:rebuild:369 - original environment: environ({'CONDA_SHLVL': '2', 'LC_ALL': 'C.UTF-8', 'LS_COLORS': 'rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:', 'LD_LIBRARY_PATH': '/opt/crashrepair/lib:/CrashRepair/lib:/klee/build/lib:', 'CONDA_EXE': '/root/anaconda3/bin/conda', 'LANG': 'C.UTF-8', 'TZ': 'Asia/Shanghai', 'HOSTNAME': 'fea22102047d', 'OLDPWD': '/orchestrator', 'CONDA_PREFIX': '/root/anaconda3/envs/CrashRepair', '_CE_M': '', 'CC': 'crepair-cc', 'LLVM_COMPILER': 'clang', 'CONDA_PREFIX_1': '/root/anaconda3', 'PWD': '/orchestrator/crashrepair', 'HOME': '/root', 'CONDA_PYTHON_EXE': '/root/anaconda3/bin/python', '_CE_CONDA': '', 'CONDA_PROMPT_MODIFIER': '(CrashRepair) ', 'CXX': 'crepair-cxx', 'TERM': 'xterm', 'SHLVL': '2', 'PYTHONPATH': '/usr/lib/python3.8/site-packages:', 'PATH': '/root/anaconda3/envs/CrashRepair/bin:/root/anaconda3/condabin:~/anaconda3/bin:/opt/crashrepair/bin:/CrashRepair/compiler:/klee/build/bin:/opt/llvm-6/bin:/klee/build/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin', 'CONDA_DEFAULT_ENV': 'CrashRepair', '_': '/root/anaconda3/envs/CrashRepair/bin/python'})
2025-02-05 20:17:11.240 | DEBUG    | scenario:rebuild:382 - injecting ghost function into CFLAGS during build: -lcrepair_ghost
2025-02-05 20:17:11.240 | DEBUG    | scenario:rebuild:398 - using environment: {'INJECT_CFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address', 'INJECT_CXXFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address', 'INJECT_LDFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address'}
2025-02-05 20:17:11.240 | DEBUG    | shell:__call__:41 - executing: make CFLAGS="${INJECT_CFLAGS}" CXXFLAGS="${INJECT_CXXFLAGS}" LDFLAGS="${INJECT_LDFLAGS}"
Making all in port
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/port'
make  all-am
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/port'
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/port'
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/port'
Making all in libtiff
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff'
make  all-am
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff'
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_unix.lo -MD -MP -MF .deps/tif_unix.Tpo -c -o tif_unix.lo tif_unix.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_unix.lo -MD -MP -MF .deps/tif_unix.Tpo -c tif_unix.c -o tif_unix.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_unix.Tpo .deps/tif_unix.Plo
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -no-undefined -version-info 6:0:0  -Wl,--version-script=./libtiff.map -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o libtiff.la -rpath /usr/local/lib tif_aux.lo tif_close.lo tif_codec.lo tif_color.lo tif_compress.lo tif_dir.lo tif_dirinfo.lo tif_dirread.lo tif_dirwrite.lo tif_dumpmode.lo tif_error.lo tif_extension.lo tif_fax3.lo tif_fax3sm.lo tif_flush.lo tif_getimage.lo tif_jbig.lo tif_jpeg.lo tif_jpeg_12.lo tif_lerc.lo tif_luv.lo tif_lzma.lo tif_lzw.lo tif_next.lo tif_ojpeg.lo tif_open.lo tif_packbits.lo tif_pixarlog.lo tif_predict.lo tif_print.lo tif_read.lo tif_strip.lo tif_swab.lo tif_thunder.lo tif_tile.lo tif_version.lo tif_warning.lo tif_webp.lo tif_write.lo tif_zip.lo tif_zstd.lo  tif_unix.lo  -llzma -ljbig -ljpeg -lz -lm 
libtool: link: rm -fr  .libs/libtiff.a .libs/libtiff.la .libs/libtiff.lai
libtool: link: ar cru .libs/libtiff.a  tif_aux.o tif_close.o tif_codec.o tif_color.o tif_compress.o tif_dir.o tif_dirinfo.o tif_dirread.o tif_dirwrite.o tif_dumpmode.o tif_error.o tif_extension.o tif_fax3.o tif_fax3sm.o tif_flush.o tif_getimage.o tif_jbig.o tif_jpeg.o tif_jpeg_12.o tif_lerc.o tif_luv.o tif_lzma.o tif_lzw.o tif_next.o tif_ojpeg.o tif_open.o tif_packbits.o tif_pixarlog.o tif_predict.o tif_print.o tif_read.o tif_strip.o tif_swab.o tif_thunder.o tif_tile.o tif_version.o tif_warning.o tif_webp.o tif_write.o tif_zip.o tif_zstd.o tif_unix.o
ar: `u' modifier ignored since `D' is the default (see `U')
libtool: link: ranlib .libs/libtiff.a
libtool: link: ( cd ".libs" && rm -f "libtiff.la" && ln -s "../libtiff.la" "libtiff.la" )
/bin/bash ../libtool  --tag=CXX   --mode=link crepair-cxx  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -no-undefined -version-info 6:0:0  -Wl,--version-script=./libtiffxx.map -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o libtiffxx.la -rpath /usr/local/lib tif_stream.lo ../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: rm -fr  .libs/libtiffxx.a .libs/libtiffxx.la .libs/libtiffxx.lai
libtool: link: ar cru .libs/libtiffxx.a  tif_stream.o
ar: `u' modifier ignored since `D' is the default (see `U')
libtool: link: ranlib .libs/libtiffxx.a
libtool: link: ( cd ".libs" && rm -f "libtiffxx.la" && ln -s "../libtiffxx.la" "libtiffxx.la" )
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff'
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff'
Making all in tools
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools'
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o fax2ps fax2ps.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o fax2ps fax2ps.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o fax2tiff fax2tiff.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o fax2tiff fax2tiff.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o pal2rgb pal2rgb.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o pal2rgb pal2rgb.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o ppm2tiff ppm2tiff.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o ppm2tiff ppm2tiff.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o raw2tiff raw2tiff.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o raw2tiff raw2tiff.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff2bw tiff2bw.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff2bw tiff2bw.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff2pdf tiff2pdf.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff2pdf tiff2pdf.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff2ps tiff2ps.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff2ps tiff2ps.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff2rgba tiff2rgba.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff2rgba tiff2rgba.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffcmp tiffcmp.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffcmp tiffcmp.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffcp tiffcp.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffcp tiffcp.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffcrop tiffcrop.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffcrop tiffcrop.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffdither tiffdither.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffdither tiffdither.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffdump tiffdump.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffdump tiffdump.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffinfo tiffinfo.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffinfo tiffinfo.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffmedian tiffmedian.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffmedian tiffmedian.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffset tiffset.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffset tiffset.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffsplit tiffsplit.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffsplit tiffsplit.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools'
Making all in build
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/build'
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/build'
make[2]: Nothing to be done for 'all-am'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/build'
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/build'
Making all in contrib
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib'
Making all in addtiffo
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/addtiffo'
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o addtiffo addtiffo.o tif_overview.o tif_ovrcache.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o addtiffo addtiffo.o tif_overview.o tif_ovrcache.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/addtiffo'
Making all in dbs
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs'
Making all in xtiff
make[3]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs/xtiff'
make[3]: Nothing to be done for 'all'.
make[3]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs/xtiff'
make[3]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs'
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff-bi tiff-bi.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff-bi tiff-bi.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff-grayscale tiff-grayscale.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff-grayscale tiff-grayscale.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff-palette tiff-palette.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff-palette tiff-palette.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff-rgb tiff-rgb.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff-rgb tiff-rgb.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
make[3]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs'
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs'
Making all in iptcutil
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/iptcutil'
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o iptcutil iptcutil.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o iptcutil iptcutil.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/iptcutil'
Making all in mfs
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/mfs'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/mfs'
Making all in pds
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/pds'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/pds'
Making all in ras
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/ras'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/ras'
Making all in stream
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/stream'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/stream'
Making all in tags
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/tags'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/tags'
Making all in win_dib
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/win_dib'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/win_dib'
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib'
make[2]: Nothing to be done for 'all-am'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib'
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib'
Making all in test
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/test'
make[1]: Nothing to be done for 'all'.
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/test'
Making all in doc
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/doc'
make[1]: Nothing to be done for 'all'.
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/doc'
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src'
make[1]: Nothing to be done for 'all-am'.
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src'
2025-02-05 20:17:14.464 | DEBUG    | scenario:evaluate:655 - testing candidate #3 against test #crash...
2025-02-05 20:17:14.464 | DEBUG    | shell:__call__:41 - executing: /data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop -Z 1:3,2:4 -e divided /data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/exploit /dev/null
2025-02-05 20:17:14.482 | DEBUG    | test:run:189 - test failed: unexpected exit code (actual: 139, expected: 0)
2025-02-05 20:17:14.482 | INFO     | scenario:evaluate:662 - candidate #3 fails test #crash
2025-02-05 20:17:14.486 | INFO     | scenario:evaluate:635 - evaluating candidate patch #4:
@@ -356,12 +356,15 @@
 	return (realloc(p, (size_t) s));
 }
 
+
 void
 _TIFFmemset(void* p, int v, tmsize_t c)
 {
-	memset(p, v, (size_t) c);
+    if (c < 0) return; // Add check for negative size
+    memset(p, v, (size_t) c);
 }
 
+
 void
 _TIFFmemcpy(void* d, const void* s, tmsize_t c)
 {

2025-02-05 20:17:14.491 | DEBUG    | scenario:rebuild:369 - original environment: environ({'CONDA_SHLVL': '2', 'LC_ALL': 'C.UTF-8', 'LS_COLORS': 'rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:', 'LD_LIBRARY_PATH': '/opt/crashrepair/lib:/CrashRepair/lib:/klee/build/lib:', 'CONDA_EXE': '/root/anaconda3/bin/conda', 'LANG': 'C.UTF-8', 'TZ': 'Asia/Shanghai', 'HOSTNAME': 'fea22102047d', 'OLDPWD': '/orchestrator', 'CONDA_PREFIX': '/root/anaconda3/envs/CrashRepair', '_CE_M': '', 'CC': 'crepair-cc', 'LLVM_COMPILER': 'clang', 'CONDA_PREFIX_1': '/root/anaconda3', 'PWD': '/orchestrator/crashrepair', 'HOME': '/root', 'CONDA_PYTHON_EXE': '/root/anaconda3/bin/python', '_CE_CONDA': '', 'CONDA_PROMPT_MODIFIER': '(CrashRepair) ', 'CXX': 'crepair-cxx', 'TERM': 'xterm', 'SHLVL': '2', 'PYTHONPATH': '/usr/lib/python3.8/site-packages:', 'PATH': '/root/anaconda3/envs/CrashRepair/bin:/root/anaconda3/condabin:~/anaconda3/bin:/opt/crashrepair/bin:/CrashRepair/compiler:/klee/build/bin:/opt/llvm-6/bin:/klee/build/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin', 'CONDA_DEFAULT_ENV': 'CrashRepair', '_': '/root/anaconda3/envs/CrashRepair/bin/python'})
2025-02-05 20:17:14.491 | DEBUG    | scenario:rebuild:382 - injecting ghost function into CFLAGS during build: -lcrepair_ghost
2025-02-05 20:17:14.491 | DEBUG    | scenario:rebuild:398 - using environment: {'INJECT_CFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address', 'INJECT_CXXFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address', 'INJECT_LDFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address'}
2025-02-05 20:17:14.491 | DEBUG    | shell:__call__:41 - executing: make CFLAGS="${INJECT_CFLAGS}" CXXFLAGS="${INJECT_CXXFLAGS}" LDFLAGS="${INJECT_LDFLAGS}"
Making all in port
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/port'
make  all-am
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/port'
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/port'
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/port'
Making all in libtiff
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff'
make  all-am
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff'
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_unix.lo -MD -MP -MF .deps/tif_unix.Tpo -c -o tif_unix.lo tif_unix.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_unix.lo -MD -MP -MF .deps/tif_unix.Tpo -c tif_unix.c -o tif_unix.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_unix.Tpo .deps/tif_unix.Plo
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -no-undefined -version-info 6:0:0  -Wl,--version-script=./libtiff.map -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o libtiff.la -rpath /usr/local/lib tif_aux.lo tif_close.lo tif_codec.lo tif_color.lo tif_compress.lo tif_dir.lo tif_dirinfo.lo tif_dirread.lo tif_dirwrite.lo tif_dumpmode.lo tif_error.lo tif_extension.lo tif_fax3.lo tif_fax3sm.lo tif_flush.lo tif_getimage.lo tif_jbig.lo tif_jpeg.lo tif_jpeg_12.lo tif_lerc.lo tif_luv.lo tif_lzma.lo tif_lzw.lo tif_next.lo tif_ojpeg.lo tif_open.lo tif_packbits.lo tif_pixarlog.lo tif_predict.lo tif_print.lo tif_read.lo tif_strip.lo tif_swab.lo tif_thunder.lo tif_tile.lo tif_version.lo tif_warning.lo tif_webp.lo tif_write.lo tif_zip.lo tif_zstd.lo  tif_unix.lo  -llzma -ljbig -ljpeg -lz -lm 
libtool: link: rm -fr  .libs/libtiff.a .libs/libtiff.la .libs/libtiff.lai
libtool: link: ar cru .libs/libtiff.a  tif_aux.o tif_close.o tif_codec.o tif_color.o tif_compress.o tif_dir.o tif_dirinfo.o tif_dirread.o tif_dirwrite.o tif_dumpmode.o tif_error.o tif_extension.o tif_fax3.o tif_fax3sm.o tif_flush.o tif_getimage.o tif_jbig.o tif_jpeg.o tif_jpeg_12.o tif_lerc.o tif_luv.o tif_lzma.o tif_lzw.o tif_next.o tif_ojpeg.o tif_open.o tif_packbits.o tif_pixarlog.o tif_predict.o tif_print.o tif_read.o tif_strip.o tif_swab.o tif_thunder.o tif_tile.o tif_version.o tif_warning.o tif_webp.o tif_write.o tif_zip.o tif_zstd.o tif_unix.o
ar: `u' modifier ignored since `D' is the default (see `U')
libtool: link: ranlib .libs/libtiff.a
libtool: link: ( cd ".libs" && rm -f "libtiff.la" && ln -s "../libtiff.la" "libtiff.la" )
/bin/bash ../libtool  --tag=CXX   --mode=link crepair-cxx  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -no-undefined -version-info 6:0:0  -Wl,--version-script=./libtiffxx.map -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o libtiffxx.la -rpath /usr/local/lib tif_stream.lo ../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: rm -fr  .libs/libtiffxx.a .libs/libtiffxx.la .libs/libtiffxx.lai
libtool: link: ar cru .libs/libtiffxx.a  tif_stream.o
ar: `u' modifier ignored since `D' is the default (see `U')
libtool: link: ranlib .libs/libtiffxx.a
libtool: link: ( cd ".libs" && rm -f "libtiffxx.la" && ln -s "../libtiffxx.la" "libtiffxx.la" )
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff'
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff'
Making all in tools
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools'
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o fax2ps fax2ps.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o fax2ps fax2ps.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o fax2tiff fax2tiff.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o fax2tiff fax2tiff.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o pal2rgb pal2rgb.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o pal2rgb pal2rgb.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o ppm2tiff ppm2tiff.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o ppm2tiff ppm2tiff.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o raw2tiff raw2tiff.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o raw2tiff raw2tiff.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff2bw tiff2bw.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff2bw tiff2bw.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff2pdf tiff2pdf.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff2pdf tiff2pdf.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff2ps tiff2ps.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff2ps tiff2ps.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff2rgba tiff2rgba.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff2rgba tiff2rgba.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffcmp tiffcmp.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffcmp tiffcmp.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffcp tiffcp.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffcp tiffcp.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffcrop tiffcrop.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffcrop tiffcrop.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffdither tiffdither.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffdither tiffdither.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffdump tiffdump.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffdump tiffdump.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffinfo tiffinfo.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffinfo tiffinfo.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffmedian tiffmedian.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffmedian tiffmedian.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffset tiffset.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffset tiffset.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffsplit tiffsplit.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffsplit tiffsplit.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools'
Making all in build
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/build'
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/build'
make[2]: Nothing to be done for 'all-am'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/build'
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/build'
Making all in contrib
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib'
Making all in addtiffo
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/addtiffo'
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o addtiffo addtiffo.o tif_overview.o tif_ovrcache.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o addtiffo addtiffo.o tif_overview.o tif_ovrcache.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/addtiffo'
Making all in dbs
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs'
Making all in xtiff
make[3]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs/xtiff'
make[3]: Nothing to be done for 'all'.
make[3]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs/xtiff'
make[3]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs'
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff-bi tiff-bi.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff-bi tiff-bi.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff-grayscale tiff-grayscale.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff-grayscale tiff-grayscale.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff-palette tiff-palette.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff-palette tiff-palette.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff-rgb tiff-rgb.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff-rgb tiff-rgb.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
make[3]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs'
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs'
Making all in iptcutil
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/iptcutil'
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o iptcutil iptcutil.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o iptcutil iptcutil.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/iptcutil'
Making all in mfs
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/mfs'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/mfs'
Making all in pds
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/pds'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/pds'
Making all in ras
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/ras'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/ras'
Making all in stream
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/stream'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/stream'
Making all in tags
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/tags'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/tags'
Making all in win_dib
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/win_dib'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/win_dib'
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib'
make[2]: Nothing to be done for 'all-am'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib'
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib'
Making all in test
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/test'
make[1]: Nothing to be done for 'all'.
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/test'
Making all in doc
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/doc'
make[1]: Nothing to be done for 'all'.
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/doc'
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src'
make[1]: Nothing to be done for 'all-am'.
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src'
2025-02-05 20:17:17.680 | DEBUG    | scenario:evaluate:655 - testing candidate #4 against test #crash...
2025-02-05 20:17:17.681 | DEBUG    | shell:__call__:41 - executing: /data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop -Z 1:3,2:4 -e divided /data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/exploit /dev/null
2025-02-05 20:17:17.705 | DEBUG    | test:run:189 - test failed: unexpected exit code (actual: 139, expected: 0)
2025-02-05 20:17:17.705 | INFO     | scenario:evaluate:662 - candidate #4 fails test #crash
2025-02-05 20:17:17.710 | INFO     | scenario:evaluate:635 - evaluating candidate patch #5:
@@ -7678,236 +7678,232 @@
 
 
 /* Process selections defined by regions, zones, margins, or fixed sized areas */
+
 static int
 processCropSelections(struct image_data *image, struct crop_mask *crop, 
                       unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])
-  {
-  int       i;
-  uint32_t    width, length, total_width, total_length;
-  tsize_t   cropsize;
-  unsigned  char *crop_buff = NULL;
-  unsigned  char *read_buff = NULL;
-  unsigned  char *next_buff = NULL;
-  tsize_t   prev_cropsize = 0;
+{
+    int       i;
+    uint32_t    width, length, total_width, total_length;
+    tsize_t   cropsize;
+    unsigned  char *crop_buff = NULL;
+    unsigned  char *read_buff = NULL;
+    unsigned  char *next_buff = NULL;
+    tsize_t   prev_cropsize = 0;
 
-  read_buff = *read_buff_ptr;
+    read_buff = *read_buff_ptr;
 
-  if (crop->img_mode == COMPOSITE_IMAGES)
+    if (crop->img_mode == COMPOSITE_IMAGES)
     {
-    cropsize = crop->bufftotal;
-    crop_buff = seg_buffs[0].buffer; 
-    if (!crop_buff)
-      crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);
-    else
-      {
-      prev_cropsize = seg_buffs[0].size;
-      if (prev_cropsize < cropsize)
-        {
-        next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);
-        if (! next_buff)
-          {
-          _TIFFfree (crop_buff);
-          crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);
-          }
+        cropsize = crop->bufftotal;
+        crop_buff = seg_buffs[0].buffer; 
+        if (!crop_buff)
+            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);
         else
-          crop_buff = next_buff;
+        {
+            prev_cropsize = seg_buffs[0].size;
+            if (prev_cropsize < cropsize)
+            {
+                next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);
+                if (!next_buff)
+                {
+                    _TIFFfree(crop_buff);
+                    crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);
+                }
+                else
+                    crop_buff = next_buff;
+            }
         }
-      }
 
-    if (!crop_buff)
-      {
-      TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");
-      return (-1);
-      }
- 
-    _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);
-    seg_buffs[0].buffer = crop_buff;
-    seg_buffs[0].size = cropsize;
-
-    /* Checks for matching width or length as required */
-    if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)
-      return (1);
-
-    if (crop->crop_mode & CROP_INVERT)
-      {
-      switch (crop->photometric)
-        {
-        /* Just change the interpretation */
-        case PHOTOMETRIC_MINISWHITE:
-        case PHOTOMETRIC_MINISBLACK:
-	     image->photometric = crop->photometric;
-	     break;
-        case INVERT_DATA_ONLY:
-        case INVERT_DATA_AND_TAG:
-             if (invertImage(image->photometric, image->spp, image->bps, 
-                             crop->combined_width, crop->combined_length, crop_buff))
-               {
-               TIFFError("processCropSelections", 
-                         "Failed to invert colorspace for composite regions");
-               return (-1);
-               }
-             if (crop->photometric == INVERT_DATA_AND_TAG)
-               {
-               switch (image->photometric)
-                 {
-                 case PHOTOMETRIC_MINISWHITE:
- 	              image->photometric = PHOTOMETRIC_MINISBLACK;
-	              break;
-                 case PHOTOMETRIC_MINISBLACK:
- 	              image->photometric = PHOTOMETRIC_MINISWHITE;
-	              break;
-                 default:
-	              break;
-	         }
-	       }
-             break;
-        default: break;
+        if (!crop_buff)
+        {
+            TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");
+            return (-1);
         }
-      }
 
-    /* Mirror and Rotate will not work with multiple regions unless they are the same width */
-    if (crop->crop_mode & CROP_MIRROR)
-      {
-      if (mirrorImage(image->spp, image->bps, crop->mirror, 
-                      crop->combined_width, crop->combined_length, crop_buff))
-        {
-        TIFFError("processCropSelections", "Failed to mirror composite regions %s", 
-	         (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");
-        return (-1);
-        }
-      }
+        _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);
+        seg_buffs[0].buffer = crop_buff;
+        seg_buffs[0].size = cropsize;
 
-    if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */
-      {
-      if (rotateImage(crop->rotation, image, &crop->combined_width, 
-                      &crop->combined_length, &crop_buff))
-        {
-        TIFFError("processCropSelections", 
-                  "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);
-        return (-1);
-        }
-      seg_buffs[0].buffer = crop_buff;
-      seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)
-                            * image->spp) * crop->combined_length; 
-      }
-    }
-  else  /* Separated Images */
-    {
-    total_width = total_length = 0;
-    for (i = 0; i < crop->selections; i++)
-      {
+        /* Checks for matching width or length as required */
+        if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)
+            return (1);
 
-        cropsize = crop->bufftotal;
-      crop_buff = seg_buffs[i].buffer; 
-      if (!crop_buff)
-        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);
-      else
-        {
-        prev_cropsize = seg_buffs[0].size;
-        if (prev_cropsize < cropsize)
-          {
-          next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);
-          if (! next_buff)
+        if (crop->crop_mode & CROP_INVERT)
+        {
+            switch (crop->photometric)
             {
-            _TIFFfree (crop_buff);
-            crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);
+            case PHOTOMETRIC_MINISWHITE:
+            case PHOTOMETRIC_MINISBLACK:
+                image->photometric = crop->photometric;
+                break;
+            case INVERT_DATA_ONLY:
+            case INVERT_DATA_AND_TAG:
+                if (invertImage(image->photometric, image->spp, image->bps, 
+                                crop->combined_width, crop->combined_length, crop_buff))
+                {
+                    TIFFError("processCropSelections", 
+                              "Failed to invert colorspace for composite regions");
+                    return (-1);
+                }
+                if (crop->photometric == INVERT_DATA_AND_TAG)
+                {
+                    switch (image->photometric)
+                    {
+                    case PHOTOMETRIC_MINISWHITE:
+                        image->photometric = PHOTOMETRIC_MINISBLACK;
+                        break;
+                    case PHOTOMETRIC_MINISBLACK:
+                        image->photometric = PHOTOMETRIC_MINISWHITE;
+                        break;
+                    default:
+                        break;
+                    }
+                }
+                break;
+            default: break;
             }
-          else
-            crop_buff = next_buff;
-          }
         }
 
-      if (!crop_buff)
+        /* Mirror and Rotate will not work with multiple regions unless they are the same width */
+        if (crop->crop_mode & CROP_MIRROR)
         {
-        TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");
-        return (-1);
+            if (mirrorImage(image->spp, image->bps, crop->mirror, 
+                            crop->combined_width, crop->combined_length, crop_buff))
+            {
+                TIFFError("processCropSelections", "Failed to mirror composite regions %s", 
+                           (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");
+                return (-1);
+            }
         }
- 
-      _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);
-      seg_buffs[i].buffer = crop_buff;
-      seg_buffs[i].size = cropsize;
 
-      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))
+        if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */
         {
-	TIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);
-        return (-1);
-        }
-    
-      width  = crop->regionlist[i].width;
-      length = crop->regionlist[i].length;
-
-      if (crop->crop_mode & CROP_INVERT)
-        {
-        switch (crop->photometric)
-          {
-          /* Just change the interpretation */
-          case PHOTOMETRIC_MINISWHITE:
-          case PHOTOMETRIC_MINISBLACK:
-	       image->photometric = crop->photometric;
-	       break;
-          case INVERT_DATA_ONLY:
-          case INVERT_DATA_AND_TAG:
-               if (invertImage(image->photometric, image->spp, image->bps, 
-                               width, length, crop_buff))
-                 {
-                 TIFFError("processCropSelections", 
-                           "Failed to invert colorspace for region");
-                 return (-1);
-                 }
-               if (crop->photometric == INVERT_DATA_AND_TAG)
-                 {
-                 switch (image->photometric)
-                   {
-                   case PHOTOMETRIC_MINISWHITE:
- 	                image->photometric = PHOTOMETRIC_MINISBLACK;
-	                break;
-                   case PHOTOMETRIC_MINISBLACK:
- 	                image->photometric = PHOTOMETRIC_MINISWHITE;
-	                break;
-                   default:
-	                break;
-	           }
-	         }
-               break;
-          default: break;
-          }
+            if (rotateImage(crop->rotation, image, &crop->combined_width, 
+                            &crop->combined_length, &crop_buff))
+            {
+                TIFFError("processCropSelections", 
+                          "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);
+                return (-1);
+            }
+            seg_buffs[0].buffer = crop_buff;
+            seg_buffs[0].size = (((crop->combined_width * image->bps + 7) / 8)
+                                  * image->spp) * crop->combined_length; 
         }
-
-      if (crop->crop_mode & CROP_MIRROR)
+    }
+    else  /* Separated Images */
+    {
+        total_width = total_length = 0;
+        for (i = 0; i < crop->selections; i++)
         {
-        if (mirrorImage(image->spp, image->bps, crop->mirror, 
-                        width, length, crop_buff))
-          {
-          TIFFError("processCropSelections", "Failed to mirror crop region %s", 
-	           (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");
-          return (-1);
-          }
-        }
+            cropsize = crop->bufftotal;
+            crop_buff = seg_buffs[i].buffer; 
+            if (!crop_buff)
+                crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);
+            else
+            {
+                prev_cropsize = seg_buffs[i].size;
+                if (prev_cropsize < cropsize)
+                {
+                    next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);
+                    if (!next_buff)
+                    {
+                        _TIFFfree(crop_buff);
+                        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);
+                    }
+                    else
+                        crop_buff = next_buff;
+                }
+            }
 
-      if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */
-        {
-          /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it schouldn't do here, when more than one section is processed. 
-           * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!
-           */
-	if (rotateImage(crop->rotation, image, &crop->regionlist[i].width, 
-			&crop->regionlist[i].length, &crop_buff))
-          {
-          TIFFError("processCropSelections", 
-                    "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);
-          return (-1);
-          }
-        total_width  += crop->regionlist[i].width;
-        total_length += crop->regionlist[i].length;
-        crop->combined_width = total_width;
-        crop->combined_length = total_length;
-        seg_buffs[i].buffer = crop_buff;
-        seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)
-                               * image->spp) * crop->regionlist[i].length; 
-        }
-      }  /* for crop->selections loop */
+            if (!crop_buff)
+            {
+                TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");
+                return (-1);
+            }
+
+            _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);
+            seg_buffs[i].buffer = crop_buff;
+            seg_buffs[i].size = cropsize;
+
+            if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))
+            {
+                TIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);
+                return (-1);
+            }
+
+            width  = crop->regionlist[i].width;
+            length = crop->regionlist[i].length;
+
+            if (crop->crop_mode & CROP_INVERT)
+            {
+                switch (crop->photometric)
+                {
+                case PHOTOMETRIC_MINISWHITE:
+                case PHOTOMETRIC_MINISBLACK:
+                    image->photometric = crop->photometric;
+                    break;
+                case INVERT_DATA_ONLY:
+                case INVERT_DATA_AND_TAG:
+                    if (invertImage(image->photometric, image->spp, image->bps, 
+                                    width, length, crop_buff))
+                    {
+                        TIFFError("processCropSelections", 
+                                  "Failed to invert colorspace for region");
+                        return (-1);
+                    }
+                    if (crop->photometric == INVERT_DATA_AND_TAG)
+                    {
+                        switch (image->photometric)
+                        {
+                        case PHOTOMETRIC_MINISWHITE:
+                            image->photometric = PHOTOMETRIC_MINISBLACK;
+                            break;
+                        case PHOTOMETRIC_MINISBLACK:
+                            image->photometric = PHOTOMETRIC_MINISWHITE;
+                            break;
+                        default:
+                            break;
+                        }
+                    }
+                    break;
+                default: break;
+                }
+            }
+
+            if (crop->crop_mode & CROP_MIRROR)
+            {
+                if (mirrorImage(image->spp, image->bps, crop->mirror, 
+                                width, length, crop_buff))
+                {
+                    TIFFError("processCropSelections", "Failed to mirror crop region %s", 
+                               (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");
+                    return (-1);
+                }
+            }
+
+            if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */
+            {
+                if (rotateImage(crop->rotation, image, &crop->regionlist[i].width, 
+                                &crop->regionlist[i].length, &crop_buff))
+                {
+                    TIFFError("processCropSelections", 
+                              "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);
+                    return (-1);
+                }
+                total_width  += crop->regionlist[i].width;
+                total_length += crop->regionlist[i].length;
+                crop->combined_width = total_width;
+                crop->combined_length = total_length;
+                seg_buffs[i].buffer = crop_buff;
+                seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7) / 8)
+                                      * image->spp) * crop->regionlist[i].length; 
+            }
+        }  /* for crop->selections loop */
     }  /* Separated Images (else case) */
-  return (0);
-  } /* end processCropSelections */
+    return (0);
+} /* end processCropSelections */
+
 
 /* Copy the crop section of the data from the current image into a buffer
  * and adjust the IFD values to reflect the new size. If no cropping is

2025-02-05 20:17:17.719 | DEBUG    | scenario:rebuild:369 - original environment: environ({'CONDA_SHLVL': '2', 'LC_ALL': 'C.UTF-8', 'LS_COLORS': 'rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:', 'LD_LIBRARY_PATH': '/opt/crashrepair/lib:/CrashRepair/lib:/klee/build/lib:', 'CONDA_EXE': '/root/anaconda3/bin/conda', 'LANG': 'C.UTF-8', 'TZ': 'Asia/Shanghai', 'HOSTNAME': 'fea22102047d', 'OLDPWD': '/orchestrator', 'CONDA_PREFIX': '/root/anaconda3/envs/CrashRepair', '_CE_M': '', 'CC': 'crepair-cc', 'LLVM_COMPILER': 'clang', 'CONDA_PREFIX_1': '/root/anaconda3', 'PWD': '/orchestrator/crashrepair', 'HOME': '/root', 'CONDA_PYTHON_EXE': '/root/anaconda3/bin/python', '_CE_CONDA': '', 'CONDA_PROMPT_MODIFIER': '(CrashRepair) ', 'CXX': 'crepair-cxx', 'TERM': 'xterm', 'SHLVL': '2', 'PYTHONPATH': '/usr/lib/python3.8/site-packages:', 'PATH': '/root/anaconda3/envs/CrashRepair/bin:/root/anaconda3/condabin:~/anaconda3/bin:/opt/crashrepair/bin:/CrashRepair/compiler:/klee/build/bin:/opt/llvm-6/bin:/klee/build/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin', 'CONDA_DEFAULT_ENV': 'CrashRepair', '_': '/root/anaconda3/envs/CrashRepair/bin/python'})
2025-02-05 20:17:17.719 | DEBUG    | scenario:rebuild:382 - injecting ghost function into CFLAGS during build: -lcrepair_ghost
2025-02-05 20:17:17.719 | DEBUG    | scenario:rebuild:398 - using environment: {'INJECT_CFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address', 'INJECT_CXXFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address', 'INJECT_LDFLAGS': '-g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address'}
2025-02-05 20:17:17.719 | DEBUG    | shell:__call__:41 - executing: make CFLAGS="${INJECT_CFLAGS}" CXXFLAGS="${INJECT_CXXFLAGS}" LDFLAGS="${INJECT_LDFLAGS}"
Making all in port
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/port'
make  all-am
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/port'
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/port'
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/port'
Making all in libtiff
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff'
make  all-am
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff'
/bin/bash ../libtool  --tag=CC   --mode=compile crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port  -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_unix.lo -MD -MP -MF .deps/tif_unix.Tpo -c -o tif_unix.lo tif_unix.c
libtool: compile:  crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../port -I../libtiff -I../port -DLERC_STATIC -I/usr/bin/ -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tif_unix.lo -MD -MP -MF .deps/tif_unix.Tpo -c tif_unix.c -o tif_unix.o
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tif_unix.Tpo .deps/tif_unix.Plo
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -no-undefined -version-info 6:0:0  -Wl,--version-script=./libtiff.map -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o libtiff.la -rpath /usr/local/lib tif_aux.lo tif_close.lo tif_codec.lo tif_color.lo tif_compress.lo tif_dir.lo tif_dirinfo.lo tif_dirread.lo tif_dirwrite.lo tif_dumpmode.lo tif_error.lo tif_extension.lo tif_fax3.lo tif_fax3sm.lo tif_flush.lo tif_getimage.lo tif_jbig.lo tif_jpeg.lo tif_jpeg_12.lo tif_lerc.lo tif_luv.lo tif_lzma.lo tif_lzw.lo tif_next.lo tif_ojpeg.lo tif_open.lo tif_packbits.lo tif_pixarlog.lo tif_predict.lo tif_print.lo tif_read.lo tif_strip.lo tif_swab.lo tif_thunder.lo tif_tile.lo tif_version.lo tif_warning.lo tif_webp.lo tif_write.lo tif_zip.lo tif_zstd.lo  tif_unix.lo  -llzma -ljbig -ljpeg -lz -lm 
libtool: link: rm -fr  .libs/libtiff.a .libs/libtiff.la .libs/libtiff.lai
libtool: link: ar cru .libs/libtiff.a  tif_aux.o tif_close.o tif_codec.o tif_color.o tif_compress.o tif_dir.o tif_dirinfo.o tif_dirread.o tif_dirwrite.o tif_dumpmode.o tif_error.o tif_extension.o tif_fax3.o tif_fax3sm.o tif_flush.o tif_getimage.o tif_jbig.o tif_jpeg.o tif_jpeg_12.o tif_lerc.o tif_luv.o tif_lzma.o tif_lzw.o tif_next.o tif_ojpeg.o tif_open.o tif_packbits.o tif_pixarlog.o tif_predict.o tif_print.o tif_read.o tif_strip.o tif_swab.o tif_thunder.o tif_tile.o tif_version.o tif_warning.o tif_webp.o tif_write.o tif_zip.o tif_zstd.o tif_unix.o
ar: `u' modifier ignored since `D' is the default (see `U')
libtool: link: ranlib .libs/libtiff.a
libtool: link: ( cd ".libs" && rm -f "libtiff.la" && ln -s "../libtiff.la" "libtiff.la" )
/bin/bash ../libtool  --tag=CXX   --mode=link crepair-cxx  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -no-undefined -version-info 6:0:0  -Wl,--version-script=./libtiffxx.map -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o libtiffxx.la -rpath /usr/local/lib tif_stream.lo ../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: rm -fr  .libs/libtiffxx.a .libs/libtiffxx.la .libs/libtiffxx.lai
libtool: link: ar cru .libs/libtiffxx.a  tif_stream.o
ar: `u' modifier ignored since `D' is the default (see `U')
libtool: link: ranlib .libs/libtiffxx.a
libtool: link: ( cd ".libs" && rm -f "libtiffxx.la" && ln -s "../libtiffxx.la" "libtiffxx.la" )
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff'
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/libtiff'
Making all in tools
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools'
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o fax2ps fax2ps.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o fax2ps fax2ps.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o fax2tiff fax2tiff.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o fax2tiff fax2tiff.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o pal2rgb pal2rgb.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o pal2rgb pal2rgb.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o ppm2tiff ppm2tiff.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o ppm2tiff ppm2tiff.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o raw2tiff raw2tiff.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o raw2tiff raw2tiff.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff2bw tiff2bw.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff2bw tiff2bw.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff2pdf tiff2pdf.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff2pdf tiff2pdf.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff2ps tiff2ps.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff2ps tiff2ps.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff2rgba tiff2rgba.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff2rgba tiff2rgba.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffcmp tiffcmp.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffcmp tiffcmp.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffcp tiffcp.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffcp tiffcp.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
crepair-cc -DHAVE_CONFIG_H -I. -I../config -I../libtiff -I../port  -I../libtiff -I../port -I/usr/bin/   -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -MT tiffcrop.o -MD -MP -MF .deps/tiffcrop.Tpo -c -o tiffcrop.o tiffcrop.c
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_ghost: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_runtime: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lcrepair_proxy: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: -lkleeRuntest: 'linker' input unused [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/lib' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/CrashRepair/compiler/../lib/' [-Wunused-command-line-argument]
clang-6.0: warning: argument unused during compilation: '-L/klee/build/lib/' [-Wunused-command-line-argument]
mv -f .deps/tiffcrop.Tpo .deps/tiffcrop.Po
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffcrop tiffcrop.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffcrop tiffcrop.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffdither tiffdither.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffdither tiffdither.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffdump tiffdump.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffdump tiffdump.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffinfo tiffinfo.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffinfo tiffinfo.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffmedian tiffmedian.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffmedian tiffmedian.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffset tiffset.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffset tiffset.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiffsplit tiffsplit.o ../libtiff/libtiff.la ../port/libport.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiffsplit tiffsplit.o  -L/klee/build/lib -L/CrashRepair/lib ../libtiff/.libs/libtiff.a ../port/.libs/libport.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools'
Making all in build
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/build'
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/build'
make[2]: Nothing to be done for 'all-am'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/build'
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/build'
Making all in contrib
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib'
Making all in addtiffo
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/addtiffo'
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o addtiffo addtiffo.o tif_overview.o tif_ovrcache.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o addtiffo addtiffo.o tif_overview.o tif_ovrcache.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/addtiffo'
Making all in dbs
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs'
Making all in xtiff
make[3]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs/xtiff'
make[3]: Nothing to be done for 'all'.
make[3]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs/xtiff'
make[3]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs'
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff-bi tiff-bi.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff-bi tiff-bi.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff-grayscale tiff-grayscale.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff-grayscale tiff-grayscale.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff-palette tiff-palette.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff-palette tiff-palette.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o tiff-rgb tiff-rgb.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o tiff-rgb tiff-rgb.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
make[3]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs'
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/dbs'
Making all in iptcutil
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/iptcutil'
/bin/bash ../../libtool  --tag=CC   --mode=link crepair-cc  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address  -g -O0 -Wno-error -L/klee/build/lib -lkleeRuntest -I/CrashRepair/lib -L/CrashRepair/lib -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -fsanitize=address -o iptcutil iptcutil.o ../../libtiff/libtiff.la -llzma -ljbig -ljpeg -lz -lm 
libtool: link: crepair-cc -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -g -O0 -Wno-error -I/CrashRepair/lib -fsanitize=address -o iptcutil iptcutil.o  -L/klee/build/lib -L/CrashRepair/lib ../../libtiff/.libs/libtiff.a -lkleeRuntest -lcrepair_runtime -lcrepair_proxy -lcrepair_ghost -llzma -ljbig -ljpeg -lz -lm
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/iptcutil'
Making all in mfs
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/mfs'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/mfs'
Making all in pds
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/pds'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/pds'
Making all in ras
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/ras'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/ras'
Making all in stream
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/stream'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/stream'
Making all in tags
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/tags'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/tags'
Making all in win_dib
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/win_dib'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib/win_dib'
make[2]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib'
make[2]: Nothing to be done for 'all-am'.
make[2]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib'
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/contrib'
Making all in test
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/test'
make[1]: Nothing to be done for 'all'.
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/test'
Making all in doc
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/doc'
make[1]: Nothing to be done for 'all'.
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/doc'
make[1]: Entering directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src'
make[1]: Nothing to be done for 'all-am'.
make[1]: Leaving directory '/data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src'
2025-02-05 20:17:21.200 | DEBUG    | scenario:evaluate:655 - testing candidate #5 against test #crash...
2025-02-05 20:17:21.200 | DEBUG    | shell:__call__:41 - executing: /data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/src/tools/tiffcrop -Z 1:3,2:4 -e divided /data/vulnloc/libtiff/REDTEAM-CVE-2022-48281/exploit /dev/null
2025-02-05 20:17:21.213 | INFO     | scenario:evaluate:659 - candidate #5 passes test #crash
2025-02-05 20:17:21.214 | INFO     | scenario:evaluate:674 - repair found! candidate #5 passes all tests
2025-02-05 20:17:21.220 | INFO     | scenario:validate:513 - saving successful patch #5...
2025-02-05 20:17:21.220 | INFO     | scenario:validate:520 - stopping search: patch was found

