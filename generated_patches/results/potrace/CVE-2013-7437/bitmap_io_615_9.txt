@@ -431,6 +431,7 @@
    although most specifications only allow 1,4,8,24,32. We can also
    read both the old and new OS/2 BMP formats in addition to the
    Windows BMP format. */
+
 static int bm_readbody_bmp(FILE *f, double threshold, potrace_bitmap_t **bmp) {
   bmp_info_t bmpinfo;
   int *coltable;
@@ -592,7 +593,11 @@
 	b = bitbuf >> (INTBITS - bmpinfo.bits);
 	bitbuf <<= bmpinfo.bits;
 	n -= bmpinfo.bits;
-	BM_UPUT(bm, x, ycorr(y), coltable[b]);
+	if (c <= 3 * threshold * 255) {
+	  BM_UPUT(bm, x, ycorr(y), coltable[b]);
+	} else {
+	  // handle cases where color value exceeds threshold
+	}
       }
       TRY(bmp_pad(f));
     }
@@ -612,7 +617,11 @@
       for (x=0; x<bmpinfo.w; x++) {
         TRY_EOF(bmp_readint(f, bmpinfo.bits/8, &c));
 	c = ((c>>16) & 0xff) + ((c>>8) & 0xff) + (c & 0xff);
-        BM_UPUT(bm, x, ycorr(y), c > 3 * threshold * 255 ? 0 : 1);
+	if (c <= 3 * threshold * 255) {
+	  BM_UPUT(bm, x, ycorr(y), 0);
+	} else {
+	  BM_UPUT(bm, x, ycorr(y), 1);
+	}
       }
       TRY(bmp_pad(f));
     }
@@ -628,7 +637,11 @@
       for (x=0; x<bmpinfo.w; x++) {
         TRY_EOF(bmp_readint(f, bmpinfo.bits/8, &c));
 	c = ((c & bmpinfo.RedMask) >> redshift) + ((c & bmpinfo.GreenMask) >> greenshift) + ((c & bmpinfo.BlueMask) >> blueshift);
-        BM_UPUT(bm, x, ycorr(y), c > 3 * threshold * 255 ? 0 : 1);
+	if (c <= 3 * threshold * 255) {
+	  BM_UPUT(bm, x, ycorr(y), 0);
+	} else {
+	  BM_UPUT(bm, x, ycorr(y), 1);
+	}
       }
       TRY(bmp_pad(f));
     }
@@ -776,6 +789,7 @@
   return -1;
 }
 
+
 /* ---------------------------------------------------------------------- */
 /* output pbm format */
 
